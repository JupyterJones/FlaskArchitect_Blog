-





import twython
from twython import Twython
from APIkey import APIkey
CONSUMER_KEY = APIkey()[0]
CONSUMER_SECRET = APIkey()[1]
ACCESS_KEY = APIkey()[2]
ACCESS_SECRET = APIkey()[3]

twitter = Twython(CONSUMER_KEY, CONSUMER_SECRET, ACCESS_KEY, ACCESS_SECRET)

def post(message):
    #twitter.update_status(status='See how easy using Twython is!')
    twitter.update_status(status=message)#, in_reply_to_status_id=twitter_id)

STR ="""
blurred = cv2.GaussianBlur(gray, (3, 3), 0)
# apply Canny edge detection using a wide threshold, tight
# threshold, and automatically determined threshold
wide = cv2.Canny(blurred, 10, 200)
cv2.imwrite("mahotastest/wide.jpg", wide)
"""
message = STR
print(len(message))


post(message)

from twython import Twython
from APIkey import APIkey
CONSUMER_KEY = APIkey()[0]
CONSUMER_SECRET = APIkey()[1]
ACCESS_KEY = APIkey()[2]
ACCESS_SECRET = APIkey()[3]

twitter = Twython(CONSUMER_KEY, CONSUMER_SECRET, ACCESS_KEY, ACCESS_SECRET)
STR ="""
blurred = cv2.GaussianBlur(gray, (3, 3), 0)
# apply Canny edge detection using a wide threshold, tight
# threshold, and automatically determined threshold
wide = cv2.Canny(blurred, 10, 200)
cv2.imwrite("mahotastest/wide.jpg", wide)
"""
message = STR
photo = open('/home/jack/Desktop/dockercommands/mahotastest/wide-inverted.jpg', 'rb')
response = twitter.upload_media(media = photo)
twitter.update_status(status = STR, media_ids = [response['media_id']])

from twython
import Twython
twitter = Twython(APP_KEY, APP_SECRET,
   OAUTH_TOKEN, OAUTH_TOKEN_SECRET)

photo = open('/path/to/file/image.jpg', 'rb')
response = twitter.upload_media(media = photo)
twitter.update_status(status = 'Checkout this cool image!', media_ids = [response['media_id']])

video = open('/path/to/file/video.mp4', 'rb')
response = twitter.upload_video(media = video, media_type = 'video/mp4')
twitter.update_status(status = 'Checkout this cool video!', media_ids = [response['media_id']])

response = twitter.upload_media(media=photo)
twitter.update_status(status=STRu, media_ids=[response['media_id']])

#note7
from PIL import Image
import numpy as np
import cv2
import imageio
from FileNameP import FilenameByTime


def auto_canny(image, sigma=0.33):
    # compute the median of the single channel pixel intensities
    v = np.median(image)
    # apply automatic Canny edge detection using the computed median
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)
    # return the edged image
    return edged

#image = cv2.imread('mahotastest/orig-color.png')
filename1 = '/home/jack/Desktop/dockercommands/images/useresult.png'
image = cv2.imread(filename1)
edged = auto_canny(image, sigma=0.33)
inverted = cv2.bitwise_not(edged)
cv2.imwrite("mahotastest/temp2.png", inverted)
cv2.imwrite(FilenameByTime("mahotastest/"), inverted)



# Open Front Image
#frontimage = Image.open('mahotastest/inverted-bitwise-note3_6.png').convert("1")
frontimage = Image.open('mahotastest/temp2.png').convert("1")
frontImage = frontimage.convert("RGBA")
datas = frontImage.getdata()


newData = []
for item in datas:
    if item[0] == 255 and item[1] == 255 and item[2] == 255:
        newData.append((255, 255, 255, 0))
    else:
        newData.append(item)

frontImage.putdata(newData)
#frontImage.save("mahotastest/frontImage-note7.png", "PNG")

# Back Image
#image = cv2.imread('mahotastest/orig-color.png')
#filename1 = '/home/jack/Desktop/Imagedata/0-original-images/05140orig.jpg'
# Open Background Image
background = Image.open(filename1)
#background = cv2.imread('mahotastest/orig-color.png')#.convert("RGBA")

# Convert image to RGBA
#frontImage = frontImage.convert("RGBA")

# Convert image to RGBA
#background = background.convert("RGBA")

# Calculate width to be at the center
width = (frontimage.width - frontimage.width) // 2

# Calculate height to be at the center
height = (frontimage.height - frontimage.height) // 2

# Paste the frontImage at (width, height)
background.paste(frontImage, (width, height), frontImage)

# Save this image
background.save("mahotastest/-atlast000.png", format="png")
background.save(FilenameByTime("mahotastest/"), format="png")
#background = background.convert("RGB")



#py38
import sys
sys.path

#py36
import sys
sys.path

#py31
import sys
sys.path

#cloned_base
import sys
sys.path

#butterflow38
import sys
sys.path

#base
import sys
sys.path

# Python3 (ipykernel)
import sys
sys.path



#py38
import sys
sys.path

#py36
import sys
sys.path

#py31
import sys
sys.path

#cloned_base
import sys
sys.path

#butterflow38
import sys
sys.path

#base
import sys
sys.path

# Python3 (ipykernel)
import sys
sys.path



!ls /home/jack/.local/share/lbry/lbrynet/lbrynet.sqlite

import sqlite3
def dbinfo(database):
    conn = sqlite3.connect(database)
    conn.text_factory = str
    c = conn.cursor()
    res = c.execute("SELECT name FROM sqlite_master WHERE type='table';")
    row = c.fetchone()
    row = str(row)
    row = row.replace("(","");row = row.replace(",)","")
    row = row.replace("'","")
    print ("Table: ",row)
    cur = c.execute("select * from '%s'" %  row)
    columns = [description[0] for description in cur.description]
    return "COLUMNS :",columns

# if run directly
database="/home/jack/.local/share/lbry/lbrynet/lbrynet.sqlite"
dbinfo(database)


import sqlite3
# Define a function
def peek_in(database):
    cnt=0
    # connect to a database
    conn = sqlite3.connect(database)
    # FYI - In this case 'text_factory' not required I use it from habit
    # By default "conn" is set to unicode and the sqlite3 module will return Unicode objects for TEXT
    # If you use "text_factory = st". it returns bytestrings instead.
    conn.text_factory = str
    c = conn.cursor()
    for res in c.execute("SELECT ROWID,* FROM blob;"):
        cnt=cnt+1
        if cnt<5:
            print ("------------- ROWiD :",res[0],"---------------\n")
            print ('blob_hash :',res[1])
            print ('blob_length :',res[2])
            print ('next_announce_time :',res[3])
            print ('should_announce :',res[4])
            print ('status :',res[5])
            print ('last_announced_time :',res[6])
            print ('single_announce :',res[7])
            print ("---------------------------------------\n")
        
database="/home/jack/.local/share/lbry/lbrynet/lbrynet.sqlite"    
peek_in(database)    
    



!ls /home/jack/.local/share/lbry/lbrynet/lbrynet.sqlite

import sqlite3
def dbinfo(database):
    conn = sqlite3.connect(database)
    conn.text_factory = str
    c = conn.cursor()
    res = c.execute("SELECT name FROM sqlite_master WHERE type='table';")
    row = c.fetchone()
    row = str(row)
    row = row.replace("(","");row = row.replace(",)","")
    row = row.replace("'","")
    print ("Table: ",row)
    cur = c.execute("select * from '%s'" %  row)
    columns = [description[0] for description in cur.description]
    return "COLUMNS :",columns

# if run directly
database="/home/jack/.local/share/lbry/lbrynet/lbrynet.sqlite"
dbinfo(database)


import sqlite3
# Define a function
def peek_in(database):
    cnt=0
    # connect to a database
    conn = sqlite3.connect(database)
    # FYI - In this case 'text_factory' not required I use it from habit
    # By default "conn" is set to unicode and the sqlite3 module will return Unicode objects for TEXT
    # If you use "text_factory = st". it returns bytestrings instead.
    conn.text_factory = str
    c = conn.cursor()
    for res in c.execute("SELECT ROWID,* FROM blob;"):
        cnt=cnt+1
        if cnt<5:
            print ("------------- ROWiD :",res[0],"---------------\n")
            print ('blob_hash :',res[1])
            print ('blob_length :',res[2])
            print ('next_announce_time :',res[3])
            print ('should_announce :',res[4])
            print ('status :',res[5])
            print ('last_announced_time :',res[6])
            print ('single_announce :',res[7])
            print ("---------------------------------------\n")
        
database="/home/jack/.local/share/lbry/lbrynet/lbrynet.sqlite"    
peek_in(database)    
    



https://www.kaggle.com/datasets/teksab/imagenetvggverydeep19mat?resource=download

import os
import sys
import scipy.io
import scipy.misc
import matplotlib.pyplot as plt
from matplotlib.pyplot import imshow
from PIL import Image
#from nst_utils import *
import numpy as np
import tensorflow as tf

%matplotlib inline

!ls models

model = open("models/imagenet-vgg-verydeep-19.mat","rb")

from keras.applications.vgg16 import VGG16
model = VGG16(weights='imagenet')
print(model.summary())

from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.vgg16 import preprocess_input,decode_predictions
import numpy as np

img_path = 'images/Poodle-Canis-familiaris-white.jpg'
#There is an interpolation method to match the source size with the target size
#image loaded in PIL (Python Imaging Library)
img = image.load_img(img_path,color_mode='rgb', target_size=(224, 224))
display(img)

# Converts a PIL Image to 3D Numy Array
x = image.img_to_array(img)
x.shape
# Adding the fouth dimension, for number of images
x = np.expand_dims(x, axis=0)

#mean centering with respect to Image
x = preprocess_input(x)
features = model.predict(x)
p = decode_predictions(features)

#model = load_vgg_model("/home/jack/Desktop/TENSORFLOW/models/imagenet-vgg-verydeep-19.mat")
model = open("/home/jack/Desktop/TENSORFLOW/models/imagenet-vgg-verydeep-19.mat","rb").read()
#print(model)

import imageio
content_image = imageio.imread('images/Poodle-Canis-familiaris-white.jpg')
content_image.shape  # im is a numpy array
(512, 512, 3)
#content_image = imageio.imwrite('imageio:astronaut-gray.jpg', im[:, :, 0])

imshow(content_image)

# GRADED FUNCTION: compute_content_cost

def compute_content_cost(a_C, a_G):
    """
    Computes the content cost
    
    Arguments:
    a_C -- tensor of dimension (1, n_H, n_W, n_C), hidden layer activations representing content of the image C 
    a_G -- tensor of dimension (1, n_H, n_W, n_C), hidden layer activations representing content of the image G
    
    Returns: 
    J_content -- scalar that you compute using equation 1 above.
    """
    
    ### START CODE HERE ###
    # Retrieve dimensions from a_G (≈1 line)
    m, n_H, n_W, n_C = a_G.get_shape().as_list()
    
    # Reshape a_C and a_G (≈2 lines)
    a_C_unrolled = tf.reshape(a_C,shape=[m, n_H*n_W, n_C])
    a_G_unrolled = tf.reshape(a_G,shape=[m, n_H*n_W, n_C])
    
    # compute the cost with tensorflow (≈1 line)
    J_content = tf.reduce_sum(tf.square(a_C_unrolled - a_G_unrolled))/(4 * n_H * n_W * n_C)
    ### END CODE HERE ###
    
    return J_content

import tensorflow as tf
tf.compat.v1.reset_default_graph()

sess = tf.compat.v1.Session()

print(sess.run(hello))

with tf.compat.v1.Session() as test:
    #tf.set_random_seed(1)
    tf.random.set_seed(1)
    #tf.random.normal
    a_C = tf.random.normal([1, 4, 4, 3], mean=1, stddev=4)
    a_G = tf.random.normal([1, 4, 4, 3], mean=1, stddev=4)
    J_content = compute_content_cost(a_C, a_G)
    print("J_content = " + str(J_content.eval()))

import imageio
style_image = imageio.imread('images/kandinsky5.jpg')
print(style_image.shape)  # style_image is a numpy array
imshow(style_image)

# GRADED FUNCTION: gram_matrix

def gram_matrix(A):
    """
    Argument:
    A -- matrix of shape (n_C, n_H*n_W)
    
    Returns:
    GA -- Gram matrix of A, of shape (n_C, n_C)
    """
    
    ### START CODE HERE ### (≈1 line)
    GA = tf.matmul(A, tf.transpose(A))
    ### END CODE HERE ###
    
    return GA

tf.compat.v1.reset_default_graph()

with tf.compat.v1.Session() as test:
    tf.random.set_seed(1)
    A = tf.random.normal([3, 2*1], mean=1, stddev=4)
    GA = gram_matrix(A)
    
    print("GA = " + str(GA.eval()))

# GRADED FUNCTION: compute_layer_style_cost

def compute_layer_style_cost(a_S, a_G):
    """
    Arguments:
    a_S -- tensor of dimension (1, n_H, n_W, n_C), hidden layer activations representing style of the image S 
    a_G -- tensor of dimension (1, n_H, n_W, n_C), hidden layer activations representing style of the image G
    
    Returns: 
    J_style_layer -- tensor representing a scalar value, style cost defined above by equation (2)
    """
    
    ### START CODE HERE ###
    # Retrieve dimensions from a_G (≈1 line)
    m, n_H, n_W, n_C = a_G.get_shape().as_list()
    
    # Reshape the images to have them of shape (n_C, n_H*n_W) (≈2 lines)
    a_S = tf.reshape(a_S, [n_H*n_W, n_C])
    a_G = tf.reshape(a_G, [n_H*n_W, n_C])

    # Computing gram_matrices for both images S and G (≈2 lines)
    GS = gram_matrix(tf.transpose(a_S))
    GG = gram_matrix(tf.transpose(a_G))

    # Computing the loss (≈1 line)
    J_style_layer = tf.reduce_sum(tf.square(GS-GG))/(4 * n_C**2 * (n_W*n_H)**2)
    
    ### END CODE HERE ###
    
    return J_style_layer



tf.compat.v1.reset_default_graph()

with tf.compat.v1.Session() as test:
    tf.random.set_seed(1)
    a_S = tf.random.normal([1, 4, 4, 3], mean=1, stddev=4)
    a_G = tf.random.normal([1, 4, 4, 3], mean=1, stddev=4)
    J_style_layer = compute_layer_style_cost(a_S, a_G)
    
    print("J_style_layer = " + str(J_style_layer.eval()))

STYLE_LAYERS = [
    ('conv1_1', 0.2),
    ('conv2_1', 0.2),
    ('conv3_1', 0.2),
    ('conv4_1', 0.2),
    ('conv5_1', 0.2)]

def compute_style_cost(model, STYLE_LAYERS):
    """
    Computes the overall style cost from several chosen layers
    
    Arguments:
    model -- our tensorflow model
    STYLE_LAYERS -- A python list containing:
                        - the names of the layers we would like to extract style from
                        - a coefficient for each of them
    
    Returns: 
    J_style -- tensor representing a scalar value, style cost defined above by equation (2)
    """
    
    # initialize the overall style cost
    J_style = 0

    for layer_name, coeff in STYLE_LAYERS:

        # Select the output tensor of the currently selected layer
        out = model[layer_name]

        # Set a_S to be the hidden layer activation from the layer we have selected, by running the session on out
        a_S = sess.run(out)

        # Set a_G to be the hidden layer activation from same layer. Here, a_G references model[layer_name] 
        # and isn't evaluated yet. Later in the code, we'll assign the image G as the model input, so that
        # when we run the session, this will be the activations drawn from the appropriate layer, with G as input.
        a_G = out
        
        # Compute style_cost for the current layer
        J_style_layer = compute_layer_style_cost(a_S, a_G)

        # Add coeff * J_style_layer of this layer to overall style cost
        J_style += coeff * J_style_layer

    return J_style

# GRADED FUNCTION: total_cost

def total_cost(J_content, J_style, alpha = 10, beta = 40):
    """
    Computes the total cost function
    
    Arguments:
    J_content -- content cost coded above
    J_style -- style cost coded above
    alpha -- hyperparameter weighting the importance of the content cost
    beta -- hyperparameter weighting the importance of the style cost
    
    Returns:
    J -- total cost as defined by the formula above.
    """
    
    ### START CODE HERE ### (≈1 line)
    J = alpha * J_content + beta * J_style
    ### END CODE HERE ###
    
    return J

tf.random.set_seed() instead of tf.set_random_seed

tf.compat.v1.reset_default_graph()

with tf.compat.v1.Session() as test:
    np.random.seed(3)
    J_content = np.random.randn()    
    J_style = np.random.randn()
    J = total_cost(J_content, J_style)
    print("J = " + str(J))

# Reset the graph
tf.compat.v1.reset_default_graph()

# Start interactive session
#sess = tf.InteractiveSession()
sess = tf.compat.v1.Session()

import imageio.v2 as imageio
content_image = imageio.imread('images/Poodle-Canis-familiaris-white.jpg')
#content_image = reshape_and_normalize_image(content_image)
style_image = imageio.imread('images/kandinsky5.jpg')
#style_image = reshape_and_normalize_image(style_image)

import cv2
content_image = cv2.normalize(content_image, None, alpha=0, beta=1,
                             norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)

import cv2
style_image  = cv2.normalize(style_image , None, alpha=0, beta=1,
                             norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)

import numpy as np
import random
import cv2

def sp_noise(image,prob):
    '''
    Add salt and pepper noise to image
    prob: Probability of the noise
    '''
    output = np.zeros(image.shape,np.uint8)
    thres = 1 - prob 
    for i in range(image.shape[0]):
        for j in range(image.shape[1]):
            rdn = random.random()
            if rdn < prob:
                output[i][j] = 0
            elif rdn > thres:
                output[i][j] = 255
            else:
                output[i][j] = image[i][j]
    return output

#image = cv2.imread('image.jpg',0) # Only for grayscale image
content_image = imageio.imread('images/Poodle-Canis-familiaris-white.jpg')
generated_image = sp_noise(content_image,0.05)
cv2.imwrite('images/sp_noise.jpg', generated_image)


imshow(generated_image[0])

model = open("models/imagenet-vgg-verydeep-19.mat","rb")

model = load_vgg_model("modelpretrained-model/imagenet-vgg-verydeep-19.mat")

from keras.applications.vgg16 import VGG16
model = VGG16(weights='imagenet')
print(model.summary())


import pydot
from keras.applications.vgg16 import VGG16
from keras.utils.vis_utils import plot_model
model = VGG16()
plot_model(model, to_file='images/vgg.png')

# Assign the content image to be the input of the VGG model.  
sess.run(model['InputLayer'].assign(content_image))

# Select the output tensor of layer conv4_2
out = model['conv4_2']

# Set a_C to be the hidden layer activation from the layer we have selected
a_C = sess.run(out)

# Set a_G to be the hidden layer activation from same layer. Here, a_G references model['conv4_2'] 
# and isn't evaluated yet. Later in the code, we'll assign the image G as the model input, so that
# when we run the session, this will be the activations drawn from the appropriate layer, with G as input.
a_G = out

# Compute the content cost
J_content = compute_content_cost(a_C, a_G)

# Assign the content image to be the input of the VGG model.  
sess.run(model['input'].assign(content_image))

# Select the output tensor of layer conv4_2
out = model['conv4_2']

# Set a_C to be the hidden layer activation from the layer we have selected
a_C = sess.run(out)

# Set a_G to be the hidden layer activation from same layer. Here, a_G references model['conv4_2'] 
# and isn't evaluated yet. Later in the code, we'll assign the image G as the model input, so that
# when we run the session, this will be the activations drawn from the appropriate layer, with G as input.
a_G = out

# Compute the content cost
J_content = compute_content_cost(a_C, a_G)

# Assign the input of the model to be the "style" image 
sess.run(model['input'].assign(style_image))

# Compute the style cost
J_style = compute_style_cost(model, STYLE_LAYERS)

### START CODE HERE ### (1 line)
J = total_cost(J_content, J_style, alpha=10, beta=40)
### END CODE HERE ###

# define optimizer (1 line)
optimizer = tf.train.AdamOptimizer(2.0)

# define train_step (1 line)
train_step = optimizer.minimize(J)

def model_nn(sess, input_image, num_iterations = 200):
    
    # Initialize global variables (you need to run the session on the initializer)
    ### START CODE HERE ### (1 line)
    sess.run(tf.global_variables_initializer())
    ### END CODE HERE ###
    
    # Run the noisy input image (initial generated image) through the model. Use assign().
    ### START CODE HERE ### (1 line)
    sess.run(model["input"].assign(input_image))
    ### END CODE HERE ###
    
    for i in range(num_iterations):
    
        # Run the session on the train_step to minimize the total cost
        ### START CODE HERE ### (1 line)
        sess.run(train_step)
        ### END CODE HERE ###
        
        # Compute the generated image by running the session on the current model['input']
        ### START CODE HERE ### (1 line)
        generated_image = sess.run(model['input'])
        ### END CODE HERE ###

        # Print every 20 iteration.
        if i%20 == 0:
            Jt, Jc, Js = sess.run([J, J_content, J_style])
            print("Iteration " + str(i) + " :")
            print("total cost = " + str(Jt))
            print("content cost = " + str(Jc))
            print("style cost = " + str(Js))
            
            # save current generated image in the "/output" directory
            save_image("output/" + str(i) + ".png", generated_image)
    
    # save last generated image
    save_image('output/generated_image.jpg', generated_image)
    
    return generated_image

model_nn(sess, generated_image)

import os
import sys
import scipy.io
import scipy.misc
import matplotlib.pyplot as plt
from matplotlib.pyplot import imshow
from PIL import Image
from nst_utils import *
import numpy as np
import tensorflow as tf
import pprint
%matplotlib inline


!ls models

pp = pprint.PrettyPrinter(indent=4)
model = load_vgg_model("models/imagenet-vgg-verydeep-19.mat")
pp.pprint(model)

imagenet-vgg-verydeep-19.mat executing.NotOneValueFound: Expected one value, found 0

# Copyright (c) 2015-2018 Anish Athalye. Released under GPLv3.

import os
import math
import re
from argparse import ArgumentParser
from collections import OrderedDict

from PIL import Image
import numpy as np
import scipy.misc

from stylize import stylize


# default arguments
CONTENT_WEIGHT = 5e0
CONTENT_WEIGHT_BLEND = 1
STYLE_WEIGHT = 5e2
TV_WEIGHT = 1e2
STYLE_LAYER_WEIGHT_EXP = 1
LEARNING_RATE = 1e1
BETA1 = 0.9
BETA2 = 0.999
EPSILON = 1e-08
STYLE_SCALE = 1.0
ITERATIONS = 1000
VGG_PATH = 'imagenet-vgg-verydeep-19.mat'
POOLING = 'max'


def build_parser():
    parser = ArgumentParser()
    parser.add_argument('--content',
            dest='content', help='content image',
            metavar='CONTENT', required=True)
    parser.add_argument('--styles',
            dest='styles',
            nargs='+', help='one or more style images',
            metavar='STYLE', required=True)
    parser.add_argument('--output',
            dest='output', help='output path',
            metavar='OUTPUT', required=True)
    parser.add_argument('--iterations', type=int,
            dest='iterations', help='iterations (default %(default)s)',
            metavar='ITERATIONS', default=ITERATIONS)
    parser.add_argument('--print-iterations', type=int,
            dest='print_iterations', help='statistics printing frequency',
            metavar='PRINT_ITERATIONS')
    parser.add_argument('--checkpoint-output',
            dest='checkpoint_output',
            help='checkpoint output format, e.g. output_{:05}.jpg or '
                 'output_%%05d.jpg',
            metavar='OUTPUT', default=None)
    parser.add_argument('--checkpoint-iterations', type=int,
            dest='checkpoint_iterations', help='checkpoint frequency',
            metavar='CHECKPOINT_ITERATIONS', default=None)
    parser.add_argument('--progress-write', default=False, action='store_true',
            help="write iteration progess data to OUTPUT's dir",
            required=False)
    parser.add_argument('--progress-plot', default=False, action='store_true',
            help="plot iteration progess data to OUTPUT's dir",
            required=False)
    parser.add_argument('--width', type=int,
            dest='width', help='output width',
            metavar='WIDTH')
    parser.add_argument('--style-scales', type=float,
            dest='style_scales',
            nargs='+', help='one or more style scales',
            metavar='STYLE_SCALE')
    parser.add_argument('--network',
            dest='network', help='path to network parameters (default %(default)s)',
            metavar='VGG_PATH', default=VGG_PATH)
    parser.add_argument('--content-weight-blend', type=float,
            dest='content_weight_blend',
            help='content weight blend, conv4_2 * blend + conv5_2 * (1-blend) '
                 '(default %(default)s)',
            metavar='CONTENT_WEIGHT_BLEND', default=CONTENT_WEIGHT_BLEND)
    parser.add_argument('--content-weight', type=float,
            dest='content_weight', help='content weight (default %(default)s)',
            metavar='CONTENT_WEIGHT', default=CONTENT_WEIGHT)
    parser.add_argument('--style-weight', type=float,
            dest='style_weight', help='style weight (default %(default)s)',
            metavar='STYLE_WEIGHT', default=STYLE_WEIGHT)
    parser.add_argument('--style-layer-weight-exp', type=float,
            dest='style_layer_weight_exp',
            help='style layer weight exponentional increase - '
                 'weight(layer<n+1>) = weight_exp*weight(layer<n>) '
                 '(default %(default)s)',
            metavar='STYLE_LAYER_WEIGHT_EXP', default=STYLE_LAYER_WEIGHT_EXP)
    parser.add_argument('--style-blend-weights', type=float,
            dest='style_blend_weights', help='style blending weights',
            nargs='+', metavar='STYLE_BLEND_WEIGHT')
    parser.add_argument('--tv-weight', type=float,
            dest='tv_weight',
            help='total variation regularization weight (default %(default)s)',
            metavar='TV_WEIGHT', default=TV_WEIGHT)
    parser.add_argument('--learning-rate', type=float,
            dest='learning_rate', help='learning rate (default %(default)s)',
            metavar='LEARNING_RATE', default=LEARNING_RATE)
    parser.add_argument('--beta1', type=float,
            dest='beta1', help='Adam: beta1 parameter (default %(default)s)',
            metavar='BETA1', default=BETA1)
    parser.add_argument('--beta2', type=float,
            dest='beta2', help='Adam: beta2 parameter (default %(default)s)',
            metavar='BETA2', default=BETA2)
    parser.add_argument('--eps', type=float,
            dest='epsilon', help='Adam: epsilon parameter (default %(default)s)',
            metavar='EPSILON', default=EPSILON)
    parser.add_argument('--initial',
            dest='initial', help='initial image',
            metavar='INITIAL')
    parser.add_argument('--initial-noiseblend', type=float,
            dest='initial_noiseblend',
            help='ratio of blending initial image with normalized noise '
                 '(if no initial image specified, content image is used) '
                 '(default %(default)s)',
            metavar='INITIAL_NOISEBLEND')
    parser.add_argument('--preserve-colors', action='store_true',
            dest='preserve_colors',
            help='style-only transfer (preserving colors) - if color transfer '
                 'is not needed')
    parser.add_argument('--pooling',
            dest='pooling',
            help='pooling layer configuration: max or avg (default %(default)s)',
            metavar='POOLING', default=POOLING)
    parser.add_argument('--overwrite', action='store_true', dest='overwrite',
            help='write file even if there is already a file with that name')
    return parser


def fmt_imsave(fmt, iteration):
    if re.match(r'^.*\{.*\}.*$', fmt):
        return fmt.format(iteration)
    elif '%' in fmt:
        return fmt % iteration
    else:
        raise ValueError("illegal format string '{}'".format(fmt))


def main():

    # https://stackoverflow.com/a/42121886
    key = 'TF_CPP_MIN_LOG_LEVEL'
    if key not in os.environ:
        os.environ[key] = '2'

    parser = build_parser()
    options = parser.parse_args()

    if not os.path.isfile(options.network):
        parser.error("Network %s does not exist. (Did you forget to "
                     "download it?)" % options.network)

    if [options.checkpoint_iterations,
        options.checkpoint_output].count(None) == 1:
        parser.error("use either both of checkpoint_output and "
                     "checkpoint_iterations or neither")

    if options.checkpoint_output is not None:
        if re.match(r'^.*(\{.*\}|%.*).*$', options.checkpoint_output) is None:
            parser.error("To save intermediate images, the checkpoint_output "
                         "parameter must contain placeholders (e.g. "
                         "`foo_{}.jpg` or `foo_%d.jpg`")

    content_image = imread(options.content)
    style_images = [imread(style) for style in options.styles]

    width = options.width
    if width is not None:
        new_shape = (int(math.floor(float(content_image.shape[0]) /
                content_image.shape[1] * width)), width)
        content_image = scipy.misc.imresize(content_image, new_shape)
    target_shape = content_image.shape
    for i in range(len(style_images)):
        style_scale = STYLE_SCALE
        if options.style_scales is not None:
            style_scale = options.style_scales[i]
        style_images[i] = scipy.misc.imresize(style_images[i], style_scale *
                target_shape[1] / style_images[i].shape[1])

    style_blend_weights = options.style_blend_weights
    if style_blend_weights is None:
        # default is equal weights
        style_blend_weights = [1.0/len(style_images) for _ in style_images]
    else:
        total_blend_weight = sum(style_blend_weights)
        style_blend_weights = [weight/total_blend_weight
                               for weight in style_blend_weights]

    initial = options.initial
    if initial is not None:
        initial = scipy.misc.imresize(imread(initial), content_image.shape[:2])
        # Initial guess is specified, but not noiseblend - no noise should be blended
        if options.initial_noiseblend is None:
            options.initial_noiseblend = 0.0
    else:
        # Neither inital, nor noiseblend is provided, falling back to random
        # generated initial guess
        if options.initial_noiseblend is None:
            options.initial_noiseblend = 1.0
        if options.initial_noiseblend < 1.0:
            initial = content_image

    # try saving a dummy image to the output path to make sure that it's writable
    if os.path.isfile(options.output) and not options.overwrite:
        raise IOError("%s already exists, will not replace it without "
                      "the '--overwrite' flag" % options.output)
    try:
        imsave(options.output, np.zeros((500, 500, 3)))
    except:
        raise IOError('%s is not writable or does not have a valid file '
                      'extension for an image file' % options.output)

    loss_arrs = None
    for iteration, image, loss_vals in stylize(
        network=options.network,
        initial=initial,
        initial_noiseblend=options.initial_noiseblend,
        content=content_image,
        styles=style_images,
        preserve_colors=options.preserve_colors,
        iterations=options.iterations,
        content_weight=options.content_weight,
        content_weight_blend=options.content_weight_blend,
        style_weight=options.style_weight,
        style_layer_weight_exp=options.style_layer_weight_exp,
        style_blend_weights=style_blend_weights,
        tv_weight=options.tv_weight,
        learning_rate=options.learning_rate,
        beta1=options.beta1,
        beta2=options.beta2,
        epsilon=options.epsilon,
        pooling=options.pooling,
        print_iterations=options.print_iterations,
        checkpoint_iterations=options.checkpoint_iterations,
    ):
        if (image is not None) and (options.checkpoint_output is not None):
            imsave(fmt_imsave(options.checkpoint_output, iteration), image)
        if (loss_vals is not None) \
                and (options.progress_plot or options.progress_write):
            if loss_arrs is None:
                itr = []
                loss_arrs = OrderedDict((key, []) for key in loss_vals.keys())
            for key,val in loss_vals.items():
                loss_arrs[key].append(val)
            itr.append(iteration)

    imsave(options.output, image)

    if options.progress_write:
        fn = "{}/progress.txt".format(os.path.dirname(options.output))
        tmp = np.empty((len(itr), len(loss_arrs)+1), dtype=float)
        tmp[:,0] = np.array(itr)
        for ii,val in enumerate(loss_arrs.values()):
            tmp[:,ii+1] = np.array(val)
        np.savetxt(fn, tmp, header=' '.join(['itr'] + list(loss_arrs.keys())))


    if options.progress_plot:
        import matplotlib
        matplotlib.use('Agg')
        from matplotlib import pyplot as plt
        fig,ax = plt.subplots()
        for key, val in loss_arrs.items():
            ax.semilogy(itr, val, label=key)
        ax.legend()
        ax.set_xlabel("iterations")
        ax.set_ylabel("loss")
        fig.savefig("{}/progress.png".format(os.path.dirname(options.output)))


def imread(path):
    img = scipy.misc.imread(path).astype(np.float)
    if len(img.shape) == 2:
        # grayscale
        img = np.dstack((img,img,img))
    elif img.shape[2] == 4:
        # PNG with alpha channel
        img = img[:,:,:3]
    return img


def imsave(path, img):
    img = np.clip(img, 0, 255).astype(np.uint8)
    Image.fromarray(img).save(path, quality=95)

if __name__ == '__main__':
    main()

import torch
import torch.nn as nn
from transforms._presets import ImageClassification
from utils import _log_api_usage_once
from _api import register_model, Weights, WeightsEnum

from matplotlib import style

from vgg import *

from stylize import stylize

from transforms._presets import ImageClassification



# -*- coding: utf-8 -*-

# Copyright 2009-2017, Simon Kennedy, sffjunkie+code@gmail.com

#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

"""The :mod:`astral` module provides the means to calculate dawn, sunrise,
solar noon, sunset, dusk and rahukaalam times, plus solar azimuth and
elevation, for specific locations or at a specific latitude/longitude. It can
also calculate the moon phase for a specific date.

The module provides 2 main classes :class:`Astral` and :class:`Location`.

:class:`Astral`
    Has 2 main responsibilities

    * Calculates the events in the UTC timezone.
    * Provides access to location data

:class:`Location`
    Holds information about a location and provides functions to calculate
    the event times for the location in the correct time zone.

For example ::

    >>> from astral import *
    >>> a = Astral()
    >>> location = a['London']
    >>> print('Information for %s' % location.name)
    Information for London
    >>> timezone = location.timezone
    >>> print('Timezone: %s' % timezone)
    Timezone: Europe/London
    >>> print('Latitude: %.02f; Longitude: %.02f' % (location.latitude,
    ... location.longitude))
    Latitude: 51.60; Longitude: 0.05
    >>> from datetime import date
    >>> d = date(2009,4,22)
    >>> sun = location.sun(local=True, date=d)
    >>> print('Dawn:    %s' % str(sun['dawn']))
    Dawn:    2009-04-22 05:12:56+01:00

The module currently provides 2 methods of obtaining location information;
:class:`AstralGeocoder` (the default, which uses information from within the
module) and :class:`GoogleGeocoder` (which obtains information from Google's
Map Service.)

To use the :class:`GoogleGeocoder` pass the class as the `geocoder` parameter
to :meth:`Astral.__init__` or by setting the `geocoder` property to an
instance of :class:`GoogleGeocoder`::

    >>> from astral import GoogleGeocoder
    >>> a = Astral(GoogleGeocoder)

or ::

    >>> from astral import GoogleGeocoder
    >>> a = Astral()
    >>> a.geocoder = GoogleGeocoder()
"""

from __future__ import unicode_literals, division

try:
    import pytz
except ImportError:
    raise ImportError(('The astral module requires the '
                       'pytz module to be available.'))

import datetime
from time import time
from math import cos, sin, tan, acos, asin, atan2, floor, ceil
from math import radians, degrees, pow
import sys

try:
    from urllib import quote_plus
except ImportError:
    from urllib.parse import quote_plus

try:
    from urllib2 import urlopen, URLError
except ImportError:
    from urllib.request import urlopen, URLError

try:
    import simplejson as json
except ImportError:
    import json

if sys.version_info[0] >= 3:
    ustr = str
else:
    ustr = unicode

__all__ = ['Astral', 'Location',
           'AstralGeocoder', 'GoogleGeocoder',
           'AstralError']

__version__ = "1.4.1"
__author__ = "Simon Kennedy <sffjunkie+code@gmail.com>"

SUN_RISING = 1
SUN_SETTING = -1

# name,region,latitude,longitude,timezone,elevation
_LOCATION_INFO = """Abu Dhabi,UAE,24°28'N,54°22'E,Asia/Dubai,5
Abu Dhabi,United Arab Emirates,24°28'N,54°22'E,Asia/Dubai,5
Abuja,Nigeria,09°05'N,07°32'E,Africa/Lagos,342
Accra,Ghana,05°35'N,00°06'W,Africa/Accra,61
Addis Ababa,Ethiopia,09°02'N,38°42'E,Africa/Addis_Ababa,2355
Adelaide,Australia,34°56'S,138°36'E,Australia/Adelaide,50
Al Jubail,Saudi Arabia,25°24'N,49°39'W,Asia/Riyadh,8
Algiers,Algeria,36°42'N,03°08'E,Africa/Algiers,224
Amman,Jordan,31°57'N,35°52'E,Asia/Amman,1100
Amsterdam,Netherlands,52°23'N,04°54'E,Europe/Amsterdam,2
Andorra la Vella,Andorra,42°31'N,01°32'E,Europe/Andorra,1023
Ankara,Turkey,39°57'N,32°54'E,Europe/Istanbul,938
Antananarivo,Madagascar,18°55'S,47°31'E,Indian/Antananarivo,1276
Apia,Samoa,13°50'S,171°50'W,Pacific/Apia,2
Ashgabat,Turkmenistan,38°00'N,57°50'E,Asia/Ashgabat,219
Asmara,Eritrea,15°19'N,38°55'E,Africa/Asmara,2325
Astana,Kazakhstan,51°10'N,71°30'E,Asia/Qyzylorda,347
Asuncion,Paraguay,25°10'S,57°30'W,America/Asuncion,124
Athens,Greece,37°58'N,23°46'E,Europe/Athens,338
Avarua,Cook Islands,21°12'N,159°46'W,Etc/GMT-10,208
Baghdad,Iraq,33°20'N,44°30'E,Asia/Baghdad,41
Baku,Azerbaijan,40°29'N,49°56'E,Asia/Baku,30
Bamako,Mali,12°34'N,07°55'W,Africa/Bamako,350
Bandar Seri Begawan,Brunei Darussalam,04°52'N,115°00'E,Asia/Brunei,1
Bangkok,Thailand,13°45'N,100°35'E,Asia/Bangkok,2
Bangui,Central African Republic,04°23'N,18°35'E,Africa/Bangui,373
Banjul,Gambia,13°28'N,16°40'W,Africa/Banjul,5
Basse-Terre,Guadeloupe,16°00'N,61°44'W,America/Guadeloupe,1
Basseterre,Saint Kitts and Nevis,17°17'N,62°43'W,America/St_Kitts,50
Beijing,China,39°55'N,116°20'E,Asia/Harbin,59
Beirut,Lebanon,33°53'N,35°31'E,Asia/Beirut,56
Belfast,Northern Ireland,54°36'N,5°56'W,Europe/Belfast,9
Belgrade,Yugoslavia,44°50'N,20°37'E,Europe/Belgrade,90
Belmopan,Belize,17°18'N,88°30'W,America/Belize,63
Berlin,Germany,52°30'N,13°25'E,Europe/Berlin,35
Bern,Switzerland,46°57'N,07°28'E,Europe/Zurich,510
Bishkek,Kyrgyzstan,42°54'N,74°46'E,Asia/Bishkek,772
Bissau,Guinea-Bissau,11°45'N,15°45'W,Africa/Bissau,0
Bloemfontein,South Africa,29°12'S,26°07'E,Africa/Johannesburg,1398
Bogota,Colombia,04°34'N,74°00'W,America/Bogota,2620
Brasilia,Brazil,15°47'S,47°55'W,Brazil/East,1087
Bratislava,Slovakia,48°10'N,17°07'E,Europe/Bratislava,132
Brazzaville,Congo,04°09'S,15°12'E,Africa/Brazzaville,156
Bridgetown,Barbados,13°05'N,59°30'W,America/Barbados,1
Brisbane,Australia,27°30'S,153°01'E,Australia/Brisbane,25
Brussels,Belgium,50°51'N,04°21'E,Europe/Brussels,62
Bucharest,Romania,44°27'N,26°10'E,Europe/Bucharest,71
Bucuresti,Romania,44°27'N,26°10'E,Europe/Bucharest,71
Budapest,Hungary,47°29'N,19°05'E,Europe/Budapest,120
Buenos Aires,Argentina,34°62'S,58°44'W,America/Buenos_Aires,6
Bujumbura,Burundi,03°16'S,29°18'E,Africa/Bujumbura,782
Cairo,Egypt,30°01'N,31°14'E,Africa/Cairo,74
Canberra,Australia,35°15'S,149°08'E,Australia/Canberra,575
Cape Town,South Africa,33°55'S,18°22'E,Africa/Johannesburg,1700
Caracas,Venezuela,10°30'N,66°55'W,America/Caracas,885
Castries,Saint Lucia,14°02'N,60°58'W,America/St_Lucia,125
Cayenne,French Guiana,05°05'N,52°18'W,America/Cayenne,9
Charlotte Amalie,United States of Virgin Islands,18°21'N,64°56'W,America/Virgin,0
Chisinau,Moldova,47°02'N,28°50'E,Europe/Chisinau,122
Conakry,Guinea,09°29'N,13°49'W,Africa/Conakry,26
Copenhagen,Denmark,55°41'N,12°34'E,Europe/Copenhagen,5
Cotonou,Benin,06°23'N,02°42'E,Africa/Porto-Novo,5
Dakar,Senegal,14°34'N,17°29'W,Africa/Dakar,24
Damascus,Syrian Arab Republic,33°30'N,36°18'E,Asia/Damascus,609
Dammam,Saudi Arabia,26°30'N,50°12'E,Asia/Riyadh,1
Dhaka,Bangladesh,23°43'N,90°26'E,Asia/Dhaka,8
Dili,East Timor,08°29'S,125°34'E,Asia/Dili,11
Djibouti,Djibouti,11°08'N,42°20'E,Africa/Djibouti,19
Dodoma,United Republic of Tanzania,06°08'S,35°45'E,Africa/Dar_es_Salaam,1119
Doha,Qatar,25°15'N,51°35'E,Asia/Qatar,10
Douglas,Isle Of Man,54°9'N,4°29'W,Europe/London,35
Dublin,Ireland,53°21'N,06°15'W,Europe/Dublin,85
Dushanbe,Tajikistan,38°33'N,68°48'E,Asia/Dushanbe,803
El Aaiun,Morocco,27°9'N,13°12'W,UTC,64
Fort-de-France,Martinique,14°36'N,61°02'W,America/Martinique,9
Freetown,Sierra Leone,08°30'N,13°17'W,Africa/Freetown,26
Funafuti,Tuvalu,08°31'S,179°13'E,Pacific/Funafuti,2
Gaborone,Botswana,24°45'S,25°57'E,Africa/Gaborone,1005
George Town,Cayman Islands,19°20'N,81°24'W,America/Cayman,3
Georgetown,Guyana,06°50'N,58°12'W,America/Guyana,30
Gibraltar,Gibraltar,36°9'N,5°21'W,Europe/Gibraltar,3
Guatemala,Guatemala,14°40'N,90°22'W,America/Guatemala,1500
Hanoi,Viet Nam,21°05'N,105°55'E,Asia/Saigon,6
Harare,Zimbabwe,17°43'S,31°02'E,Africa/Harare,1503
Havana,Cuba,23°08'N,82°22'W,America/Havana,59
Helsinki,Finland,60°15'N,25°03'E,Europe/Helsinki,56
Hobart,Tasmania,42°53'S,147°19'E,Australia/Hobart,4
Hong Kong,China,22°16'N,114°09'E,Asia/Hong_Kong,8
Honiara,Solomon Islands,09°27'S,159°57'E,Pacific/Guadalcanal,8
Islamabad,Pakistan,33°40'N,73°10'E,Asia/Karachi,508
Jakarta,Indonesia,06°09'S,106°49'E,Asia/Jakarta,6
Jerusalem,Israel,31°47'N,35°12'E,Asia/Jerusalem,775
Juba,South Sudan,4°51'N,31°36'E,Africa/Juba,550
Jubail,Saudi Arabia,27°02'N,49°39'E,Asia/Riyadh,2
Kabul,Afghanistan,34°28'N,69°11'E,Asia/Kabul,1791
Kampala,Uganda,00°20'N,32°30'E,Africa/Kampala,1155
Kathmandu,Nepal,27°45'N,85°20'E,Asia/Kathmandu,1337
Khartoum,Sudan,15°31'N,32°35'E,Africa/Khartoum,380
Kiev,Ukraine,50°30'N,30°28'E,Europe/Kiev,153
Kigali,Rwanda,01°59'S,30°04'E,Africa/Kigali,1497
Kingston,Jamaica,18°00'N,76°50'W,America/Jamaica,9
Kingston,Norfolk Island,45°20'S,168°43'E,Pacific/Norfolk,113
Kingstown,Saint Vincent and the Grenadines,13°10'N,61°10'W,America/St_Vincent,1
Kinshasa,Democratic Republic of the Congo,04°20'S,15°15'E,Africa/Kinshasa,312
Koror,Palau,07°20'N,134°28'E,Pacific/Palau,33
Kuala Lumpur,Malaysia,03°09'N,101°41'E,Asia/Kuala_Lumpur,22
Kuwait,Kuwait,29°30'N,48°00'E,Asia/Kuwait,55
La Paz,Bolivia,16°20'S,68°10'W,America/La_Paz,4014
Libreville,Gabon,00°25'N,09°26'E,Africa/Libreville,15
Lilongwe,Malawi,14°00'S,33°48'E,Africa/Blantyre,1229
Lima,Peru,12°00'S,77°00'W,America/Lima,13
Lisbon,Portugal,38°42'N,09°10'W,Europe/Lisbon,123
Ljubljana,Slovenia,46°04'N,14°33'E,Europe/Ljubljana,385
Lome,Togo,06°09'N,01°20'E,Africa/Lome,25
London,England,51°30'N,00°07'W,Europe/London,24
Luanda,Angola,08°50'S,13°15'E,Africa/Luanda,6
Lusaka,Zambia,15°28'S,28°16'E,Africa/Lusaka,1154
Luxembourg,Luxembourg,49°37'N,06°09'E,Europe/Luxembourg,232
Macau,Macao,22°12'N,113°33'E,Asia/Macau,6
Madinah,Saudi Arabia,24°28'N,39°36'E,Asia/Riyadh,631
Madrid,Spain,40°25'N,03°45'W,Europe/Madrid,582
Majuro,Marshall Islands,7°4'N,171°16'E,Pacific/Majuro,65
Makkah,Saudi Arabia,21°26'N,39°49'E,Asia/Riyadh,240
Malabo,Equatorial Guinea,03°45'N,08°50'E,Africa/Malabo,56
Male,Maldives,04°00'N,73°28'E,Indian/Maldives,2
Mamoudzou,Mayotte,12°48'S,45°14'E,Indian/Mayotte,420
Managua,Nicaragua,12°06'N,86°20'W,America/Managua,50
Manama,Bahrain,26°10'N,50°30'E,Asia/Bahrain,2
Manila,Philippines,14°40'N,121°03'E,Asia/Manila,21
Maputo,Mozambique,25°58'S,32°32'E,Africa/Maputo,44
Maseru,Lesotho,29°18'S,27°30'E,Africa/Maseru,1628
Masqat,Oman,23°37'N,58°36'E,Asia/Muscat,8
Mbabane,Swaziland,26°18'S,31°06'E,Africa/Mbabane,1243
Mecca,Saudi Arabia,21°26'N,39°49'E,Asia/Riyadh,240
Medina,Saudi Arabia,24°28'N,39°36'E,Asia/Riyadh,631
Mexico,Mexico,19°20'N,99°10'W,America/Mexico_City,2254
Minsk,Belarus,53°52'N,27°30'E,Europe/Minsk,231
Mogadishu,Somalia,02°02'N,45°25'E,Africa/Mogadishu,9
Monaco,Priciplality Of Monaco,43°43'N,7°25'E,Europe/Monaco,206
Monrovia,Liberia,06°18'N,10°47'W,Africa/Monrovia,9
Montevideo,Uruguay,34°50'S,56°11'W,America/Montevideo,32
Moroni,Comoros,11°40'S,43°16'E,Indian/Comoro,29
Moscow,Russian Federation,55°45'N,37°35'E,Europe/Moscow,247
Moskva,Russian Federation,55°45'N,37°35'E,Europe/Moscow,247
Mumbai,India,18°58'N,72°49'E,Asia/Kolkata,14
Muscat,Oman,23°37'N,58°32'E,Asia/Muscat,8
N'Djamena,Chad,12°10'N,14°59'E,Africa/Ndjamena,295
Nairobi,Kenya,01°17'S,36°48'E,Africa/Nairobi,1624
Nassau,Bahamas,25°05'N,77°20'W,America/Nassau,7
Naypyidaw,Myanmar,19°45'N,96°6'E,Asia/Rangoon,104
New Delhi,India,28°37'N,77°13'E,Asia/Kolkata,233
Ngerulmud,Palau,7°30'N,134°37'E,Pacific/Palau,3
Niamey,Niger,13°27'N,02°06'E,Africa/Niamey,223
Nicosia,Cyprus,35°10'N,33°25'E,Asia/Nicosia,162
Nouakchott,Mauritania,20°10'S,57°30'E,Africa/Nouakchott,3
Noumea,New Caledonia,22°17'S,166°30'E,Pacific/Noumea,69
Nuku'alofa,Tonga,21°10'S,174°00'W,Pacific/Tongatapu,6
Nuuk,Greenland,64°10'N,51°35'W,America/Godthab,70
Oranjestad,Aruba,12°32'N,70°02'W,America/Aruba,33
Oslo,Norway,59°55'N,10°45'E,Europe/Oslo,170
Ottawa,Canada,45°27'N,75°42'W,US/Eastern,79
Ouagadougou,Burkina Faso,12°15'N,01°30'W,Africa/Ouagadougou,316
P'yongyang,Democratic People's Republic of Korea,39°09'N,125°30'E,Asia/Pyongyang,21
Pago Pago,American Samoa,14°16'S,170°43'W,Pacific/Pago_Pago,0
Palikir,Micronesia,06°55'N,158°09'E,Pacific/Ponape,71
Panama,Panama,09°00'N,79°25'W,America/Panama,2
Papeete,French Polynesia,17°32'S,149°34'W,Pacific/Tahiti,7
Paramaribo,Suriname,05°50'N,55°10'W,America/Paramaribo,7
Paris,France,48°50'N,02°20'E,Europe/Paris,109
Perth,Australia,31°56'S,115°50'E,Australia/Perth,20
Phnom Penh,Cambodia,11°33'N,104°55'E,Asia/Phnom_Penh,10
Podgorica,Montenegro,42°28'N,19°16'E,Europe/Podgorica,53
Port Louis,Mauritius,20°9'S,57°30'E,Indian/Mauritius,5
Port Moresby,Papua New Guinea,09°24'S,147°08'E,Pacific/Port_Moresby,44
Port-Vila,Vanuatu,17°45'S,168°18'E,Pacific/Efate,1
Port-au-Prince,Haiti,18°40'N,72°20'W,America/Port-au-Prince,34
Port of Spain,Trinidad and Tobago,10°40'N,61°31'W,America/Port_of_Spain,66
Porto-Novo,Benin,06°23'N,02°42'E,Africa/Porto-Novo,38
Prague,Czech Republic,50°05'N,14°22'E,Europe/Prague,365
Praia,Cape Verde,15°02'N,23°34'W,Atlantic/Cape_Verde,35
Pretoria,South Africa,25°44'S,28°12'E,Africa/Johannesburg,1322
Pristina,Albania,42°40'N,21°10'E,Europe/Tirane,576
Quito,Ecuador,00°15'S,78°35'W,America/Guayaquil,2812
Rabat,Morocco,34°1'N,6°50'W,Africa/Casablanca,75
Reykjavik,Iceland,64°10'N,21°57'W,Atlantic/Reykjavik,61
Riga,Latvia,56°53'N,24°08'E,Europe/Riga,7
Riyadh,Saudi Arabia,24°41'N,46°42'E,Asia/Riyadh,612
Road Town,British Virgin Islands,18°27'N,64°37'W,America/Virgin,1
Rome,Italy,41°54'N,12°29'E,Europe/Rome,95
Roseau,Dominica,15°20'N,61°24'W,America/Dominica,72
Saint Helier,Jersey,49°11'N,2°6'W,Etc/GMT,54
Saint Pierre,Saint Pierre and Miquelon,46°46'N,56°12'W,America/Miquelon,5
Saipan,Northern Mariana Islands,15°12'N,145°45'E,Pacific/Saipan,200
Sana,Yemen,15°20'N,44°12'W,Asia/Aden,2199
Sana'a,Yemen,15°20'N,44°12'W,Asia/Aden,2199
San Jose,Costa Rica,09°55'N,84°02'W,America/Costa_Rica,931
San Juan,Puerto Rico,18°28'N,66°07'W,America/Puerto_Rico,21
San Marino,San Marino,43°55'N,12°30'E,Europe/San_Marino,749
San Salvador,El Salvador,13°40'N,89°10'W,America/El_Salvador,621
Santiago,Chile,33°24'S,70°40'W,America/Santiago,476
Santo Domingo,Dominica Republic,18°30'N,69°59'W,America/Santo_Domingo,14
Sao Tome,Sao Tome and Principe,00°10'N,06°39'E,Africa/Sao_Tome,13
Sarajevo,Bosnia and Herzegovina,43°52'N,18°26'E,Europe/Sarajevo,511
Seoul,Republic of Korea,37°31'N,126°58'E,Asia/Seoul,49
Singapore,Republic of Singapore,1°18'N,103°48'E,Asia/Singapore,16
Skopje,The Former Yugoslav Republic of Macedonia,42°01'N,21°26'E,Europe/Skopje,238
Sofia,Bulgaria,42°45'N,23°20'E,Europe/Sofia,531
Sri Jayawardenapura Kotte,Sri Lanka,6°54'N,79°53'E,Asia/Colombo,7
St. George's,Grenada,32°22'N,64°40'W,America/Grenada,7
St. John's,Antigua and Barbuda,17°7'N,61°51'W,America/Antigua,1
St. Peter Port,Guernsey,49°26'N,02°33'W,Europe/Guernsey,1
Stanley,Falkland Islands,51°40'S,59°51'W,Atlantic/Stanley,23
Stockholm,Sweden,59°20'N,18°05'E,Europe/Stockholm,52
Sucre,Bolivia,16°20'S,68°10'W,America/La_Paz,2903
Suva,Fiji,18°06'S,178°30'E,Pacific/Fiji,0
Sydney,Australia,33°53'S,151°13'E,Australia/Sydney,3
Taipei,Republic of China (Taiwan),25°02'N,121°38'E,Asia/Taipei,9
T'bilisi,Georgia,41°43'N,44°50'E,Asia/Tbilisi,467
Tbilisi,Georgia,41°43'N,44°50'E,Asia/Tbilisi,467
Tallinn,Estonia,59°22'N,24°48'E,Europe/Tallinn,39
Tarawa,Kiribati,01°30'N,173°00'E,Pacific/Tarawa,2
Tashkent,Uzbekistan,41°20'N,69°10'E,Asia/Tashkent,489
Tegucigalpa,Honduras,14°05'N,87°14'W,America/Tegucigalpa,994
Tehran,Iran,35°44'N,51°30'E,Asia/Tehran,1191
Thimphu,Bhutan,27°31'N,89°45'E,Asia/Thimphu,2300
Tirana,Albania,41°18'N,19°49'E,Europe/Tirane,90
Tirane,Albania,41°18'N,19°49'E,Europe/Tirane,90
Torshavn,Faroe Islands,62°05'N,06°56'W,Atlantic/Faroe,39
Tokyo,Japan,35°41'N,139°41'E,Asia/Tokyo,8
Tripoli,Libyan Arab Jamahiriya,32°49'N,13°07'E,Africa/Tripoli,81
Tunis,Tunisia,36°50'N,10°11'E,Africa/Tunis,4
Ulan Bator,Mongolia,47°55'N,106°55'E,Asia/Ulaanbaatar,1330
Ulaanbaatar,Mongolia,47°55'N,106°55'E,Asia/Ulaanbaatar,1330
Vaduz,Liechtenstein,47°08'N,09°31'E,Europe/Vaduz,463
Valletta,Malta,35°54'N,14°31'E,Europe/Malta,48
Vienna,Austria,48°12'N,16°22'E,Europe/Vienna,171
Vientiane,Lao People's Democratic Republic,17°58'N,102°36'E,Asia/Vientiane,171
Vilnius,Lithuania,54°38'N,25°19'E,Europe/Vilnius,156
W. Indies,Antigua and Barbuda,17°20'N,61°48'W,America/Antigua,0
Warsaw,Poland,52°13'N,21°00'E,Europe/Warsaw,107
Washington DC,USA,39°91'N,77°02'W,US/Eastern,23
Wellington,New Zealand,41°19'S,174°46'E,Pacific/Auckland,7
Willemstad,Netherlands Antilles,12°05'N,69°00'W,America/Curacao,1
Windhoek,Namibia,22°35'S,17°04'E,Africa/Windhoek,1725
Yamoussoukro,Cote d'Ivoire,06°49'N,05°17'W,Africa/Abidjan,213
Yangon,Myanmar,16°45'N,96°20'E,Asia/Rangoon,33
Yaounde,Cameroon,03°50'N,11°35'E,Africa/Douala,760
Yaren,Nauru,0°32'S,166°55'E,Pacific/Nauru,0
Yerevan,Armenia,40°10'N,44°31'E,Asia/Yerevan,890
Zagreb,Croatia,45°50'N,15°58'E,Europe/Zagreb,123

# UK Cities
Aberdeen,Scotland,57°08'N,02°06'W,Europe/London,65
Birmingham,England,52°30'N,01°50'W,Europe/London,99
Bolton,England,53°35'N,02°15'W,Europe/London,105
Bradford,England,53°47'N,01°45'W,Europe/London,127
Bristol,England,51°28'N,02°35'W,Europe/London,11
Cardiff,Wales,51°29'N,03°13'W,Europe/London,9
Crawley,England,51°8'N,00°10'W,Europe/London,77
Edinburgh,Scotland,55°57'N,03°13'W,Europe/London,61
Glasgow,Scotland,55°50'N,04°15'W,Europe/London,8
Greenwich,England,51°28'N,00°00'W,Europe/London,24
Leeds,England,53°48'N,01°35'W,Europe/London,47
Leicester,England,52°38'N,01°08'W,Europe/London,138
Liverpool,England,53°25'N,03°00'W,Europe/London,25
Manchester,England,53°30'N,02°15'W,Europe/London,78
Newcastle Upon Time,England,54°59'N,01°36'W,Europe/London,47
Newcastle,England,54°59'N,01°36'W,Europe/London,47
Norwich,England,52°38'N,01°18'E,Europe/London,18
Oxford,England,51°45'N,01°15'W,Europe/London,72
Plymouth,England,50°25'N,04°15'W,Europe/London,50
Portsmouth,England,50°48'N,01°05'W,Europe/London,9
Reading,England,51°27'N,0°58'W,Europe/London,84
Sheffield,England,53°23'N,01°28'W,Europe/London,105
Southampton,England,50°55'N,01°25'W,Europe/London,9
Swansea,England,51°37'N,03°57'W,Europe/London,91
Swindon,England,51°34'N,01°47'W,Europe/London,112
Wolverhampton,England,52°35'N,2°08'W,Europe/London,89
Barrow-In-Furness,England,54°06'N,3°13'W,Europe/London,20

# US State Capitals
Montgomery,USA,32°21'N,86°16'W,US/Central,42
Juneau,USA,58°23'N,134°11'W,US/Alaska,29
Phoenix,USA,33°26'N,112°04'W,America/Phoenix,331
Little Rock,USA,34°44'N,92°19'W,US/Central,95
Sacramento,USA,38°33'N,121°28'W,US/Pacific,15
Denver,USA,39°44'N,104°59'W,US/Mountain,1600
Hartford,USA,41°45'N,72°41'W,US/Eastern,9
Dover,USA,39°09'N,75°31'W,US/Eastern,8
Tallahassee,USA,30°27'N,84°16'W,US/Eastern,59
Atlanta,USA,33°45'N,84°23'W,US/Eastern,267
Honolulu,USA,21°18'N,157°49'W,US/Hawaii,229
Boise,USA,43°36'N,116°12'W,US/Mountain,808
Springfield,USA,39°47'N,89°39'W,US/Central,190
Indianapolis,USA,39°46'N,86°9'W,US/Eastern,238
Des Moines,USA,41°35'N,93°37'W,US/Central,276
Topeka,USA,39°03'N,95°41'W,US/Central,289
Frankfort,USA,38°11'N,84°51'W,US/Eastern,243
Baton Rouge,USA,30°27'N,91°8'W,US/Central,15
Augusta,USA,44°18'N,69°46'W,US/Eastern,41
Annapolis,USA,38°58'N,76°30'W,US/Eastern,0
Boston,USA,42°21'N,71°03'W,US/Eastern,6
Lansing,USA,42°44'N,84°32'W,US/Eastern,271
Saint Paul,USA,44°56'N,93°05'W,US/Central,256
Jackson,USA,32°17'N,90°11'W,US/Central,90
Jefferson City,USA,38°34'N,92°10'W,US/Central,167
Helena,USA,46°35'N,112°1'W,US/Mountain,1150
Lincoln,USA,40°48'N,96°40'W,US/Central,384
Carson City,USA,39°9'N,119°45'W,US/Pacific,1432
Concord,USA,43°12'N,71°32'W,US/Eastern,117
Trenton,USA,40°13'N,74°45'W,US/Eastern,28
Santa Fe,USA,35°40'N,105°57'W,US/Mountain,2151
Albany,USA,42°39'N,73°46'W,US/Eastern,17
Raleigh,USA,35°49'N,78°38'W,US/Eastern,90
Bismarck,USA,46°48'N,100°46'W,US/Central,541
Columbus,USA,39°59'N,82°59'W,US/Eastern,271
Oklahoma City,USA,35°28'N,97°32'W,US/Central,384
Salem,USA,44°55'N,123°1'W,US/Pacific,70
Harrisburg,USA,40°16'N,76°52'W,US/Eastern,112
Providence,USA,41°49'N,71°25'W,US/Eastern,2
Columbia,USA,34°00'N,81°02'W,US/Eastern,96
Pierre,USA,44°22'N,100°20'W,US/Central,543
Nashville,USA,36°10'N,86°47'W,US/Central,149
Austin,USA,30°16'N,97°45'W,US/Central,167
Salt Lake City,USA,40°45'N,111°53'W,US/Mountain,1294
Montpelier,USA,44°15'N,72°34'W,US/Eastern,325
Richmond,USA,37°32'N,77°25'W,US/Eastern,68
Olympia,USA,47°2'N,122°53'W,US/Pacific,35
Charleston,USA,38°20'N,81°38'W,US/Eastern,11
Madison,USA,43°4'N,89°24'W,US/Central,281
Cheyenne,USA,41°8'N,104°48'W,US/Mountain,1860

# Major US Cities
Birmingham,USA,33°39'N,86°48'W,US/Central,197
Anchorage,USA,61°13'N,149°53'W,US/Alaska,30
Los Angeles,USA,34°03'N,118°15'W,US/Pacific,50
San Francisco,USA,37°46'N,122°25'W,US/Pacific,47
Bridgeport,USA,41°11'N,73°11'W,US/Eastern,13
Wilmington,USA,39°44'N,75°32'W,US/Eastern,15
Jacksonville,USA,30°19'N,81°39'W,US/Eastern,13
Miami,USA,26°8'N,80°12'W,US/Eastern,10
Chicago,USA,41°50'N,87°41'W,US/Central,189
Wichita,USA,37°41'N,97°20'W,US/Central,399
Louisville,USA,38°15'N,85°45'W,US/Eastern,142
New Orleans,USA,29°57'N,90°4'W,US/Central,10
Portland,USA,43°39'N,70°16'W,US/Eastern,6
Baltimore,USA,39°17'N,76°37'W,US/Eastern,31
Detroit,USA,42°19'N,83°2'W,US/Eastern,189
Minneapolis,USA,44°58'N,93°15'W,US/Central,260
Kansas City,USA,39°06'N,94°35'W,US/Central,256
Billings,USA,45°47'N,108°32'W,US/Mountain,946
Omaha,USA,41°15'N,96°0'W,US/Central,299
Las Vegas,USA,36°10'N,115°08'W,US/Pacific,720
Manchester,USA,42°59'N,71°27'W,US/Eastern,56
Newark,USA,40°44'N,74°11'W,US/Eastern,4
Albuquerque,USA,35°06'N,106°36'W,US/Mountain,1523
New York,USA,40°43'N,74°0'W,US/Eastern,17
Charlotte,USA,35°13'N,80°50'W,US/Eastern,217
Fargo,USA,46°52'N,96°47'W,US/Central,271
Cleveland,USA,41°28'N,81°40'W,US/Eastern,210
Philadelphia,USA,39°57'N,75°10'W,US/Eastern,62
Sioux Falls,USA,43°32'N,96°43'W,US/Central,443
Memphis,USA,35°07'N,89°58'W,US/Central,84
Houston,USA,29°45'N,95°22'W,US/Central,8
Dallas,USA,32°47'N,96°48'W,US/Central,137
Burlington,USA,44°28'N,73°9'W,US/Eastern,35
Virginia Beach,USA,36°50'N,76°05'W,US/Eastern,9
Seattle,USA,47°36'N,122°19'W,US/Pacific,63
Milwaukee,USA,43°03'N,87°57'W,US/Central,188
San Diego,USA,32°42'N,117°09'W,US/Pacific,16
Orlando,USA,28°32'N,81°22'W,US/Eastern,35
Buffalo,USA,42°54'N,78°50'W,US/Eastern,188
Toledo,USA,41°39'N,83°34'W,US/Eastern,180

# Canadian cities
Vancouver,Canada,49°15'N,123°6'W,America/Vancouver,55
Calgary,Canada,51°2'N,114°3'W,America/Edmonton,1040
Edmonton,Canada,53°32'N,113°29'W,America/Edmonton,664
Saskatoon,Canada,52°8'N,106°40'W,America/Regina,480
Regina,Canada,50°27'N,104°36'W,America/Regina,577
Winnipeg,Canada,49°53'N,97°8'W,America/Winnipeg,229
Toronto,Canada,43°39'N,79°22'W,America/Toronto,77
Montreal,Canada,45°30'N,73°33'W,America/Montreal,23
Quebec,Canada,46°48'N,71°14'W,America/Toronto,87
Fredericton,Canada,45°57'N,66°38'W,America/Halifax,8
Halifax,Canada,44°38'N,63°34'W,America/Halifax,36
Charlottetown,Canada,46°14'N,63°7'W,America/Halifax,2
St. John's,Canada,47°33'N,52°42'W,America/Halifax,116
Whitehorse,Canada,60°43'N,135°3'W,America/Whitehorse,696
Yellowknife,Canada,62°27'N,114°22'W,America/Yellowknife,191
Iqaluit,Canada,63°44'N,68°31'W,America/Iqaluit,3
"""

class AstralError(Exception):
    """Astral base exception class"""


def excel_datediff(start_date, end_date):
    """Return the same number of days between 2 dates as Excel does"""
    return end_date.toordinal() - start_date.toordinal() + 2


class Location(object):
    """Provides access to information for single location."""

    def __init__(self, info=None):
        """Initializes the object with a tuple of information.

        :param info: A tuple of information to fill in the location info.

            The tuple should contain items in the following order

            ================ =============
            Field            Default
            ================ =============
            name             Greenwich
            region           England
            latitude         51.168
            longitude        0
            time zone name   Europe/London
            elevation        24
            ================ =============

            See :attr:`timezone` property for a method of obtaining time zone
            names
        """

        self.astral = None
        if info is None:
            self.name = 'Greenwich'
            self.region = 'England'
            self._latitude = 51.168
            self._longitude = 0.0
            self._timezone_group = 'Europe'
            self._timezone_location = 'London'
            self._elevation = 24
        else:
            self.name = ''
            self.region = ''
            self._latitude = 0.0
            self._longitude = 0.0
            self._timezone_group = ''
            self._timezone_location = ''
            self._elevation = 0

            try:
                self.name = info[0]
                self.region = info[1]
                self.latitude = info[2]
                self.longitude = info[3]
                self.timezone = info[4]
                self.elevation = info[5]
            except IndexError:
                pass

        self.url = ''

    def __repr__(self):
        repr_format = '%s/%s, tz=%s, lat=%0.02f, lon=%0.02f'
        return repr_format % (self.name, self.region,
                              self.timezone,
                              self.latitude, self.longitude)

    @property
    def latitude(self):
        """The location's latitude

        ``latitude`` can be set either as a string or as a number

        For strings they must be of the form

            degrees°minutes'[N|S] e.g. 51°31'N

        For numbers, positive numbers signify latitudes to the North.
        """

        return self._latitude

    @latitude.setter
    def latitude(self, latitude):
        if isinstance(latitude, str) or isinstance(latitude, ustr):
            (deg, rest) = latitude.split("°", 1)
            (minute, rest) = rest.split("'", 1)

            self._latitude = float(deg) + (float(minute) / 60)

            if latitude.endswith("S"):
                self._latitude = -self._latitude
        else:
            self._latitude = float(latitude)

    @property
    def longitude(self):
        """The location's longitude.

        ``longitude`` can be set either as a string or as a number

        For strings they must be of the form

            degrees°minutes'[E|W] e.g. 51°31'W

        For numbers, positive numbers signify longitudes to the East.
        """

        return self._longitude

    @longitude.setter
    def longitude(self, longitude):
        if isinstance(longitude, str) or isinstance(longitude, ustr):
            (deg, rest) = longitude.split("°", 1)
            (minute, rest) = rest.split("'", 1)

            self._longitude = float(deg) + (float(minute) / 60)

            if longitude.endswith("W"):
                self._longitude = -self._longitude
        else:
            self._longitude = float(longitude)

    @property
    def elevation(self):
        """The elevation in metres above sea level."""

        return self._elevation

    @elevation.setter
    def elevation(self, elevation):
        self._elevation = int(elevation)

    @property
    def timezone(self):
        """The name of the time zone for the location.

        A list of time zone names can be obtained from pytz. For example.

        >>> from pytz import all_timezones
        >>> for timezone in all_timezones:
        ...     print(timezone)
        """

        if self._timezone_location != '':
            return '%s/%s' % (self._timezone_group,
                              self._timezone_location)
        else:
            return self._timezone_group

    @timezone.setter
    def timezone(self, name):
        if name not in pytz.all_timezones:
            raise ValueError('Timezone \'%s\' not recognized' % name)

        try:
            self._timezone_group, self._timezone_location = \
                name.split('/', 1)
        except ValueError:
            self._timezone_group = name
            self._timezone_location = ''

    @property
    def tz(self):
        """Time zone information."""

        try:
            tz = pytz.timezone(self.timezone)
            return tz
        except pytz.UnknownTimeZoneError:
            raise AstralError('Unknown timezone \'%s\'' % self.timezone)

    tzinfo = tz

    @property
    def solar_depression(self):
        """The number of degrees the sun must be below the horizon for the
        dawn/dusk calculation.

        Can either be set as a number of degrees below the horizon or as
        one of the following strings

        ============= =======
        String        Degrees
        ============= =======
        civil            6.0
        nautical        12.0
        astronomical    18.0
        ============= =======
        """

        return self.astral.solar_depression

    @solar_depression.setter
    def solar_depression(self, depression):
        if self.astral is None:
            self.astral = Astral()

        self.astral.solar_depression = depression

    def sun(self, date=None, local=True):
        """Returns dawn, sunrise, noon, sunset and dusk as a dictionary.

        :param date: The date for which to calculate the times.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: Dictionary with keys ``dawn``, ``sunrise``, ``noon``,
            ``sunset`` and ``dusk`` whose values are the results of the
            corresponding methods.
        :rtype: dict
         """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        sun = self.astral.sun_utc(date, self.latitude, self.longitude)

        if local:
            for key, dt in sun.items():
                sun[key] = dt.astimezone(self.tz)

        return sun

    def dawn(self, date=None, local=True):
        """Calculates the time in the morning when the sun is a certain number
        of degrees below the horizon. By default this is 6 degrees but can be
        changed by setting the :attr:`Astral.solar_depression` property.

        :param date: The date for which to calculate the dawn time.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: The date and time at which dawn occurs.
        :rtype: :class:`~datetime.datetime`
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        dawn = self.astral.dawn_utc(date, self.latitude, self.longitude)

        if local:
            return dawn.astimezone(self.tz)
        else:
            return dawn

    def sunrise(self, date=None, local=True):
        """Return sunrise time.

        Calculates the time in the morning when the sun is a 0.833 degrees
        below the horizon. This is to account for refraction.

        :param date: The date for which to calculate the sunrise time.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: The date and time at which sunrise occurs.
        :rtype: :class:`~datetime.datetime`
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        sunrise = self.astral.sunrise_utc(date, self.latitude, self.longitude)

        if local:
            return sunrise.astimezone(self.tz)
        else:
            return sunrise

    def solar_noon(self, date=None, local=True):
        """Calculates the solar noon (the time when the sun is at its highest
        point.)

        :param date: The date for which to calculate the noon time.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: The date and time at which the solar noon occurs.
        :rtype: :class:`~datetime.datetime`
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        noon = self.astral.solar_noon_utc(date, self.longitude)

        if local:
            return noon.astimezone(self.tz)
        else:
            return noon

    def sunset(self, date=None, local=True):
        """Calculates sunset time (the time in the evening when the sun is a
        0.833 degrees below the horizon. This is to account for refraction.)

        :param date: The date for which to calculate the sunset time.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: The date and time at which sunset occurs.
        :rtype: :class:`~datetime.datetime`
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        sunset = self.astral.sunset_utc(date, self.latitude, self.longitude)

        if local:
            return sunset.astimezone(self.tz)
        else:
            return sunset

    def dusk(self, date=None, local=True):
        """Calculates the dusk time (the time in the evening when the sun is a
        certain number of degrees below the horizon. By default this is 6
        degrees but can be changed by setting the
        :attr:`solar_depression` property.)

        :param date: The date for which to calculate the dusk time.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: The date and time at which dusk occurs.
        :rtype: :class:`~datetime.datetime`
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        dusk = self.astral.dusk_utc(date, self.latitude, self.longitude)

        if local:
            return dusk.astimezone(self.tz)
        else:
            return dusk

    def solar_midnight(self, date=None, local=True):
        """Calculates the solar midnight (the time when the sun is at its lowest
        point.)

        :param date: The date for which to calculate the midnight time.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: The date and time at which the solar midnight occurs.
        :rtype: :class:`~datetime.datetime`
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        midnight = self.astral.solar_midnight_utc(date, self.longitude)

        if local:
            return midnight.astimezone(self.tz)
        else:
            return midnight

    def daylight(self, date=None, local=True):
        """Calculates the daylight time (the time between sunrise and sunset)

        :param date: The date for which to calculate daylight.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: A tuple containing the start and end times
        :rtype: tuple(:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        start, end = self.astral.daylight_utc(date, self.latitude, self.longitude)

        if local:
            return start.astimezone(self.tz), end.astimezone(self.tz)
        else:
            return start, end

    def night(self, date=None, local=True):
        """Calculates the night time (the time between astronomical dusk and
        astronomical dawn of the next day)

        :param date: The date for which to calculate the start of the night time.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: A tuple containing the start and end times
        :rtype: tuple(:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        start, end = self.astral.night_utc(date, self.latitude, self.longitude)

        if local:
            return start.astimezone(self.tz), end.astimezone(self.tz)
        else:
            return start, end

    def twilight(self, direction=SUN_RISING, date=None, local=True):
        """Returns the start and end times of Twilight in the UTC timezone when
        the sun is traversing in the specified direction.

        This method defines twilight as being between the time
        when the sun is at -6 degrees and sunrise/sunset.

        :param direction:  Determines whether the time is for the sun rising or setting.
                           Use ``astral.SUN_RISING`` or ``astral.SUN_SETTING``.
        :type direction:   int
        :param date: The date for which to calculate the times.
        :type date: :class:`datetime.date`
        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :return: A tuple of the UTC date and time at which twilight starts and ends.
        :rtype: (:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        if date is None:
            date = datetime.date.today()

        start, end = self.astral.twilight_utc(direction, date,
                                              self.latitude, self.longitude)

        if local:
            return start.astimezone(self.tz), end.astimezone(self.tz)
        else:
            return start, end

    def time_at_elevation(self, elevation, direction=SUN_RISING, date=None, local=True):
        """Calculate the time when the sun is at the specified elevation.

        Note:
            This method uses positive elevations for those above the horizon.

            Elevations greater than 90 degrees are converted to a setting sun
            i.e. an elevation of 110 will calculate a setting sun at 70 degrees.

        :param elevation:  Elevation in degrees above the horizon to calculate for.
        :type elevation:   float
        :param direction:  Determines whether the time is for the sun rising or setting.
                           Use ``astral.SUN_RISING`` or ``astral.SUN_SETTING``. Default is rising.
        :type direction:   int
        :param date: The date for which to calculate the elevation time.
                     If no date is specified then the current date will be used.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.
                      If not specified then the time will be returned in local time

        :returns: The date and time at which dusk occurs.
        :rtype: :class:`~datetime.datetime`
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        if elevation > 90.0:
            elevation = 180.0 - elevation
            direction = SUN_SETTING

        time_ = self.astral.time_at_elevation_utc(elevation, direction,
                                                  date, self.latitude, self.longitude)

        if local:
            return time_.astimezone(self.tz)
        else:
            return time_

    def rahukaalam(self, date=None, local=True):
        """Calculates the period of rahukaalam.

        :param date: The date for which to calculate the rahukaalam period.
                     A value of ``None`` uses the current date.

        :param local: True  = Time to be returned in location's time zone;
                      False = Time to be returned in UTC.

        :return: Tuple containing the start and end times for Rahukaalam.
        :rtype: tuple
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        rahukaalam = self.astral.rahukaalam_utc(date,
                                                self.latitude, self.longitude)

        if local:
            rahukaalam = (rahukaalam[0].astimezone(self.tz),
                          rahukaalam[1].astimezone(self.tz))

        return rahukaalam

    def golden_hour(self, direction=SUN_RISING, date=None, local=True):
        """Returns the start and end times of the Golden Hour when the sun is traversing
        in the specified direction.

        This method uses the definition from PhotoPills i.e. the
        golden hour is when the sun is between 4 degrees below the horizon
        and 6 degrees above.

        :param direction:  Determines whether the time is for the sun rising or setting.
                           Use ``astral.SUN_RISING`` or ``astral.SUN_SETTING``. Default is rising.
        :type direction:   int
        :param date: The date for which to calculate the times.
        :type date: :class:`datetime.date`
        :param local: True  = Times to be returned in location's time zone;
                      False = Times to be returned in UTC.
                      If not specified then the time will be returned in local time

        :return: A tuple of the date and time at which the Golden Hour starts and ends.
        :rtype: (:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        start, end = self.astral.golden_hour_utc(direction, date,
                                                 self.latitude, self.longitude)

        if local:
            start = start.astimezone(self.tz)
            end = end.astimezone(self.tz)

        return start, end

    def blue_hour(self, direction=SUN_RISING, date=None, local=True):
        """Returns the start and end times of the Blue Hour when the sun is traversing
        in the specified direction.

        This method uses the definition from PhotoPills i.e. the
        blue hour is when the sun is between 6 and 4 degrees below the horizon.

        :param direction:  Determines whether the time is for the sun rising or setting.
                           Use ``astral.SUN_RISING`` or ``astral.SUN_SETTING``. Default is rising.
        :type direction:   int
        :param date: The date for which to calculate the times.
                     If no date is specified then the current date will be used.

        :param local: True  = Times to be returned in location's time zone;
                      False = Times to be returned in UTC.
                      If not specified then the time will be returned in local time

        :return: A tuple of the date and time at which the Blue Hour starts and ends.
        :rtype: (:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        start, end = self.astral.blue_hour_utc(direction, date,
                                               self.latitude, self.longitude)

        if local:
            start = start.astimezone(self.tz)
            end = end.astimezone(self.tz)

        return start, end

    def solar_azimuth(self, dateandtime=None):
        """Calculates the solar azimuth angle for a specific date/time.

        :param dateandtime: The date and time for which to calculate the angle.
        :type dateandtime: :class:`~datetime.datetime`

        :returns: The azimuth angle in degrees clockwise from North.
        :rtype: float
        """

        if self.astral is None:
            self.astral = Astral()

        if dateandtime is None:
            dateandtime = datetime.datetime.now(self.tz)
        elif not dateandtime.tzinfo:
            dateandtime = self.tz.localize(dateandtime)

        dateandtime = dateandtime.astimezone(pytz.UTC)

        return self.astral.solar_azimuth(dateandtime,
                                         self.latitude, self.longitude)

    def solar_elevation(self, dateandtime=None):
        """Calculates the solar elevation angle for a specific time.

        :param dateandtime: The date and time for which to calculate the angle.
        :type dateandtime: :class:`~datetime.datetime`

        :returns: The elevation angle in degrees above the horizon.
        :rtype: float
        """

        if self.astral is None:
            self.astral = Astral()

        if dateandtime is None:
            dateandtime = datetime.datetime.now(self.tz)
        elif not dateandtime.tzinfo:
            dateandtime = self.tz.localize(dateandtime)

        dateandtime = dateandtime.astimezone(pytz.UTC)

        return self.astral.solar_elevation(dateandtime,
                                           self.latitude, self.longitude)

    def solar_zenith(self, dateandtime=None):
        """Calculates the solar zenith angle for a specific time.

        :param dateandtime: The date and time for which to calculate the angle.
        :type dateandtime: :class:`~datetime.datetime`

        :returns: The zenith angle in degrees from vertical.
        :rtype: float
        """

        return 90.0 - self.solar_elevation(dateandtime)

    def moon_phase(self, date=None):
        """Calculates the moon phase for a specific date.

        :param date: The date to calculate the phase for.
                     If ommitted the current date is used.
        :type date: :class:`datetime.date`

        :returns:
            A number designating the phase

                | 0  = New moon
                | 7  = First quarter
                | 14 = Full moon
                | 21 = Last quarter
        :rtype: int
        """

        if self.astral is None:
            self.astral = Astral()

        if date is None:
            date = datetime.date.today()

        return self.astral.moon_phase(date)


class LocationGroup(object):
    """Groups a set of timezones by the timezone group"""

    def __init__(self, name):
        self.name = name
        self._locations = {}

    def __getitem__(self, key):
        """Returns a Location object for the specified `key`.

            group = astral.europe
            location = group['London']

        You can supply an optional region name by adding a comma
        followed by the region name. Where multiple locations have the
        same name you may need to supply the region name otherwise
        the first result will be returned which may not be the one
        you're looking for.

            location = group['Abu Dhabi,United Arab Emirates']

        Handles location names with spaces and mixed case.
        """

        key = self._sanitize_key(key)

        try:
            lookup_name, lookup_region = key.split(',', 1)
        except ValueError:
            lookup_name = key
            lookup_region = ''

        lookup_name = lookup_name.strip('"\'')
        lookup_region = lookup_region.strip('"\'')

        for (location_name, location_list) in self._locations.items():
            if location_name == lookup_name:
                if lookup_region == '':
                    return location_list[0]

                for location in location_list:
                    if self._sanitize_key(location.region) == lookup_region:
                        return location

        raise KeyError('Unrecognised location name - %s' % key)

    def __setitem__(self, key, value):
        key = self._sanitize_key(key)
        if key not in self._locations:
            self._locations[key] = [value]
        else:
            self._locations[key].append(value)

    def __contains__(self, key):
        key = self._sanitize_key(key)
        for name in self._locations.keys():
            if name == key:
                return True

        return False

    def __iter__(self):
        for location_list in self._locations.values():
            for location in location_list:
                yield location

    def keys(self):
        return self._locations.keys()

    def values(self):
        return self._locations.values()

    def items(self):
        return self._locations.items()

    @property
    def locations(self):
        k = []
        for location_list in self._locations.values():
            for location in location_list:
                k.append(location.name)

        return k

    def _sanitize_key(self, key):
        return str(key).lower().replace(' ', '_')


class AstralGeocoder(object):
    """Looks up geographic information from the locations stored within the
    module
    """

    def __init__(self):
        self._groups = {}

        locations = _LOCATION_INFO.split('\n')
        for line in locations:
            line = line.strip()
            if line != '' and line[0] != '#':
                if line[-1] == '\n':
                    line = line[:-1]

                info = line.split(',')

                l = Location(info)

                key = l._timezone_group.lower()
                try:
                    group = self.__getattr__(key)
                except AttributeError:
                    group = LocationGroup(l._timezone_group)
                    self._groups[key] = group

                group[info[0].lower()] = l

    def __getattr__(self, key):
        """Access to each timezone group. For example London is in timezone
        group Europe.

        Attribute lookup is case insensitive"""

        key = str(key).lower()
        for name, value in self._groups.items():
            if name == key:
                return value

        raise AttributeError('Group \'%s\' not found' % key)

    def __getitem__(self, key):
        """Lookup a location within all timezone groups.

        Item lookup is case insensitive."""

        key = str(key).lower()
        for group in self._groups.values():
            try:
                return group[key]
            except KeyError:
                pass

        raise KeyError('Unrecognised location name - %s' % key)

    def __iter__(self):
        return self._groups.__iter__()

    def __contains__(self, key):
        key = str(key).lower()
        for name, group in self._groups.items():
            if name == key:
                return True

            if key in group:
                return True

        return False

    @property
    def locations(self):
        k = []
        for group in self._groups.values():
            k.extend(group.locations)

        return k

    @property
    def groups(self):
        return self._groups


class GoogleGeocoder(object):
    """Use Google Maps API Web Service to lookup GPS co-ordinates, timezone and
    elevation.

    See the following for more info.
    https://developers.google.com/maps/documentation/
    """

    def __init__(self, cache=False):
        self.cache = cache
        self.geocache = {}
        self._location_query_base = 'http://maps.googleapis.com/maps/api/geocode/json?address=%s&sensor=false'
        self._timezone_query_base = 'https://maps.googleapis.com/maps/api/timezone/json?location=%f,%f&timestamp=%d&sensor=false'
        self._elevation_query_base = 'http://maps.googleapis.com/maps/api/elevation/json?locations=%f,%f&sensor=false'

    def __getitem__(self, key):
        if self.cache and key in self.geocache:
            return self.geocache[key]

        location = Location()
        try:
            self._get_geocoding(key, location)
            self._get_timezone(location)
            self._get_elevation(location)
        except URLError:
            raise AstralError(('GoogleGeocoder: Unable to contact '
                               'Google maps API'))

        url = 'http://maps.google.com/maps?q=loc:%f,%f'
        location.url = url % (location.latitude, location.longitude)

        if self.cache:
            self.geocache[key] = location

        return location

    def _get_geocoding(self, key, location):
        """Lookup the Google geocoding API information for `key`"""

        url = self._location_query_base % quote_plus(key)
        data = self._read_from_url(url)
        response = json.loads(data)
        if response['status'] == 'OK':
            formatted_address = response['results'][0]['formatted_address']
            pos = formatted_address.find(',')
            if pos == -1:
                location.name = formatted_address
                location.region = ''
            else:
                location.name = formatted_address[:pos].strip()
                location.region = formatted_address[pos + 1:].strip()

            l = response['results'][0]['geometry']['location']
            location.latitude = float(l['lat'])
            location.longitude = float(l['lng'])
        else:
            raise AstralError('GoogleGeocoder: Unable to locate %s' % key)

    def _get_timezone(self, location):
        """Query the timezone information with the latitude and longitude of
        the specified `location`.

        This function assumes the timezone of the location has always been
        the same as it is now by using time() in the query string.
        """

        url = self._timezone_query_base % (location.latitude,
                                           location.longitude,
                                           int(time()))
        data = self._read_from_url(url)
        response = json.loads(data)
        if response['status'] == 'OK':
            location.timezone = response['timeZoneId']
        else:
            location.timezone = 'UTC'

    def _get_elevation(self, location):
        """Query the elevation information with the latitude and longitude of
        the specified `location`.
        """

        url = self._elevation_query_base % (location.latitude,
                                            location.longitude)
        data = self._read_from_url(url)
        response = json.loads(data)
        if response['status'] == 'OK':
            location.elevation = int(float(response['results'][0]['elevation']))
        else:
            location.elevation = 0

    def _read_from_url(self, url):
        ds = urlopen(url)
        content_types = ds.headers.get('Content-Type').split(';')

        charset = 'UTF-8'
        for ct in content_types:
            if ct.strip().startswith('charset'):
                charset = ct.split('=')[1]

        data = ds.read().decode(charset)
        ds.close()

        return data


class Astral(object):
    def __init__(self, geocoder=AstralGeocoder):
        """Initialise the geocoder and set the default depression."""

        self.geocoder = geocoder()
        self._depression = 6  # Set default depression in degrees

    def __getitem__(self, key):
        """Returns the Location instance specified by ``key``."""

        location = self.geocoder[key]
        location.astral = self
        return location

    @property
    def solar_depression(self):
        """The number of degrees the sun must be below the horizon for the
        dawn/dusk calculation.

        Can either be set as a number of degrees below the horizon or as
        one of the following strings

        ============= =======
        String        Degrees
        ============= =======
        civil            6.0
        nautical        12.0
        astronomical    18.0
        ============= =======
        """

        return self._depression

    @solar_depression.setter
    def solar_depression(self, depression):
        if isinstance(depression, str) or isinstance(depression, ustr):
            try:
                self._depression = {
                    'civil': 6,
                    'nautical': 12,
                    'astronomical': 18}[depression]
            except:
                raise KeyError(("solar_depression must be either a number "
                                "or one of 'civil', 'nautical' or "
                                "'astronomical'"))
        else:
            self._depression = float(depression)

    def sun_utc(self, date, latitude, longitude):
        """Calculate all the info for the sun at once.
        All times are returned in the UTC timezone.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :returns: Dictionary with keys ``dawn``, ``sunrise``, ``noon``,
            ``sunset`` and ``dusk`` whose values are the results of the
            corresponding `_utc` methods.
        :rtype: dict
        """

        dawn = self.dawn_utc(date, latitude, longitude)
        sunrise = self.sunrise_utc(date, latitude, longitude)
        noon = self.solar_noon_utc(date, longitude)
        sunset = self.sunset_utc(date, latitude, longitude)
        dusk = self.dusk_utc(date, latitude, longitude)

        return {
            'dawn': dawn,
            'sunrise': sunrise,
            'noon': noon,
            'sunset': sunset,
            'dusk': dusk
        }

    def dawn_utc(self, date, latitude, longitude, depression=0):
        """Calculate dawn time in the UTC timezone.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float
        :param depression: Override the depression used
        :type depression:  float

        :return: The UTC date and time at which dawn occurs.
        :rtype: :class:`~datetime.datetime`
        """

        if depression == 0:
            depression = self._depression
        depression += 90

        try:
            return self._calc_time(depression, SUN_RISING, date, latitude, longitude)
        except:
            raise AstralError(('Sun never reaches %d degrees below the horizon, '
                               'at this location.') % (depression - 90))

    def sunrise_utc(self, date, latitude, longitude):
        """Calculate sunrise time in the UTC timezone.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: The UTC date and time at which sunrise occurs.
        :rtype: :class:`~datetime.datetime`
        """

        try:
            return self._calc_time(90 + 0.833, SUN_RISING, date, latitude, longitude)
        except:
            raise AstralError(('Sun never reaches the horizon on this day, '
                               'at this location.'))

    def solar_noon_utc(self, date, longitude):
        """Calculate solar noon time in the UTC timezone.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: The UTC date and time at which noon occurs.
        :rtype: :class:`~datetime.datetime`
        """

        jc = self._jday_to_jcentury(self._julianday(date))
        eqtime = self._eq_of_time(jc)
        timeUTC = (720.0 - (4 * longitude) - eqtime) / 60.0

        hour = int(timeUTC)
        minute = int((timeUTC - hour) * 60)
        second = int((((timeUTC - hour) * 60) - minute) * 60)

        if second > 59:
            second -= 60
            minute += 1
        elif second < 0:
            second += 60
            minute -= 1

        if minute > 59:
            minute -= 60
            hour += 1
        elif minute < 0:
            minute += 60
            hour -= 1

        if hour > 23:
            hour -= 24
            date += datetime.timedelta(days=1)
        elif hour < 0:
            hour += 24
            date -= datetime.timedelta(days=1)

        noon = datetime.datetime(date.year, date.month, date.day,
                                 hour, minute, second)
        noon = pytz.UTC.localize(noon)

        return noon

    def sunset_utc(self, date, latitude, longitude):
        """Calculate sunset time in the UTC timezone.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: The UTC date and time at which sunset occurs.
        :rtype: :class:`~datetime.datetime`
        """

        try:
            return self._calc_time(90 + 0.833, SUN_SETTING, date, latitude, longitude)
        except:
            raise AstralError(('Sun never reaches the horizon on this day, '
                               'at this location.'))

    def dusk_utc(self, date, latitude, longitude, depression=0):
        """Calculate dusk time in the UTC timezone.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float
        :param depression: Override the depression used
        :type depression:   float

        :return: The UTC date and time at which dusk occurs.
        :rtype: :class:`~datetime.datetime`
        """

        if depression == 0:
            depression = self._depression
        depression += 90

        try:
            return self._calc_time(depression, SUN_SETTING, date, latitude, longitude)
        except:
            raise AstralError(('Sun never reaches %d degrees below the horizon, '
                               'at this location.') % (depression - 90))

    def solar_midnight_utc(self, date, longitude):
        """Calculate solar midnight time in the UTC timezone.

        Note that this claculates the solar midgnight that is closest
        to 00:00:00 of the specified date i.e. it may return a time that is on
        the previous day.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: The UTC date and time at which midnight occurs.
        :rtype: :class:`~datetime.datetime`
        """

        julianday = self._julianday(date)

        newt = self._jday_to_jcentury(julianday + 0.5 + -longitude / 360.0)

        eqtime = self._eq_of_time(newt)
        timeUTC = (-longitude * 4.0) - eqtime

        timeUTC = timeUTC / 60.0
        hour = int(timeUTC)
        minute = int((timeUTC - hour) * 60)
        second = int((((timeUTC - hour) * 60) - minute) * 60)

        if second > 59:
            second -= 60
            minute += 1
        elif second < 0:
            second += 60
            minute -= 1

        if minute > 59:
            minute -= 60
            hour += 1
        elif minute < 0:
            minute += 60
            hour -= 1

        if hour < 0:
            hour += 24
            date -= datetime.timedelta(days=1)

        midnight = datetime.datetime(date.year, date.month, date.day,
                                     hour, minute, second)
        midnight = pytz.UTC.localize(midnight)

        return midnight

    def daylight_utc(self, date, latitude, longitude):
        """Calculate daylight start and end times in the UTC timezone.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: A tuple of the UTC date and time at which daylight starts and ends.
        :rtype: (:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        start = self.sunrise_utc(date, latitude, longitude)
        end = self.sunset_utc(date, latitude, longitude)

        return start, end

    def night_utc(self, date, latitude, longitude):
        """Calculate night start and end times in the UTC timezone.

        Night is calculated to be between astronomical dusk on the
        date specified and astronomical dawn of the next day.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: A tuple of the UTC date and time at which night starts and ends.
        :rtype: (:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        start = self.dusk_utc(date, latitude, longitude, 18)
        tomorrow = date + datetime.timedelta(days=1)
        end = self.dawn_utc(tomorrow, latitude, longitude, 18)

        return start, end

    def twilight_utc(self, direction, date, latitude, longitude):
        """Returns the start and end times of Twilight in the UTC timezone when
        the sun is traversing in the specified direction.

        This method defines twilight as being between the time
        when the sun is at -6 degrees and sunrise/sunset.

        :param direction:  Determines whether the time is for the sun rising or setting.
                           Use ``astral.SUN_RISING`` or ``astral.SUN_SETTING``.
        :type direction:   int
        :param date: The date for which to calculate the times.
        :type date: :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: A tuple of the UTC date and time at which twilight starts and ends.
        :rtype: (:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        if date is None:
            date = datetime.date.today()

        start = self.time_at_elevation_utc(-6, direction, date, latitude, longitude)
        if direction == SUN_RISING:
            end = self.sunrise_utc(date, latitude, longitude)
        else:
            end = self.sunset_utc(date, latitude, longitude)

        if direction == SUN_RISING:
            return start, end
        else:
            return end, start

    def golden_hour_utc(self, direction, date, latitude, longitude):
        """Returns the start and end times of the Golden Hour in the UTC timezone
        when the sun is traversing in the specified direction.

        This method uses the definition from PhotoPills i.e. the
        golden hour is when the sun is between 4 degrees below the horizon
        and 6 degrees above.

        :param direction:  Determines whether the time is for the sun rising or setting.
                           Use ``astral.SUN_RISING`` or ``astral.SUN_SETTING``.
        :type direction:   int
        :param date: The date for which to calculate the times.
        :type date: :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: A tuple of the UTC date and time at which the Golden Hour starts and ends.
        :rtype: (:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        if date is None:
            date = datetime.date.today()

        start = self.time_at_elevation_utc(-4, direction, date,
                                           latitude, longitude)
        end = self.time_at_elevation_utc(6, direction, date,
                                         latitude, longitude)

        if direction == SUN_RISING:
            return start, end
        else:
            return end, start

    def blue_hour_utc(self, direction, date, latitude, longitude):
        """Returns the start and end times of the Blue Hour in the UTC timezone
        when the sun is traversing in the specified direction.

        This method uses the definition from PhotoPills i.e. the
        blue hour is when the sun is between 6 and 4 degrees below the horizon.

        :param direction:  Determines whether the time is for the sun rising or setting.
                           Use ``astral.SUN_RISING`` or ``astral.SUN_SETTING``.
        :type direction:   int
        :param date: The date for which to calculate the times.
        :type date: :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: A tuple of the UTC date and time at which the Blue Hour starts and ends.
        :rtype: (:class:`~datetime.datetime`, :class:`~datetime.datetime`)
        """

        if date is None:
            date = datetime.date.today()

        start = self.time_at_elevation_utc(-6, direction, date,
                                           latitude, longitude)
        end = self.time_at_elevation_utc(-4, direction, date,
                                         latitude, longitude)

        if direction == SUN_RISING:
            return start, end
        else:
            return end, start

    def time_at_elevation_utc(self, elevation, direction, date, latitude, longitude):
        """Calculate the time in the UTC timezone when the sun is at
        the specified elevation on the specified date.

        Note: This method uses positive elevations for those above the horizon.

        :param elevation:  Elevation in degrees above the horizon to calculate for.
        :type elevation:   float
        :param direction:  Determines whether the calculated time is for the sun rising or setting.
                           Use ``astral.SUN_RISING`` or ``astral.SUN_SETTING``. Default is rising.
        :type direction:   int
        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: The UTC date and time at which the sun is at the required
                 elevation.
        :rtype: :class:`~datetime.datetime`
        """

        if elevation > 90.0:
            elevation = 180.0 - elevation
            direction = SUN_SETTING

        depression = 90 - elevation
        try:
            return self._calc_time(depression, direction, date, latitude, longitude)
        except Exception:
            raise AstralError(('Sun never reaches an elevation of %d degrees'
                               'at this location.') % elevation)

    def solar_azimuth(self, dateandtime, latitude, longitude):
        """Calculate the azimuth angle of the sun.

        :param dateandtime: The date and time for which to calculate
                            the angle.
        :type dateandtime:  :class:`~datetime.datetime`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: The azimuth angle in degrees clockwise from North.
        :rtype: float

        If `dateandtime` is a naive Python datetime then it is assumed to be
        in the UTC timezone.
        """

        if latitude > 89.8:
            latitude = 89.8

        if latitude < -89.8:
            latitude = -89.8

        if dateandtime.tzinfo is None:
            zone = 0
            utc_datetime = dateandtime
        else:
            zone = -dateandtime.utcoffset().total_seconds() / 3600.0
            utc_datetime = dateandtime.astimezone(pytz.utc)

        timenow = utc_datetime.hour + (utc_datetime.minute / 60.0) + \
            (utc_datetime.second / 3600.0)

        JD = self._julianday(dateandtime)
        t = self._jday_to_jcentury(JD + timenow / 24.0)
        theta = self._sun_declination(t)
        eqtime = self._eq_of_time(t)
        solarDec = theta   # in degrees

        solarTimeFix = eqtime - (4.0 * -longitude) + (60 * zone)
        trueSolarTime = dateandtime.hour * 60.0 + dateandtime.minute + \
            dateandtime.second / 60.0 + solarTimeFix
        #    in minutes

        while trueSolarTime > 1440:
            trueSolarTime = trueSolarTime - 1440

        hourangle = trueSolarTime / 4.0 - 180.0
        #    Thanks to Louis Schwarzmayr for the next line:
        if hourangle < -180:
            hourangle = hourangle + 360.0

        harad = radians(hourangle)

        csz = sin(radians(latitude)) * sin(radians(solarDec)) + \
            cos(radians(latitude)) * cos(radians(solarDec)) * cos(harad)

        if csz > 1.0:
            csz = 1.0
        elif csz < -1.0:
            csz = -1.0

        zenith = degrees(acos(csz))

        azDenom = (cos(radians(latitude)) * sin(radians(zenith)))

        if abs(azDenom) > 0.001:
            azRad = ((sin(radians(latitude)) * cos(radians(zenith))) -
                     sin(radians(solarDec))) / azDenom

            if abs(azRad) > 1.0:
                if azRad < 0:
                    azRad = -1.0
                else:
                    azRad = 1.0

            azimuth = 180.0 - degrees(acos(azRad))

            if hourangle > 0.0:
                azimuth = -azimuth
        else:
            if latitude > 0.0:
                azimuth = 180.0
            else:
                azimuth = 0.0

        if azimuth < 0.0:
            azimuth = azimuth + 360.0

        return azimuth

    def solar_elevation(self, dateandtime, latitude, longitude):
        """Calculate the elevation angle of the sun.

        :param dateandtime: The date and time for which to calculate
                            the angle.
        :type dateandtime:  :class:`~datetime.datetime`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: The elevation angle in degrees above the horizon.
        :rtype: float

        If `dateandtime` is a naive Python datetime then it is assumed to be
        in the UTC timezone.
        """

        if latitude > 89.8:
            latitude = 89.8

        if latitude < -89.8:
            latitude = -89.8

        if dateandtime.tzinfo is None:
            zone = 0
            utc_datetime = dateandtime
        else:
            zone = -dateandtime.utcoffset().total_seconds() / 3600.0
            utc_datetime = dateandtime.astimezone(pytz.utc)

        timenow = utc_datetime.hour + (utc_datetime.minute / 60.0) + \
            (utc_datetime.second / 3600)

        JD = self._julianday(dateandtime)
        t = self._jday_to_jcentury(JD + timenow / 24.0)
        theta = self._sun_declination(t)
        eqtime = self._eq_of_time(t)
        solarDec = theta   # in degrees

        solarTimeFix = eqtime - (4.0 * -longitude) + (60 * zone)
        trueSolarTime = dateandtime.hour * 60.0 + dateandtime.minute + \
            dateandtime.second / 60.0 + solarTimeFix
        #    in minutes

        while trueSolarTime > 1440:
            trueSolarTime = trueSolarTime - 1440

        hourangle = trueSolarTime / 4.0 - 180.0
        # Thanks to Louis Schwarzmayr for the next line:
        if hourangle < -180:
            hourangle = hourangle + 360.0

        harad = radians(hourangle)

        csz = sin(radians(latitude)) * sin(radians(solarDec)) + \
            cos(radians(latitude)) * cos(radians(solarDec)) * cos(harad)

        if csz > 1.0:
            csz = 1.0
        elif csz < -1.0:
            csz = -1.0

        zenith = degrees(acos(csz))

        azDenom = (cos(radians(latitude)) * sin(radians(zenith)))

        if abs(azDenom) > 0.001:
            azRad = ((sin(radians(latitude)) * cos(radians(zenith))) -
                     sin(radians(solarDec))) / azDenom

            if abs(azRad) > 1.0:
                if azRad < 0:
                    azRad = -1.0
                else:
                    azRad = 1.0

            azimuth = 180.0 - degrees(acos(azRad))

            if hourangle > 0.0:
                azimuth = -azimuth
        else:
            if latitude > 0.0:
                azimuth = 180.0
            else:
                azimuth = 0.0

        if azimuth < 0.0:
            azimuth = azimuth + 360.0

        exoatmElevation = 90.0 - zenith

        if exoatmElevation > 85.0:
            refractionCorrection = 0.0
        else:
            te = tan(radians(exoatmElevation))
            if exoatmElevation > 5.0:
                refractionCorrection = 58.1 / te - 0.07 / (te * te * te) + \
                    0.000086 / (te * te * te * te * te)
            elif exoatmElevation > -0.575:
                step1 = (-12.79 + exoatmElevation * 0.711)
                step2 = (103.4 + exoatmElevation * (step1))
                step3 = (-518.2 + exoatmElevation * (step2))
                refractionCorrection = 1735.0 + exoatmElevation * (step3)
            else:
                refractionCorrection = -20.774 / te

            refractionCorrection = refractionCorrection / 3600.0

        solarzen = zenith - refractionCorrection

        solarelevation = 90.0 - solarzen

        return solarelevation

    def solar_zenith(self, dateandtime, latitude, longitude):
        """Calculates the solar zenith angle.

        :param dateandtime: The date and time for which to calculate
                            the angle.
        :type dateandtime: :class:`~datetime.datetime`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: The zenith angle in degrees from vertical.
        :rtype: float

        If `dateandtime` is a naive Python datetime then it is assumed to be
        in the UTC timezone.
        """

        return 90.0 - self.solar_elevation(dateandtime, latitude, longitude)

    def moon_phase(self, date):
        """Calculates the phase of the moon on the specified date.

        :param date: The date to calculate the phase for.
        :type date: :class:`datetime.date`

        :return:
            A number designating the phase

                | 0  = New moon
                | 7  = First quarter
                | 14 = Full moon
                | 21 = Last quarter
        :rtype: int
        """

        jd = self._julianday(date)
        DT = pow((jd - 2382148), 2) / (41048480 * 86400)
        T = (jd + DT - 2451545.0) / 36525
        T2 = pow(T, 2)
        T3 = pow(T, 3)
        D = 297.85 + (445267.1115 * T) - (0.0016300 * T2) + (T3 / 545868)
        D = radians(self._proper_angle(D))
        M = 357.53 + (35999.0503 * T)
        M = radians(self._proper_angle(M))
        M1 = 134.96 + (477198.8676 * T) + (0.0089970 * T2) + (T3 / 69699)
        M1 = radians(self._proper_angle(M1))
        elong = degrees(D) + 6.29 * sin(M1)
        elong -= 2.10 * sin(M)
        elong += 1.27 * sin(2 * D - M1)
        elong += 0.66 * sin(2 * D)
        elong = self._proper_angle(elong)
        elong = round(elong)
        moon = ((elong + 6.43) / 360) * 28
        moon = floor(moon)
        if moon == 28:
            moon = 0

        return moon

    def rahukaalam_utc(self, date, latitude, longitude):
        """Calculate ruhakaalam times in the UTC timezone.

        :param date:       Date to calculate for.
        :type date:        :class:`datetime.date`
        :param latitude:   Latitude - Northern latitudes should be positive
        :type latitude:    float
        :param longitude:  Longitude - Eastern longitudes should be positive
        :type longitude:   float

        :return: Tuple containing the start and end times for Rahukaalam.
        :rtype: tuple
        """

        if date is None:
            date = datetime.date.today()

        sunrise = self.sunrise_utc(date, latitude, longitude)
        sunset = self.sunset_utc(date, latitude, longitude)

        octant_duration = datetime.timedelta(seconds=(sunset - sunrise).seconds / 8)

        # Mo,Sa,Fr,We,Th,Tu,Su
        octant_index = [1, 6, 4, 5, 3, 2, 7]

        weekday = date.weekday()
        octant = octant_index[weekday]

        start = sunrise + (octant_duration * octant)
        end = start + octant_duration

        return start, end

    def _proper_angle(self, value):
        if value > 0.0:
            value /= 360.0
            return (value - floor(value)) * 360.0
        else:
            tmp = ceil(abs(value / 360.0))
            return value + tmp * 360.0

    def _julianday(self, utcdatetime, timezone=None):
        if isinstance(utcdatetime, datetime.datetime):
            end_date = utcdatetime.date()
            hour = utcdatetime.hour
            minute = utcdatetime.minute
            second = utcdatetime.second
        else:
            end_date = utcdatetime
            hour = 0
            minute = 0
            second = 0

        if timezone:
            if isinstance(timezone, int):
                hour_offset = timezone
            else:
                offset = timezone.localize(utcdatetime).utcoffset()
                hour_offset = offset.total_seconds() / 3600.0
        else:
            hour_offset = 0

        start_date = datetime.date(1900, 1, 1)
        time_fraction = (hour * 3600.0 + minute * 60.0 + second) / (24.0 * 3600.0)
        date_diff = excel_datediff(start_date, end_date)
        jd = date_diff + 2415018.5 + time_fraction - (hour_offset / 24)

        return jd

    def _jday_to_jcentury(self, julianday):
        return (julianday - 2451545.0) / 36525.0

    def _jcentury_to_jday(self, juliancentury):
        return (juliancentury * 36525.0) + 2451545.0

    def _geom_mean_long_sun(self, juliancentury):
        l0 = 280.46646 + \
            juliancentury * (36000.76983 + 0.0003032 * juliancentury)
        return l0 % 360.0

    def _geom_mean_anomaly_sun(self, juliancentury):
        return 357.52911 + \
            juliancentury * (35999.05029 - 0.0001537 * juliancentury)

    def _eccentrilocation_earth_orbit(self, juliancentury):
        return 0.016708634 - \
            juliancentury * (0.000042037 + 0.0000001267 * juliancentury)

    def _sun_eq_of_center(self, juliancentury):
        m = self._geom_mean_anomaly_sun(juliancentury)

        mrad = radians(m)
        sinm = sin(mrad)
        sin2m = sin(mrad + mrad)
        sin3m = sin(mrad + mrad + mrad)

        c = sinm * (1.914602 - juliancentury * \
            (0.004817 + 0.000014 * juliancentury)) + \
            sin2m * (0.019993 - 0.000101 * juliancentury) + sin3m * 0.000289

        return c

    def _sun_true_long(self, juliancentury):
        l0 = self._geom_mean_long_sun(juliancentury)
        c = self._sun_eq_of_center(juliancentury)

        return l0 + c

    def _sun_true_anomoly(self, juliancentury):
        m = self._geom_mean_anomaly_sun(juliancentury)
        c = self._sun_eq_of_center(juliancentury)

        return m + c

    def _sun_rad_vector(self, juliancentury):
        v = self._sun_true_anomoly(juliancentury)
        e = self._eccentrilocation_earth_orbit(juliancentury)

        return (1.000001018 * (1 - e * e)) / (1 + e * cos(radians(v)))

    def _sun_apparent_long(self, juliancentury):
        O = self._sun_true_long(juliancentury)

        omega = 125.04 - 1934.136 * juliancentury
        return O - 0.00569 - 0.00478 * sin(radians(omega))

    def _mean_obliquity_of_ecliptic(self, juliancentury):
        seconds = 21.448 - juliancentury * \
            (46.815 + juliancentury * (0.00059 - juliancentury * (0.001813)))
        return 23.0 + (26.0 + (seconds / 60.0)) / 60.0

    def _obliquity_correction(self, juliancentury):
        e0 = self._mean_obliquity_of_ecliptic(juliancentury)

        omega = 125.04 - 1934.136 * juliancentury
        return e0 + 0.00256 * cos(radians(omega))

    def _sun_rt_ascension(self, juliancentury):
        oc = self._obliquity_correction(juliancentury)
        al = self._sun_apparent_long(juliancentury)

        tananum = (cos(radians(oc)) * sin(radians(al)))
        tanadenom = cos(radians(al))

        return degrees(atan2(tananum, tanadenom))

    def _sun_declination(self, juliancentury):
        e = self._obliquity_correction(juliancentury)
        lambd = self._sun_apparent_long(juliancentury)

        sint = sin(radians(e)) * sin(radians(lambd))
        return degrees(asin(sint))

    def _var_y(self, juliancentury):
        epsilon = self._obliquity_correction(juliancentury)
        y = tan(radians(epsilon) / 2.0)
        return y * y

    def _eq_of_time(self, juliancentury):
        l0 = self._geom_mean_long_sun(juliancentury)
        e = self._eccentrilocation_earth_orbit(juliancentury)
        m = self._geom_mean_anomaly_sun(juliancentury)

        y = self._var_y(juliancentury)

        sin2l0 = sin(2.0 * radians(l0))
        sinm = sin(radians(m))
        cos2l0 = cos(2.0 * radians(l0))
        sin4l0 = sin(4.0 * radians(l0))
        sin2m = sin(2.0 * radians(m))

        Etime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0 - \
            0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m

        return degrees(Etime) * 4.0

    def _hour_angle(self, latitude, declination, depression):
        latitude_rad = radians(latitude)
        declination_rad = radians(declination)
        depression_rad = radians(depression)

        n = cos(depression_rad)
        d = cos(latitude_rad) * cos(declination_rad)
        t = tan(latitude_rad) * tan(declination_rad)
        h = (n / d) - t

        HA = acos(h)
        return HA

    def _calc_time(self, depression, direction, date, latitude, longitude):
        julianday = self._julianday(date)

        if latitude > 89.8:
            latitude = 89.8

        if latitude < -89.8:
            latitude = -89.8

        t = self._jday_to_jcentury(julianday)
        eqtime = self._eq_of_time(t)
        solarDec = self._sun_declination(t)

        hourangle = self._hour_angle(latitude, solarDec, depression)
        if direction == SUN_SETTING:
            hourangle = -hourangle

        delta = -longitude - degrees(hourangle)
        timeDiff = 4.0 * delta
        timeUTC = 720.0 + timeDiff - eqtime

        timeUTC = timeUTC / 60.0
        hour = int(timeUTC)
        minute = int((timeUTC - hour) * 60)
        second = int((((timeUTC - hour) * 60) - minute) * 60)

        if second > 59:
            second -= 60
            minute += 1
        elif second < 0:
            second += 60
            minute -= 1

        if minute > 59:
            minute -= 60
            hour += 1
        elif minute < 0:
            minute += 60
            hour -= 1

        if hour > 23:
            hour -= 24
            date += datetime.timedelta(days=1)
        elif hour < 0:
            hour += 24
            date -= datetime.timedelta(days=1)

        dt = datetime.datetime(date.year, date.month, date.day,
                               hour, minute, second)
        dt = pytz.UTC.localize(dt)

        return dt


#!/usr/python

# from R
"""
sunPosition <- function(year, month, day, hour=12, min=0, sec=0,
                    lat=46.5, long=6.5) {

    twopi <- 2 * pi
    deg2rad <- pi / 180

    # Get day of the year, e.g. Feb 1 = 32, Mar 1 = 61 on leap years
    month.days <- c(0,31,28,31,30,31,30,31,31,30,31,30)
    day <- day + cumsum(month.days)[month]
    leapdays <- year %% 4 == 0 & (year %% 400 == 0 | year %% 100 != 0) & 
                day >= 60 & !(month==2 & day==60)
    day[leapdays] <- day[leapdays] + 1

    # Get Julian date - 2400000
    hour <- hour + min / 60 + sec / 3600 # hour plus fraction
    delta <- year - 1949
    leap <- trunc(delta / 4) # former leapyears
    jd <- 32916.5 + delta * 365 + leap + day + hour / 24

    # The input to the Atronomer's almanach is the difference between
    # the Julian date and JD 2451545.0 (noon, 1 January 2000)
    time <- jd - 51545.

    # Ecliptic coordinates

    # Mean longitude
    mnlong <- 280.460 + .9856474 * time
    mnlong <- mnlong %% 360
    #mnlong[mnlong < 0] <- mnlong[mnlong < 0] + 360

    # Mean anomaly
    mnanom <- 357.528 + .9856003 * time
    mnanom <- mnanom %% 360
    mnanom[mnanom < 0] <- mnanom[mnanom < 0] + 360
    mnanom <- mnanom * deg2rad

    # Ecliptic longitude and obliquity of ecliptic
    eclong <- mnlong + 1.915 * sin(mnanom) + 0.020 * sin(2 * mnanom)
    eclong <- eclong %% 360
    eclong[eclong < 0] <- eclong[eclong < 0] + 360
    oblqec <- 23.439 - 0.0000004 * time
    eclong <- eclong * deg2rad
    oblqec <- oblqec * deg2rad

    # Celestial coordinates
    # Right ascension and declination
    num <- cos(oblqec) * sin(eclong)
    den <- cos(eclong)
    ra <- atan(num / den)
    ra[den < 0] <- ra[den < 0] + pi
    ra[den >= 0 & num < 0] <- ra[den >= 0 & num < 0] + twopi
    dec <- asin(sin(oblqec) * sin(eclong))

    # Local coordinates
    # Greenwich mean sidereal time
    gmst <- 6.697375 + .0657098242 * time + hour
    gmst <- gmst %% 24
    gmst[gmst < 0] <- gmst[gmst < 0] + 24.

    # Local mean sidereal time
    lmst <- gmst + long / 15.
    lmst <- lmst %% 24.
    lmst[lmst < 0] <- lmst[lmst < 0] + 24.
    lmst <- lmst * 15. * deg2rad

    # Hour angle
    ha <- lmst - ra
    ha[ha < -pi] <- ha[ha < -pi] + twopi
    ha[ha > pi] <- ha[ha > pi] - twopi

    # Latitude to radians
    lat <- lat * deg2rad

    # Solar zenith angle
    zenithAngle <- acos(sin(lat) * sin(dec) + cos(lat) * cos(dec) * cos(ha))
    # Solar azimuth
    az <- acos(((sin(lat) * cos(zenithAngle)) - sin(dec)) / (cos(lat) * sin(zenithAngle)))
    rm(zenithAngle)

    # Azimuth and elevation
    el <- asin(sin(dec) * sin(lat) + cos(dec) * cos(lat) * cos(ha))

    el <- el / deg2rad
    az <- az / deg2rad
    lat <- lat / deg2rad

    # -----------------------------------------------
    # Azimuth correction for Hour Angle
    if (ha > 0) az <- az + 180 else az <- 540 - az
    az <- az %% 360

    return(list(elevation=el, azimuth=az))
}
"""
import math

def leapyear(year):  
    if year % 400 == 0:   return True
    elif year % 100 == 0: return False  
    elif year % 4 == 0:   return True  
    else: return False
    

def calc_time(year, month, day, hour=12, minute=0, sec=0):
    # Get day of the year, e.g. Feb 1 = 32, Mar 1 = 61 on leap years
    month_days = [0,31,28,31,30,31,30,31,31,30,31,30]
    day = day + sum(month_days[:month])
    leapdays = leapyear(year) and day >= 60 and (not (month==2 and day==60))
    if leapdays: day += 1

    # Get Julian date - 2400000
    hour = hour + minute / 60.0 + sec / 3600.0 # hour plus fraction
    delta = year - 1949
    leap = delta // 4 # former leapyears
    jd = 32916.5 + delta * 365 + leap + day + hour / 24.0
    # The input to the Astronomer's almanac is the difference between
    # the Julian date and JD 2451545.0 (noon, 1 January 2000)
    time = jd - 51545
    return time

    
def sun_position(year, month, day, hour=12, minute=0, sec=0,
                lat=46.5, longitude=6.5):

    twopi = 2 * math.pi
    deg2rad = math.pi / 180

    time = calc_time(year, month, day, hour, minute, sec)

    # Ecliptic coordinates
    # Mean longitude
    mnlong = 280.46 + 0.9856474 * time
    mnlong = mnlong % 360
    if mnlong < 0: mnlong += 360

    # Mean anomaly
    mnanom = 357.528 + 0.9856003 * time
    mnanom = mnanom % 360
    if mnanom < 0: mnanom += 360
    mnanom = mnanom * deg2rad

    # Ecliptic longitude and obliquity of ecliptic
    eclong = mnlong + 1.915 * math.sin(mnanom) + 0.02 * math.sin(2 * mnanom)
    eclong = eclong % 360
    if eclong < 0: eclong += 360
    oblqec = 23.439 - 0.0000004 * time
    eclong = eclong * deg2rad
    oblqec = oblqec * deg2rad

    # Celestial coordinates
    # Right ascension and declination
    num = math.cos(oblqec) * math.sin(eclong)
    den = math.cos(eclong)
    ra = math.atan(num / den)
    if den < 0: ra += math.pi
    if den >= 0 and num < 0: ra += twopi
    dec = math.asin(math.sin(oblqec) * math.sin(eclong))

    # Local coordinates
    # Greenwich mean sidereal time
    gmst = 6.697375 + 0.0657098242 * time + hour
    gmst = gmst % 24
    if gmst < 0: gmst += 24

    # Local mean sidereal time
    lmst = gmst + longitude / 15.0
    lmst = lmst % 24
    if lmst < 0: lmst += 24
    lmst = lmst * 15 * deg2rad

    # Hour angle
    ha = lmst - ra
    if ha < -math.pi: ha += twopi
    if ha > math.pi: ha -= twopi

    # Latitude to radians
    lat = lat * deg2rad

##    # Azimuth and elevation
##    el = math.asin(math.sin(dec) * math.sin(lat) + math.cos(dec) * math.cos(lat) * math.cos(ha))
##    az = math.asin(-math.cos(dec) * math.sin(ha) / math.cos(el))
##
##    # For logic and names, see Spencer, J.W. 1989. Solar Energy. 42(4):353
##    cosAzPos = 0 <= math.sin(dec) - math.sin(el) * math.sin(lat)
##    sinAzNeg = math.sin(az) < 0
##    #print " ", cosAzPos, sinAzNeg
##    if cosAzPos and sinAzNeg: az += twopi
##    if not(cosAzPos): az = math.pi - az
    # Solar zenith angle
    zenithAngle = math.acos(math.sin(lat) * math.sin(dec) + math.cos(lat) * math.cos(dec) * math.cos(ha))
    # Solar azimuth
    az = math.acos(((math.sin(lat) * math.cos(zenithAngle)) - math.sin(dec)) / (math.cos(lat) * math.sin(zenithAngle)))
    #rm(zenithAngle)
    el = math.asin(math.sin(dec) * math.sin(lat) + math.cos(dec) * math.cos(lat) * math.cos(ha))
    
    el = el / deg2rad
    az = az / deg2rad
    lat = lat / deg2rad

    # Azimuth correction for Hour Angle
    if ha > 0:
        #print "  corrected az. +180", az
        #print "    fix?", (az+180-(az*2)) %360
        az += 180
    else:
        #print "  corrected az. 540-az", az
        #print "    fix?", (540+az) %360
        az = 540 - az
    az = az % 360
    return(az, el)

#  A latitude or longitude with 8 decimal places pinpoints a location to within 1 millimeter,( 1/16 inch).
#   Precede South latitudes and West longitudes with a minus sign.
#    Latitudes range from -90 to 90.
#    Longitudes range from -180 to 180.
#    E.g.
#    41.25 and -120.9762
#    -31.96 and 115.84
#    90 and 0 (North Pole)



if __name__ == '__main__':
    ### Tests
    # Latitude: North = +, South = -
    # Longitude: East = -, West = +
    # For July 1 2014
    samples = [(46.5,6.5, 163.03, 65.83),
               (46.0,6.0, 163.82, 66.41),
               (-41,0,    0.98, 25.93),
               (-3,0,     2.01,63.9),
               (3,0,      2.58, 69.89),
               (41,0,     177.11, 72.07),
               (40,0,     176.95, 73.07),
               (-40,0,    0.99, 26.93),
               (-40,40,   38.91, 16.31),
               (-40,-40,  322.67, 17.22),
               (-20,-100, 289.35, -15.64),
               (20,-100,  29.47, 0.4),
               (80,-100,  283.05, 21.2),
               (80,-20,   200.83, 32.51),
               (80,0,     178.94, 33.11),
               (80,40,    135.6, 30.47),
               (80,120,   55.89, 17.74),
               (0, 0,     2.26, 66.89)
               ]
    print "Noon July 1 2014 at 0,0 = 2.26, 66.89"
    print "",sun_position(2014,7,1, lat=0, longitude=0)
    print "Noon Dec 22 2012 at 41,0 = 180.03, 25.6"
    print "",sun_position(2012, 12, 22, lat=41, longitude=0)
    print "Noon Dec 22 2012 at -41,0 = 359.09, 72.44"
    print "",sun_position(2012, 12, 22, lat=-41, longitude=0)
    print

    for s in samples:
        lat, lon, az, el = s
        print "\nFor lat,long:", lat, lon,
        calc_az, calc_el = sun_position(2014,7,1, lat=lat, longitude=lon)
        az_ok = abs(az-calc_az) < 0.5
        el_ok = abs(el-calc_el) < 0.5
        if not(az_ok and el_ok):
            print "\n Azimuth (Noaa,calc)   = %4.2f %4.2f (error %4.2f)" %(az, calc_az, abs(az-calc_az))
            print " Elevation (Noaa,calc) = %4.2f %4.2f (error %4.2f)" %(el, calc_el, abs(el-calc_el))
        else:
            print" OK (<0.5 error)"




14.797424, 121.057481

import urllib2

request = urllib2.Request(new_url)

import urllib2
from urllib2 import urlopen
import sys
sys.path.insert(0,"/home/jack/anaconda2/lib/python2.7/site-packages")
import requests
request = urllib2.Request('http://api.sunrise-sunset.org/json?lat=14.797424&lng=121.057481&formatted=0')
response = urlopen(request)
timestring = response.read()
timestring = str(timestring)
timestring = timestring.replace('":"', ':  ');timestring = timestring.replace('":{"', '\n')
timestring = timestring.replace('":', ' in seconds: ')
timestring = timestring.replace(',"', '\n');timestring = timestring.replace('"}', '')
timestring = timestring.replace('{"', '')
print timestring

import pprint
import urllib2
from urllib2 import urlopen
import sys
sys.path.insert(0,"/home/jack/anaconda2/lib/python2.7/site-packages")
import requests
request = urllib2.Request('http://api.sunrise-sunset.org/json?lat=14.797424&lng=121.057481&formatted=0')
response = urlopen(request)
timestring = response.read()

pprint.pprint(timestring)

import ephem
help(ephem)

import ephem
atlanta = ephem.Observer()
atlanta.pressure = 0
atlanta.horizon = '-0:34'

atlanta.lat, atlanta.lon = '33.8', '-84.4'
atlanta.date = '2017/10/17 17:00' # noon EST
print(atlanta.previous_rising(ephem.Sun()))
print(atlanta.next_setting(ephem.Sun()))
print(atlanta.previous_rising(ephem.Moon()))
print(atlanta.next_setting(ephem.Moon()))


atlanta.horizon = '-6'
print(atlanta.previous_rising(ephem.Sun(), use_center=True))
print(atlanta.next_setting(ephem.Sun(), use_center=True))

import ephem
j = ephem.Jupiter('2017/10/17')
print "Jupiter's distance in light seconds from Earth"
print("%.2f sec" % (j.earth_distance * ephem.meters_per_au / ephem.c))

# Creating an Ephem Date
import ephem
d = ephem.Date('2017/10/17 07:05:45.12')
print(d)

#!/usr/bin/python
import time
now = time.strftime("%c")
## date and time representation
print time.strftime("%c")
## Only date representation
print time.strftime("%x")
## Only time representation
print time.strftime("%X")
## Display current date and time from now variable 
print (now )

print time.strftime("%X %C")

print now,"-------",now[-20:],"-------",now[-20:][:-4]

from datetime import datetime
i = datetime.now()
print str(i),"-----",i.strftime('%Y/%m/%d %H:%M:%S')

#!/usr/bin/python
#24 hour clock 
import time
print (time.strftime("%H:%M:%S"))
## 12 hour format ##
print (time.strftime("%I:%M:%S"))



# Creating an Ephem Date
import ephem
d = ephem.Date('2017/10/17 07:05:45.12')
print(d)

from datetime import datetime
i = datetime.now()
print i.strftime('%Y/%m/%d %H:%M:%S')

from datetime import datetime
i = datetime.now()
Ein = i.strftime('%Y/%m/%d %H:%M:%S')
# Creating an Ephem Date
import ephem
d = ephem.Date(Ein)
print(d)

import ephem
lt = ephem.localtime(d)
print(lt)
print(repr(lt))



#################################################################################
# http://sherrytowers.com/2014/04/13/archeoastronomy-where-on-the-horizon-do-the-stars-sun-moon-rise-and-set-part-ii/
# A python script to calculate the declinations for past years for
# all the stars in the pyephem star catalog, from 5000BC to present in 
# increments of 50 years.
# To run the script type
#    python ./stars_print_out_ra_and_dec.py
# the script will output the file stars_print_out_ra_and_dec.out
#
# http://www.sherrytowers.com/stars.py
#
# Author: Sherry Towers
#         smtowers _at_ asu.edu
# Created: Dec 2nd, 2013
#
# Copyright Sherry Towers, 2013, 2014
#
# This script is not guaranteed to be free of bugs and/or errors.
#
# This script can be freely used and shared as long as the author and
# copyright information in this header remain intact.
##################################################################################
import ephem
global star
import ephem.stars
from ephem import *
messierdb = 'Messier.edb'
from math import pi

temp = ephem.Observer()
temp.elevation = 0

hyades = ephem.FixedBody()
hyades._ra = '4:27:0.0'
hyades._dec = '15:52:00.0'
hyades._pmra = 0.0
hyades._pmdec = 0.0
hyades.name = 'Hyades'
# NB: proper motion could be obtained from Gamma Tauri

SN1006 = ephem.FixedBody()
SN1006._ra = '15:2:8.0'
SN1006._dec = '-41:57:00.0'
SN1006._pmra = 0.0
SN1006._pmdec = 0.0
SN1006.name = 'SN1006'
SN1054 = ephem.FixedBody()
SN1054._ra = '5:34:20.0'
SN1054._dec = '22:01:00.0'
SN1054._pmra = 0.0
SN1054._pmdec = 0.0
SN1054.name = 'SN1054'

##################################################################################
# the Sun, plus the list of stars from
# http://github.com/brandon-rhodes/pyephem/blob/master/src/ephem/stars.py
##################################################################################
sirius  = ephem.star('Sirius')
canopus = ephem.star('Canopus')
arcturus = ephem.star('Arcturus')
vega = ephem.star('Vega')
rigel = ephem.star('Rigel')
procyon = ephem.star('Procyon')
betelgeuse = ephem.star('Betelgeuse')
capella = ephem.star('Capella')
altair = ephem.star('Altair')
aldebaran = ephem.star('Aldebaran')
spica = ephem.star('Spica')
antares = ephem.star('Antares')
pollux = ephem.star('Pollux')
fomalhaut = ephem.star('Fomalhaut')
deneb = ephem.star('Deneb')
regulus = ephem.star('Regulus')
pleiades = ephem.star('Alcyone')
alnitak = ephem.star('Alnitak')
alnilam = ephem.star('Alnilam')
mintaka = ephem.star('Mintaka')
eta_orionis = ephem.star('Saiph')
menkar = ephem.star('Menkar')
bellatrix = ephem.star('Bellatrix')
elnath = ephem.star('Elnath')
shaula = ephem.star('Shaula')
adara = ephem.star('Adara')
alnair = ephem.star('Alnair')
wezen = ephem.star('Wezen')
alhena = ephem.star('Alhena')
castor = ephem.star('Castor')
mirzam = ephem.star('Mirzam')
alphard = ephem.star('Alphard')
sirrah = ephem.star('Sirrah')
caph = ephem.star('Caph')
algenib = ephem.star('Algenib')
schedar = ephem.star('Schedar')
mirach = ephem.star('Mirach')
achernar = ephem.star('Achernar')
almach = ephem.star('Almach')
hamal = ephem.star('Hamal')
polaris = ephem.star('Polaris')
algol = ephem.star('Algol')
electra = ephem.star('Electra')
taygeta = ephem.star('Taygeta')
maia = ephem.star('Maia')
merope = ephem.star('Merope')
alcyone = ephem.star('Alcyone')
atlas = ephem.star('Atlas')
zaurak = ephem.star('Zaurak')
nihal = ephem.star('Nihal')
arneb = ephem.star('Arneb')
menkalinan = ephem.star('Menkalinan')
naos = ephem.star('Naos')
algieba = ephem.star('Algieba')
merak = ephem.star('Merak')
dubhe = ephem.star('Dubhe')
denebola = ephem.star('Denebola')
phecda = ephem.star('Phecda')
minkar = ephem.star('Minkar')
megrez = ephem.star('Megrez')
gienah = ephem.star('Gienah Corvi')
mimosa = ephem.star('Mimosa')
alioth = ephem.star('Alioth')
vindemiatrix = ephem.star('Vindemiatrix')
mizar = ephem.star('Mizar')
alcor = ephem.star('Alcor')
alcaid = ephem.star('Alcaid')
agena = ephem.star('Agena')
thuban = ephem.star('Thuban')
izar = ephem.star('Izar')
kochab = ephem.star('Kochab')
alphecca = ephem.star('Alphecca')
unukalhai = ephem.star('Unukalhai')
rasalgethi = ephem.star('Rasalgethi')
cebalrai = ephem.star('Cebalrai')
etamin = ephem.star('Etamin')
kaus_australis = ephem.star('Kaus Australis')
sheliak = ephem.star('Sheliak')
nunki = ephem.star('Nunki')
sulafat = ephem.star('Sulafat')
arkab_prior = ephem.star('Arkab Prior')
arkab_posterior = ephem.star('Arkab Posterior')
rukbat = ephem.star('Rukbat')
albereo = ephem.star('Albereo')
tarazed = ephem.star('Tarazed')
alshain = ephem.star('Alshain')
sadr = ephem.star('Sadr')
peacock = ephem.star('Peacock')
alderamin = ephem.star('Alderamin')
alfirk = ephem.star('Alfirk')
enif = ephem.star('Enif')
sadalmelik = ephem.star('Sadalmelik')
scheat = ephem.star('Scheat')
markab = ephem.star('Markab')

##################################################################################
# now loop over the locations and dates and calculate the rise/set azimuths
##################################################################################
aname = "stars_print_out_ra_and_dec.out"
f=open(aname,'w')
f.write('epoch,star,RA,DEC,prop_RA,prop_DEC,mag\n')
for lat in range(0,1,1):
 temp.lon = "00:00:00.00"
 temp.lat = str(lat)+":00:00.00"
 lat = 180*float(temp.lat)/pi
 temp.elevation = 0
 for year in range(-5000,2060,50):
 # http://earthsky.org/brightest-stars/thuban-past-north-star
 #for year in range(-2787,-2786,1): # check Thuban... it is north star 2787BC
 #for year in range(2000,2001,1): # check Thuban... it is north star 2787BC
  for istar in range(1,98,1):
  #for istar in range(70,71,1):
    if istar==1: mystar=hyades
    if istar==2: mystar=sirius
    if istar==3: mystar=canopus
    if istar==4: mystar=arcturus
    if istar==5: mystar=vega
    if istar==6: mystar=rigel
    if istar==7: mystar=procyon
    if istar==8: mystar=betelgeuse
    if istar==9: mystar=capella
    if istar==10: mystar=altair
    if istar==11: mystar=aldebaran
    if istar==12: mystar=spica
    if istar==13: mystar=antares
    if istar==14: mystar=pollux 
    if istar==15: mystar=fomalhaut
    if istar==16: mystar=deneb
    if istar==17: mystar=regulus
    if istar==18: mystar=pleiades
    if istar==19: mystar=alnitak
    if istar==20: mystar=alnilam
    if istar==21: mystar=mintaka
    if istar==22: mystar=eta_orionis
    if istar==23: mystar=menkar
    if istar==24: mystar=bellatrix
    if istar==25: mystar=elnath
    if istar==26: mystar=shaula
    if istar==27: mystar=adara 
    if istar==28: mystar=alnair
    if istar==29: mystar=wezen 
    if istar==30: mystar=alhena
    if istar==31: mystar=castor
    if istar==32: mystar=mirzam
    if istar==33: mystar=alphard
    if istar==34: mystar=sirrah
    if istar==35: mystar=caph
    if istar==36: mystar=algenib
    if istar==37: mystar=schedar
    if istar==38: mystar=mirach
    if istar==39: mystar=achernar
    if istar==40: mystar=almach
    if istar==41: mystar=hamal
    if istar==42: mystar=polaris
    if istar==43: mystar=algol
    if istar==44: mystar=electra
    if istar==45: mystar=taygeta
    if istar==46: mystar=maia
    if istar==47: mystar=merope
    if istar==48: mystar=alcyone
    if istar==49: mystar=atlas
    if istar==50: mystar=zaurak
    if istar==51: mystar=nihal
    if istar==52: mystar=arneb
    if istar==53: mystar=menkalinan
    if istar==54: mystar=naos
    if istar==55: mystar=algieba
    if istar==56: mystar=merak
    if istar==57: mystar=dubhe
    if istar==58: mystar=denebola
    if istar==59: mystar=phecda
    if istar==60: mystar=minkar
    if istar==61: mystar=megrez
    if istar==62: mystar=gienah 
    if istar==63: mystar=mimosa 
    if istar==64: mystar=alioth 
    if istar==65: mystar=vindemiatrix 
    if istar==66: mystar=mizar 
    if istar==67: mystar=alcor 
    if istar==68: mystar=alcaid
    if istar==69: mystar=agena
    if istar==70: mystar=thuban
    if istar==71: mystar=izar
    if istar==72: mystar=kochab
    if istar==73: mystar=alphecca
    if istar==74: mystar=unukalhai
    if istar==75: mystar=rasalgethi
    if istar==76: mystar=cebalrai
    if istar==77: mystar=etamin
    if istar==78: mystar=kaus_australis
    if istar==79: mystar=sheliak
    if istar==80: mystar=nunki
    if istar==81: mystar=sulafat
    if istar==82: mystar=arkab_prior
    if istar==83: mystar=arkab_posterior
    if istar==84: mystar=rukbat
    if istar==85: mystar=albereo
    if istar==86: mystar=tarazed
    if istar==87: mystar=alshain
    if istar==88: mystar=sadr
    if istar==89: mystar=peacock
    if istar==90: mystar=alderamin
    if istar==91: mystar=alfirk
    if istar==92: mystar=enif
    if istar==93: mystar=sadalmelik
    if istar==94: mystar=scheat
    if istar==95: mystar=markab
    if istar==96: mystar=SN1006
    if istar==97: mystar=SN1054

    myname = str(mystar.name)
    if (istar==18): myname='Pleiades'
    lgood=0
    adate = str(year)+'/6/21'
    a = ephem.date(adate)
    mystar.compute(a,epoch=str(year))
    #print 'istar is '+str(istar)+' '+myname
    if istar!=1:
     if istar!=18:
       if istar<96:
        mag = float(mystar.mag)
       b=1
     b=1
    b=1
    if (istar==1): mag=0.5    # hyades
    if (istar==18): mag=1.6   # pleiades
    if (istar==96): mag= -7.5 # SN1006
    if (istar==97): mag= -6   # SN1054
    #print str(mag)
    
    ########################################################
    ########################################################
    f.write(str(year)+','+myname+","+str((180/pi)*float(mystar.a_ra))+','+str((180.0/pi)*float(mystar.a_dec))+","+str(float(mystar._pmra))+","+str(float(mystar._pmdec))+","+str(mag)+'\n')
  b=1
 b=1 
f.close()
b=1


import ephem
latitude = 14.797424; longitude = 121.057481

import ephem
latitude = 14.797424; longitude = 121.057481
gatech = ephem.Observer()
gatech.long, gatech.lat = latitude, longitude
gatech.date = '2017/14/10 07:00:00'   # 12:22:56 EDT
sun, moon = ephem.Sun(), ephem.Moon()
sun.compute(gatech), moon.compute(gatech)
print sun.alt, sun.az
print moon.alt, moon.az


import datetime
from astral import Astral
city_name = 'London'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
print('Information for %s/%s\n' % (city_name, city.region))

import datetime
from astral import Astral
city_name = 'London'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
timezone = city.timezone
print('Timezone: %s' % timezone)

import datetime
from astral import Astral
city_name = 'London'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
timezone = city.timezone
print('Latitude: %.02f; Longitude: %.02f\n' % \
     (city.latitude, city.longitude))

import datetime
from astral import Astral
city_name = 'Manila'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
timezone = city.timezone
sun = city.sun(date=datetime.date(2017, 10, 14), local=True)
print('Dawn:    %s' % str(sun['dawn']))
print('Sunrise: %s' % str(sun['sunrise']))
print('Noon:    %s' % str(sun['noon']))
print('Sunset:  %s' % str(sun['sunset']))
print('Dusk:    %s' % str(sun['dusk']))

import datetime
from astral import Astral
city_name = 'London'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
timezone = city.timezone
sun = city.sun(date=datetime.date(2009, 4, 22), local=True)
print str(sun['sunrise'])[0:-6]



Current Altitude and Azimith

import ephem
import Here
x,y= Here.here()
#latitude = 14.797424; longitude = 121.057481
gatech = ephem.Observer()
gatech.long, gatech.lat = x, y
gatech.date = '1984/5/30 06:00:00'   # 12:22:56 EDT
sun, moon = ephem.Sun(), ephem.Moon()
sun.compute(gatech), moon.compute(gatech)
print sun.alt, sun.az
#print moon.alt, moon.az


%%writefile There.py
def there():
    latitude = '14.797424'
    longitude = '121.057481'
    location = (latitude,longitude)
    return location

import Here
Lt = Here.here()[0]
Lo = Here.here()[1]
print Lt,Lo

import There
x,y= There.there()
print x,y

import Here
x,y= Here.here()
print x,y

import ephem 
import Here
Lt, Lg= Here.here()
o=ephem.Observer()  
o.lat = Lt  
o.long = Lg
s=ephem.Sun()  
s.compute()  
print ephem.localtime(o.next_rising(s))  

import ephem
observer = ephem.city('Manila')
sun = ephem.Sun()
sun.compute(observer)
print sun.alt, sun.az

from ephem import *
count = 2000
while count <2017:
    date = str(count)
    m = Mars(date)
    print count,": ",(ephem.constellation(m))
    count=count+1


import AstroStore
insert ="""
import Here
x,y= Here.here()
print x,y

import There
x,y= There.there()
print x,y

"""
AstroStore.astrostore(insert)

import AstroRead
AstroRead.astroread()

import datetime
now = datetime.datetime.now()
date = now.strftime("%Y/%m/%d/%H")
print date,"     ", now

import Here
import datetime
now = datetime.datetime.now()
date = now.strftime("%Y/%m/%d/%H")
x , y = Here.here()
print x, y
gatech = ephem.Observer()
gatech.lon = str(x)
gatech.lat = str(y)
gatech.elevation = 2100
gatech.date = date
v = ephem.Sun(gatech)
print('%s %s' % (v.alt, v.az))


14.797424 121.057481
30:47:22.8 343:22:41.2

from ephem import *
m = Mars('1948')
print(constellation(m))

from ephem import *
m = Mars('2017')
print(constellation(m))

latitude = 14.797424; longitude = 121.057481
sitka = ephem.Observer()
sitka.date = '2017/14/10'
sitka.lat = latitude
sitka.lon = longitude
m = ephem.Moon()
print(sitka.next_transit(m))


from ephem import *
latitude = 14.797424; longitude = 121.057481
sitka = ephem.Observer()
sitka.date = '2017/14/10'
sitka.lat = latitude
sitka.lon = longitude
m = ephem.Sun()
print(sitka.next_transit(m))


print('%s %s' % (m.alt, m.az))

import datetime
from astral import Astral
city_name = 'London'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
timezone = city.timezone
sun = city.sun(date=datetime.date(2009, 4, 22), local=True)
print str(sun['sunrise'])[0:-6]


import Here
import datetime
import datetime
from astral import Astral
dt = str(sun['sunrise'])[0:-6]
x , y = Here.here()
print x, y
gatech = ephem.Observer()
gatech.lon = str(x)
gatech.lat = str(y)
gatech.elevation = 2100
gatech.date = dt
v = ephem.Sun(gatech)
print('%s %s' % (v.alt, v.az))


import Here
import datetime
import datetime
from astral import Astral
city_name = 'London'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
timezone = city.timezone
sun = city.sun(date=datetime.date(2009, 4, 22), local=True)
dt = str(sun['sunrise'])[0:-6]
now = datetime.datetime.now()
date = now.strftime("%Y/%m/%d/%H")
x , y = Here.here()
print x, y
gatech = ephem.Observer()
gatech.lon = str(x)
gatech.lat = str(y)
gatech.elevation = 2100
gatech.date = dt
v = ephem.Sun(gatech)
print('%s %s' % (v.alt, v.az))


import datetime
from astral import Astral
city_name = 'London'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
timezone = city.timezone
sun = city.sun(date=datetime.date(2009, 4, 22), local=True)
dt = str(sun['sunrise'])[0:-6]
atech = ephem.Observer()
gatech.lon = '-84.39733'
gatech.lat = '33.775867'
gatech.elevation = 320
gatech.date = dt
s = ephem.Sun(gatech)
print('%s %s' % (s.alt, s.az))


print('%s %s' % (m.alt, m.az))

%%writefile AstroStore.py
def astrostore(insert):
    import sqlite3
    conn = sqlite3.connect('AstroStore.db')
    c = conn.cursor()
    c.execute("""
    CREATE VIRTUAL TABLE IF NOT EXISTS pages 
    USING FTS3(code);
    """
    )
    c = conn.cursor()
    conn.text_factory = str
    # CREATE VIRTUAL TABLE pages USING fts4(code);
    c.execute("INSERT INTO pages VALUES(?)", (insert,))
    conn.commit()
    conn.close()

%%writefile AstroRead.py
def astroread():
    import sqlite3
    conn = sqlite3.connect('AstroStore.db')
    c = conn.cursor()
    count = 0
    req = 100
    view = raw_input("Search : ")
    #for row in c.execute('SELECT rowid, code FROM pages WHERE pages MATCH ?', (view,)):
    for row in c.execute('SELECT rowid, code FROM pages'):        
        count=count+1
        print (row)[0],"-",(row)[1],"\n"
        if count > req:
            conn.close()
            sys.exit()

import numpy as np
from matplotlib import pyplot as plt
from scipy import randn, convolve

#data
t = np.arange(0.0, 20.0, 0.001)
r = np.exp(-t[:1000]/0.05)     
x = randn(len(t))
s = convolve(x,r)[:len(x)]*0.001
theta = 2 * np.pi * t
#
fig = plt.figure(figsize=(7, 6))
#main
plt.plot(t, s)
plt.axis([0, 1, np.amin(s), 2.5*np.amax(s)])
plt.xlabel('xlabel')
plt.ylabel('ylabel')
#polar
ax = fig.add_axes([0.2, 0.47, 0.30, 0.40], polar=True, axisbg='yellow')
ax.plot(theta, t, color='blue', lw=3)
ax.set_rmax(1.0)
plt.grid(True)

plt.show()

import numpy as np
from scipy.interpolate import splev, splrep

equinoxAzi = np.array([90, 180, 270]) 
equinoxAlt = np.array([0, 80, 0]) 
summerAzi = np.array([180-121.5, 180, 180+121.5]) 
summerAlt = np.array([0, 60, 0]) 
winterAzi = np.array([180-58.46, 180, 180+58.46]) 
winterAlt = np.array([0, 40, 0])



equinoxX_new = np.linspace(equinoxX.min(),equinoxX.max(),30)
equinoxY_smooth = splev(equinoxX_new, splrep(equinoxX, equinoxY, k=2))

summerX_new = np.linspace(summerX.min(), summerX.max(),30)
summerY_smooth = splev(summerX_new, splrep(summerX, summerY, k=2))

winterX_new = np.linspace(winterX.min(), winterX.max(),30)
winterY_smooth = splev(winterX_new, splrep(winterX, winterY, k=2))

import matplotlib.pylab as plt
from mpl_toolkits.basemap import Basemap
import numpy as np

winterAzi = np.array([81.67440007, 75.55094006, 67.57616189, 55.73337697])
winterAlt = np.array([11.28088118, 25.0837551, 38.44986883, 50.8769649])

#winterAzi = np.array([func(n,1) for n in range(x,y)])
#winterAlt = np.array([func(n,2) for n in range(x,y)])

#winterAzi = int(winterAzi)
#winterAlt = int(winterAzi)




# create instance of basemap, note we want a south polar projection to 90 = E
myMap = Basemap(projection='spstere',boundinglat=0,lon_0=180,resolution='l',round=True,suppress_ticks=True)
# set the grid up
gridX,gridY = 10.0,15.0
parallelGrid = np.arange(-90.0,90.0,gridX)
meridianGrid = np.arange(-180.0,180.0,gridY)

# draw parallel and meridian grid, not labels are off. We have to manually create these.
myMap.drawparallels(parallelGrid,labels=[False,False,False,False])
myMap.drawmeridians(meridianGrid,labels=[False,False,False,False],labelstyle='+/-',fmt='%i')

# we have to send our values through basemap to convert coordinates, note -winterAlt
winterX,winterY = myMap(winterAzi,-winterAlt)

# plot azimuth labels, with a North label.
ax = plt.gca()
ax.text(0.5,1.025,'N',transform=ax.transAxes,horizontalalignment='center',verticalalignment='bottom',size=25)
for para in np.arange(gridY,360,gridY):
    x= (1.1*0.5*np.sin(np.deg2rad(para)))+0.5
    y= (1.1*0.5*np.cos(np.deg2rad(para)))+0.5
    ax.text(x,y,u'%i\N{DEGREE SIGN}'%para,transform=ax.transAxes,horizontalalignment='center',verticalalignment='center')


# plot the winter values
myMap.plot(winterX,winterY ,'bo')

#savefig('foo.png')
plt.show()

from matplotlib.pyplot import rc, grid, figure, plot, rcParams, savefig
from math import radians
import Here

def generate_satellite_plot(observer_lat, observer_lon):
    rc('grid', color='#84cefd', linewidth=1, linestyle='-')
    rc('xtick', labelsize=15)
    rc('ytick', labelsize=15)
    
    # force square figure and square axes looks better for polar, IMO
    size = 11
    fig = figure(figsize=(size, size))

    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], polar=True, axisbg='#d8f7ff')
    ax.set_theta_zero_location('N')
    ax.set_theta_direction(-1)

    sat_positions = [[1, 30, 0], [2, 60, 90], [3, 30, 180], [4, 50, 270]]
    for (PRN, E, Az) in sat_positions:
        ax.annotate(str(PRN),
                    xy=(radians(Az), 90-E),  # theta, radius
                    bbox=dict(boxstyle="round", fc = 'blue', alpha = 0.25),
                    horizontalalignment='center',
                    verticalalignment='center')


    ax.set_yticks(range(0, 90+10, 10))                   # Define the yticks
    yLabel = ['90', '', '', '60', '', '', '30', '', '', '']
    ax.set_yticklabels(yLabel)
    grid(True)
    #plt.figsize=(10,10)
    savefig('foo.png')
    plt.show()
    
observer_lat, observer_lon = Here.here()   
generate_satellite_plot(observer_lat, observer_lon)    
    

!showme foo.png

https://recalll.co/app/?q=python%20-%20Matplotlib%20inset%20polar%20plot

import matplotlib.pylab as plt
testFig = plt.figure(1, figsize=(8,8))
rect = [0.1,0.1,0.8,0.8]
testAx = testFig.add_axes(rect,polar=True)
testAx.invert_yaxis()
testAx.set_theta_zero_location('N')
testAx.set_theta_direction(-1)

Azi = [90,180,270]
Alt= [0,42,0]
testAx.plot(Azi,Alt)
plt.show()


winterAzi = np.array([81.67440007, 75.55094006, 67.57616189, 55.73337697])
winterAlt = np.array([11.28088118, 25.0837551, 38.44986883, 50.8769649])

#create instance of basemap, note we want a south polar projection to 90 = E
myMap = Basemap(projection='spstere',boundinglat=0,lon_0=180,resolution='l',round=True,suppress_ticks=True)
# set the grid up
gridX,gridY = 10.0,15.0
parallelGrid = np.arange(-90.0,90.0,gridX)
meridianGrid = np.arange(-180.0,180.0,gridY)
testFig = plt.figure(1, figsize=(8,8))
# draw parallel and meridian grid, not labels are off. We have to manually create these.
myMap.drawparallels(parallelGrid,labels=[False,False,False,False])
myMap.drawmeridians(meridianGrid,labels=[False,False,False,False],labelstyle='+/-',fmt='%i')

# we have to send our values through basemap to convert coordinates, note -winterAlt
winterX,winterY = myMap(winterAzi,-winterAlt)

# plot azimuth labels, with a North label.
ax = plt.gca()
ax.text(0.5,1.025,'N',transform=ax.transAxes,horizontalalignment='center',verticalalignment='bottom',size=25)
for para in np.arange(gridY,360,gridY):
    x= (1.1*0.5*np.sin(np.deg2rad(para)))+0.5
    y= (1.1*0.5*np.cos(np.deg2rad(para)))+0.5
    ax.text(x,y,u'%i\N{DEGREE SIGN}'%para,transform=ax.transAxes,horizontalalignment='center',verticalalignment='center')


# plot the winter values
myMap.plot(winterX,winterY ,'bo')


plt.show()

import matplotlib.pylab as plt
from mpl_toolkits.basemap import Basemap
import numpy as np

winterAzi = np.array([81.67440007, 75.55094006, 67.57616189, 55.73337697])
winterAlt = np.array([11.28088118, 25.0837551, 38.44986883, 50.8769649])

# create instance of basemap, note we want a south polar projection to 90 = E
myMap = Basemap(projection='spstere',boundinglat=0,lon_0=180,resolution='l',round=True,suppress_ticks=True)
# set the grid up
gridX,gridY = 10.0,15.0
parallelGrid = np.arange(-90.0,90.0,gridX)
meridianGrid = np.arange(-180.0,180.0,gridY)

# draw parallel and meridian grid, not labels are off. We have to manually create these.
myMap.drawparallels(parallelGrid,labels=[False,False,False,False])
myMap.drawmeridians(meridianGrid,labels=[False,False,False,False],labelstyle='+/-',fmt='%i')

# we have to send our values through basemap to convert coordinates, note -winterAlt
winterX,winterY = myMap(winterAzi,-winterAlt)

# plot azimuth labels, with a North label.
ax = plt.gca()
ax.text(0.5,1.025,'N',transform=ax.transAxes,horizontalalignment='center',verticalalignment='bottom',size=25)
for para in np.arange(gridY,360,gridY):
    x= (1.1*0.5*np.sin(np.deg2rad(para)))+0.5
    y= (1.1*0.5*np.cos(np.deg2rad(para)))+0.5
    ax.text(x,y,u'%i\N{DEGREE SIGN}'%para,transform=ax.transAxes,horizontalalignment='center',verticalalignment='center')


# plot the winter values
myMap.plot(winterX,winterY ,'bo')

plt.show()

Azimuth Lines - Azimuth angles run around the edge of the diagram.
Altitude Lines - Altitude angles are represented a

https://sustainabilityworkshop.autodesk.com/buildings/reading-sun-path-diagrams

import matplotlib.pylab as plt
from mpl_toolkits.basemap import Basemap
import numpy as np
from scipy.interpolate import spline

equinoxAzi = np.array([90, 180, 270])
equinoxAlt = np.array([0, 38.7, 0])
summerAzi = np.array([45, 180, 315])
summerAlt = np.array([0, 62.1, 0])
winterAzi = np.array([135, 180, 225])
winterAlt = np.array([0, 16, 0])


# create instance of basemap, note we want a south polar projection to 90 = E
myMap = Basemap(projection='spstere',boundinglat=0,lon_0=180,resolution='l',round=True,suppress_ticks=True)
# set the grid up
gridX,gridY = 10.0,15.0
parallelGrid = np.arange(-90.0,90.0,gridX)
meridianGrid = np.arange(-180.0,180.0,gridY)

# draw parallel and meridian grid, not labels are off. We have to manually create these.
myMap.drawparallels(parallelGrid,labels=[False,False,False,False])
myMap.drawmeridians(meridianGrid,labels=[False,False,False,False],labelstyle='+/-',fmt='%i')

# we have to send our values through basemap to convert coordinates, note -winterAlt
equinoxX, equinoxY = myMap(equinoxAzi, -equinoxAlt)
summerX, summerY = myMap(summerAzi, -summerAlt)
winterX, winterY = myMap(winterAzi, -winterAlt)


# plot azimuth labels, with a North label.
ax = plt.gca()
ax.text(0.5,1.025,'N',transform=ax.transAxes,horizontalalignment='center',verticalalignment='bottom',size=25)
for para in np.arange(gridY,360,gridY):
    x= (1.1*0.5*np.sin(np.deg2rad(para)))+0.5
    y= (1.1*0.5*np.cos(np.deg2rad(para)))+0.5
    ax.text(x,y,u'%i\N{DEGREE SIGN}'%para,transform=ax.transAxes,horizontalalignment='center',verticalalignment='center')

equinoxX_new = np.linspace(equinoxX.min(),equinoxY.max(),30)
equinoxY_smooth = spline(equinoxX, equinoxY, equinoxX_new)

summerX_new = np.linspace(summerX.min(), summerX.max(),30)
summerY_smooth = spline(summerX, summerY, summerX_new)

winterX_new = np.linspace(winterX.min(), winterX.max(),30)
winterY_smooth = spline(winterX, winterY, winterX_new)

myMap.plot(equinoxX_new, equinoxY_smooth, 'b')
myMap.plot(summerX_new, summerY_smooth, 'g')
myMap.plot(winterX_new, winterY_smooth/2, 'r')

myMap.plot(equinoxX, equinoxY, 'bo')
myMap.plot(summerX, summerY, 'go')
myMap.plot(winterX, winterY, 'ro')

plt.show()

# Working VIA Command line

import Here
x,y = Here.here()
print x, y

%%writefile analemma.py
#! /usr/bin/env python

# Display an analemma for a specified location and time.
# Copyright 2011 by Akkana Peck: share and enjoy under the GPL v2 or later.
import ephem
import sys
sys.path.insert(0, "/usr/lib/python2.7/dist-packages/gtk-2.0/")
import gtk
sys.path.insert(0, "/usr/lib/python2.7/dist-packages")
import gobject
import os
import math
import Here
class AnalemmaWindow:
    def __init__(self, observer, year):
        self.observer = observer
        self.year = year

        self.special_dates = None
        self.drawing_area = None
        self.xgc = None
        self.bgc = None
        self.specialgc = None
        self.width = 0
        self.height = 0
        self.sun = ephem.Sun()
        self.sinusoidal = False

    def draw_sun_position(self, date):
        if not self.drawing_area:
            print "no drawing area"
            return
        if not self.xgc:
            print "no GC"
            return
        self.observer.date = self.local_to_gmt(date, reverse=True)

        self.sun.compute(self.observer)

        # Y scale is 90 degrees (PI/2), horizon to zenith:
        # y = self.height - int(float(self.sun.alt) * self.height / math.pi * 2)

        # So make X scale 90 degrees too, centered around due south.
        # Want az = PI to come out at x = width/2,
        # az = PI/2 to be 0, 3*PI/2 = width.
        # x = int(float(self.sun.az) * self.width / math.pi * 2 - self.width / 2) % self.width

        self.project_and_draw(self.sun.az, self.sun.alt, 4)

    def calc_special_dates(self):
        '''Earlist and latest rising and setting times,
           and longest/shortest day.
        '''
        if self.special_dates:
            # Already done, nothing more to do.
            return

        self.special_dates = {
            'earliest sunrise': 24,
            'latest sunrise'  :  0,
            'earliest sunset' : 24,
            'latest sunset'   :  0,
            'longest day len' :  0,
            'shortest day len': 24
        }

        # Start just after midnight on New Year's Day.
        dt = self.local_to_gmt('%d/01/01 00:00:01' % (self.year))
        while (dt.tuple()[0] == self.year):
            self.observer.date = dt
            risetime = self.observer.next_rising(ephem.Sun())
            self.observer.date = risetime
            settime = self.observer.next_setting(ephem.Sun())
            self.observer.date = settime

            # Now we're done setting observer time, so it's safe to
            # convert to localtime.
            risetime = self.local_mean_time(risetime)
            settime = self.local_mean_time(settime)
            risehours = self.ephemdate_to_hours(risetime)
            sethours = self.ephemdate_to_hours(settime)

            if risehours < self.ephemdate_to_hours(self.special_dates['earliest sunrise']):
                self.special_dates['earliest sunrise'] = risetime
            if risehours > self.ephemdate_to_hours(self.special_dates['latest sunrise']):
                self.special_dates['latest sunrise'] = risetime
            if sethours < self.ephemdate_to_hours(self.special_dates['earliest sunset']):
                self.special_dates['earliest sunset'] = settime
            if sethours > self.ephemdate_to_hours(self.special_dates['latest sunset']):
                self.special_dates['latest sunset'] = settime

            # calculate daylength in hours
            daylength = (settime - risetime) * 24.
            if daylength < self.special_dates['shortest day len']:
                self.special_dates['shortest day'] = risetime
                self.special_dates['shortest day len'] = daylength
            if daylength > self.special_dates['longest day len']:
                self.special_dates['longest day'] = risetime
                self.special_dates['longest day len'] = daylength

            dt = ephem.date(dt + ephem.hour * 24)

    def gmt_for_time_on_date(self, edate, timetuple):
        '''Returns the ephem.date for the GMT corresponding to localtime
           timetuple on the given ephem.date.
        '''
        tup = list(edate.tuple())
        tup[3], tup[4], tup[5] = timetuple
        return self.local_to_gmt(ephem.date(tuple(tup)), reverse=True)

    def draw_special_dates(self, timestr):
        # Make a tuple out from timestr
        if ':' in timestr:
            timetuple = map(int, timestr.split(':'))
            while len(timetuple) < 3:
                timetuple.append(0)
        else:
            timetuple = (int(timestr), 0, 0)

        for key in self.special_dates:
            d = self.special_dates[key]
            if not isinstance(d, ephem.date):
                continue

            gmt = self.gmt_for_time_on_date(d, timetuple)
            self.observer.date = self.gmt_for_time_on_date(d, timetuple)
            self.sun.compute(self.observer)
            x, y = self.project(self.sun.az, self.sun.alt)
            self.draw_dot(self.specialgc, x, y, 7)

            # Offsets to figure out where to draw the string.
            # That's tough, because they're normally on top of each other.
            # Latest sunrise is a little left of earliest sunset,
            # and shortest day is in between and a little below both.
            offsets = { "latest sunrise"   : (-1,  0),
                        "earliest sunset"  : ( 1,  0),
                        "shortest day"     : ( 0,  1),
                        "latest sunset"    : (-1,  0),
                        "earliest sunrise" : ( 1,  0),
                        "longest day"      : ( 0, -1)
            }
            factor = 30
            xoffset = int(offsets[key][0] * factor)
            yoffset = int(offsets[key][1] * factor)
            self.drawing_area.window.draw_line(self.specialgc, x, y,
                                               x + xoffset, y + yoffset)
            s = str(self.special_dates[key])
            if key + " len" in self.special_dates:
                # for longest/shortest days, split off the time part
                s = s.split(' ')[0]
                # and then add the day length
                s += ", %.1f hrs" % self.special_dates[key + " len"]
            self.draw_string(key + "\n" + s,
                             x + xoffset, y + yoffset, self.specialgc,
                             offsets=offsets[key])

        # Draw the equinoxes too. Solstices are too crowded what with
        # all the other special dates.

        def draw_equinox(start, whicheq, offsets):
            equinox = ephem.next_equinox(start)
            self.observer.date = self.gmt_for_time_on_date(equinox, (12, 0, 0))
            self.sun.compute(self.observer)
            x, y = self.project(self.sun.az, self.sun.alt)
            self.draw_dot(self.specialgc, x, y, 7)
            x1 = x + offsets[0] * 20
            self.drawing_area.window.draw_line(self.specialgc, x, y, x1, y)
            eqstr = "%s equinox\n%s" % (whicheq, str(equinox).split(' ')[0])
            self.draw_string(eqstr, x1, y, self.specialgc, offsets)

        draw_equinox("%d/1/1" % self.year, "Vernal", (-1, 0))
        draw_equinox(observer.date, "Autumnal", (1, 0))

    def special_dates_str(self):
        if not self.special_dates:
            self.calc_special_dates()
        s = '''
Longest day: %d hours on %s
Shortest day: %d hours on %s
Earliest sunrise: %s
Latest sunrise: %s
Earliest sunset: %s
Latest sunset: %s
''' %      (self.special_dates["longest day len"],
            str(self.special_dates["longest day"]),
            self.special_dates["shortest day len"],
            str(self.special_dates["shortest day"]),
            str(self.special_dates["earliest sunrise"]),
            str(self.special_dates["latest sunrise"]),
            str(self.special_dates["earliest sunset"]),
            str(self.special_dates["latest sunset"]))
        return s

    def local_mean_time(self, d, reverse=False):
        '''Adjust GMT to local time.
           We don't know time zone, but we can adjust for actual
           local noon since we know the Observer's longitude:
        '''
        return ephem.date(ephem.date(d) \
                    + float(self.observer.lon) * 12 / math.pi * ephem.hour)

    def local_to_gmt(self, d, reverse=False):
        '''Adjust GMT to local time.
           We don't know time zone, but we can adjust for actual
           local noon since we know the Observer's longitude:
        '''
        return ephem.date(ephem.date(d) \
                    - float(self.observer.lon) * 12 / math.pi * ephem.hour)

    def ephemdate_to_hours(self, edate):
        if isinstance(edate, int):
            return edate
        etuple = edate.tuple()
        return etuple[3] + etuple[4]/60. + etuple[5]/3600.

    def draw_dot(self, gc, x, y, dotsize):
        # Draw the dot centered, not hanging off to the lower right:
        x = int(x - dotsize / 2)
        y = int(y - dotsize / 2)

        if dotsize == 1:
            self.drawing_area.window.draw_points(gc, [(x, y)])
        elif dotsize <= 4:
            self.drawing_area.window.draw_rectangle(gc, True, x, y,
                                                    dotsize, dotsize)
        else:
            self.drawing_area.window.draw_arc(gc, True, x, y,
                                              dotsize, dotsize, 0, 23040)

    def draw_string(self, label, x, y, gc=None, offsets=None):
        '''Draw a string at the specified point.
           offsets is an optional tuple specifying where the string will
           be drawn relative to the coordinates passed in;
           for instance, if offsets are (-1, -1) the string will be
           drawn with the bottom right edge at the given x, y.
        '''
        layout = self.drawing_area.create_pango_layout(label)
        # layout.set_font_description(self.font_desc)
        if not gc:
            gc = self.xgc
        if offsets:
            # pango draws text with the upper left corner at x, y.
            # So that's an offset of (1, 1). Adjust if offsets are different.
            width, height = layout.get_pixel_size()
            if offsets[0] == 0:
                x -= int(width/2)
            elif offsets[0] != 1:
                x += int(width * offsets[0])
            if offsets[1] != 1:
                y += int(height * offsets[1] - height/2)
        self.drawing_area.window.draw_layout(gc, x, y, layout)

    def project_rectangular(self, az, alt):
        """Rectangular -- don't do any projection, just scaling"""

        y = int((math.pi/2 - alt) * (self.height * 2 / math.pi))
        x = int(az * self.width / math.pi - self.width/2)

        return (x, y)

    def project_sinusoidal(self, lon, lat):
        """Return a sinusoidal projection as (x, y)"""
        # XXX Actually this is bogus, it's not being used right for alt/az.

        # Sinusoidal projection
        y = int((math.pi/2 - lat) * self.height * 2 / math.pi)

        if lat > 90:
            print "lat is", lat
            return (0, 0)

        if lon < math.pi/2:
            gc = self.bgc
            lon = math.pi - lon
        elif lon > 3*math.pi/2:
            gc = self.bgc
            lon = 3 * math.pi - lon
        else:
            gc = self.xgc

        x = int(((lon - math.pi) * math.cos(lat) * self.width / math.pi)
                 + self.width/2)

        if dotsize > 0:
            self.draw_dot(gc, x, y, dotsize)

        #print int(lon*180/math.pi), int(lat*180/math.pi), x, y

        return (x, y)

    def project_and_draw(self, az, alt, dotsize):
        if az < math.pi/2:
            gc = self.bgc
            az = math.pi - az
        elif az > 3*math.pi/2:
            gc = self.bgc
            az = 3 * math.pi - az
        else:
            gc = self.xgc

        x, y = self.project(az, alt)

        if dotsize > 0:
            self.draw_dot(gc, x, y, dotsize)

    def project(self, az, alt):
        if self.sinusoidal:
            return self.project_sinusoidal(az, alt)
        else:
            return self.project_rectangular(az, alt)

    def expose_handler(self, widget, event):
        # print "Expose"
        if not self.xgc:
            self.xgc = widget.window.new_gc()
            self.bgc = widget.window.new_gc()
            self.specialgc = widget.window.new_gc()
        self.width, self.height = self.drawing_area.window.get_size()

        # Draw a blue background. But if we're using a sinusoidal
        # projection, then only color the projected part blue.
        self.xgc.set_rgb_fg_color(gtk.gdk.Color(0, 0, 65535))
        if self.sinusoidal:
        # the "backside" GC will have a different color
            self.bgc.set_rgb_fg_color(gtk.gdk.Color(0, 0, 0))
            self.drawing_area.window.draw_rectangle(self.bgc, True, 0, 0,
                                                    self.width, self.height)
            for f in range(0, int(math.pi * 100)):
                theta = f/200.
                (x, y) = self.project_sinusoidal(math.pi/2, theta, 0)
                #print f, theta, x, y
                self.drawing_area.window.draw_rectangle(self.xgc, True,
                                                        x, y,
                                                        self.width - 2*x, 4)
        else:
            self.drawing_area.window.draw_rectangle(self.xgc, True, 0, 0,
                                                    self.width, self.height)

        # "Special" gc to be used for showing special dates
        self.specialgc.set_rgb_fg_color(gtk.gdk.Color(65535, 65535, 65535))

        # Draw some projected grid lines
        #self.xgc.set_rgb_fg_color(gtk.gdk.Color(16384, 16384, 16384))
        self.xgc.set_rgb_fg_color(gtk.gdk.Color(65535, 65535, 65535))
        for f in range(0, int(math.pi * 100), 5):
            theta = f/200.   # i is going from 0 to pi/2
            # Draw the equator: (doesn't actually show up)
            # self.project_and_draw(theta + math.pi/2, 0., 1)
            # self.project_and_draw(theta + math.pi, 0., 1)

            # Central meridian (180 dgrees)
            self.project_and_draw(math.pi, theta, 1)

            # and a few other lines
            # self.project_and_draw(math.pi * .75, theta, 1)
            # self.project_and_draw(math.pi*1.25, theta, 1)

        # Then prepare to draw the sun in yellow:
        self.xgc.set_rgb_fg_color(gtk.gdk.Color(65535, 65535, 0))

        # the "backside" GC will have a different color
        self.bgc.set_rgb_fg_color(gtk.gdk.Color(65535, 32767, 0))

        # Calculate earliest sunrise and suchlike.
        self.calc_special_dates()

        # Draw three analemmas, showing the sun positions at 7:40 am,
        # noon, and 4:40 pm ... in each case adjusted for mean solar time,
        # i.e. the observer's position within their timezone.
        for time in [ '8:00', '12:00', '16:00' ]:
            for m in range(1, 13):
                self.draw_sun_position('%d/%d/1 %s' % (self.year, m, time))
                self.draw_sun_position('%d/%d/10 %s' % (self.year, m, time))
                self.draw_sun_position('%d/%d/20 %s' % (self.year, m, time))

        # Mark special dates for mean solar noon.
        self.draw_special_dates("12:00")

        # Make a label
        if observer.name == "custom":
            obslabel = "Observer at %.1f N, %.1f E" % (observer.lat,
                                                       observer.lon)
        else:
            obslabel = "Observer in " + self.observer.name
        self.draw_string(obslabel, 10, 10)

    def show_window(self):
        win = gtk.Window()
        self.drawing_area = gtk.DrawingArea()
        self.drawing_area.connect("expose-event", self.expose_handler)
        win.add(self.drawing_area)
        self.drawing_area.show()
        win.connect("destroy", gtk.main_quit)
        win.set_default_size(1025, 512)
        win.show()
        gtk.main()

if __name__ == "__main__":
    def Usage():
        progname = os.path.basename(sys.argv[0])
        print """Usage: %s [cityname]
       %s [lat lon]""" % (progname, progname)
        sys.exit(0)
    if len(sys.argv) == 2:
        if sys.argv[1] == "-h" or sys.argv[1] == "--help":
            Usage()
        observer = ephem.city(sys.argv[1])
    elif len(sys.argv) == 3:
        observer = ephem.Observer()
        #observer.name = "Gaya Gaya, Philippines"
        #observer.lon = sys.argv[1]
        #observer.lat = sys.argv[2]
        #x, y = Here.here()
        #observer.lon = y
        #observer.lat = x 
        observer.name = "San Jose"
        observer.lon = '-121:56.8'
        observer.lat = '37:15.55'        
    else:
        # default to San Jose
        # pyephem doesn't know ephem.city('San Jose')
        # Houge Park is -121^56.53' 37^15.38'
        observer = ephem.Observer()
        observer.name = "San Jose"
        #observer.lon = '-121:56.8'
        #observer.lat = '37:15.55'
        #observer.name = "Gaya Gaya, Philippines"
        #observer.lon = sys.argv[1]
        #observer.lat = sys.argv[2]
        #x, y = Here.here()
        observer.lon = "121.057481"
        observer.lat = "14.797424"         
        
        observer.elevation = 100

    awin = AnalemmaWindow(observer, ephem.now().triple()[0])
    print awin.special_dates_str(),x,y
    awin.show_window()

%%writefile analemma.py
#! /usr/bin/env python

# Display an analemma for a specified location and time.
# Copyright 2011 by Akkana Peck: share and enjoy under the GPL v2 or later.
import ephem
import sys
sys.path.insert(0, "/usr/lib/python2.7/dist-packages/gtk-2.0/")
import gtk
sys.path.insert(0, "/usr/lib/python2.7/dist-packages")
import gobject
import os
import math
import Here
class AnalemmaWindow:
    def __init__(self, observer, year):
        self.observer = observer
        self.year = year

        self.special_dates = None
        self.drawing_area = None
        self.xgc = None
        self.bgc = None
        self.specialgc = None
        self.width = 0
        self.height = 0
        self.sun = ephem.Sun()
        self.sinusoidal = False

    def draw_sun_position(self, date):
        if not self.drawing_area:
            print "no drawing area"
            return
        if not self.xgc:
            print "no GC"
            return
        self.observer.date = self.local_to_gmt(date, reverse=True)

        self.sun.compute(self.observer)

        # Y scale is 90 degrees (PI/2), horizon to zenith:
        # y = self.height - int(float(self.sun.alt) * self.height / math.pi * 2)

        # So make X scale 90 degrees too, centered around due south.
        # Want az = PI to come out at x = width/2,
        # az = PI/2 to be 0, 3*PI/2 = width.
        # x = int(float(self.sun.az) * self.width / math.pi * 2 - self.width / 2) % self.width

        self.project_and_draw(self.sun.az, self.sun.alt, 4)

    def calc_special_dates(self):
        '''Earlist and latest rising and setting times,
           and longest/shortest day.
        '''
        if self.special_dates:
            # Already done, nothing more to do.
            return

        self.special_dates = {
            'earliest sunrise': 24,
            'latest sunrise'  :  0,
            'earliest sunset' : 24,
            'latest sunset'   :  0,
            'longest day len' :  0,
            'shortest day len': 24
        }

        # Start just after midnight on New Year's Day.
        dt = self.local_to_gmt('%d/01/01 00:00:01' % (self.year))
        while (dt.tuple()[0] == self.year):
            self.observer.date = dt
            risetime = self.observer.next_rising(ephem.Sun())
            self.observer.date = risetime
            settime = self.observer.next_setting(ephem.Sun())
            self.observer.date = settime

            # Now we're done setting observer time, so it's safe to
            # convert to localtime.
            risetime = self.local_mean_time(risetime)
            settime = self.local_mean_time(settime)
            risehours = self.ephemdate_to_hours(risetime)
            sethours = self.ephemdate_to_hours(settime)

            if risehours < self.ephemdate_to_hours(self.special_dates['earliest sunrise']):
                self.special_dates['earliest sunrise'] = risetime
            if risehours > self.ephemdate_to_hours(self.special_dates['latest sunrise']):
                self.special_dates['latest sunrise'] = risetime
            if sethours < self.ephemdate_to_hours(self.special_dates['earliest sunset']):
                self.special_dates['earliest sunset'] = settime
            if sethours > self.ephemdate_to_hours(self.special_dates['latest sunset']):
                self.special_dates['latest sunset'] = settime

            # calculate daylength in hours
            daylength = (settime - risetime) * 24.
            if daylength < self.special_dates['shortest day len']:
                self.special_dates['shortest day'] = risetime
                self.special_dates['shortest day len'] = daylength
            if daylength > self.special_dates['longest day len']:
                self.special_dates['longest day'] = risetime
                self.special_dates['longest day len'] = daylength

            dt = ephem.date(dt + ephem.hour * 24)

    def gmt_for_time_on_date(self, edate, timetuple):
        '''Returns the ephem.date for the GMT corresponding to localtime
           timetuple on the given ephem.date.
        '''
        tup = list(edate.tuple())
        tup[3], tup[4], tup[5] = timetuple
        return self.local_to_gmt(ephem.date(tuple(tup)), reverse=True)

    def draw_special_dates(self, timestr):
        # Make a tuple out from timestr
        if ':' in timestr:
            timetuple = map(int, timestr.split(':'))
            while len(timetuple) < 3:
                timetuple.append(0)
        else:
            timetuple = (int(timestr), 0, 0)

        for key in self.special_dates:
            d = self.special_dates[key]
            if not isinstance(d, ephem.date):
                continue

            gmt = self.gmt_for_time_on_date(d, timetuple)
            self.observer.date = self.gmt_for_time_on_date(d, timetuple)
            self.sun.compute(self.observer)
            x, y = self.project(self.sun.az, self.sun.alt)
            self.draw_dot(self.specialgc, x, y, 7)

            # Offsets to figure out where to draw the string.
            # That's tough, because they're normally on top of each other.
            # Latest sunrise is a little left of earliest sunset,
            # and shortest day is in between and a little below both.
            offsets = { "latest sunrise"   : (-1,  0),
                        "earliest sunset"  : ( 1,  0),
                        "shortest day"     : ( 0,  1),
                        "latest sunset"    : (-1,  0),
                        "earliest sunrise" : ( 1,  0),
                        "longest day"      : ( 0, -1)
            }
            factor = 30
            xoffset = int(offsets[key][0] * factor)
            yoffset = int(offsets[key][1] * factor)
            self.drawing_area.window.draw_line(self.specialgc, x, y,
                                               x + xoffset, y + yoffset)
            s = str(self.special_dates[key])
            if key + " len" in self.special_dates:
                # for longest/shortest days, split off the time part
                s = s.split(' ')[0]
                # and then add the day length
                s += ", %.1f hrs" % self.special_dates[key + " len"]
            self.draw_string(key + "\n" + s,
                             x + xoffset, y + yoffset, self.specialgc,
                             offsets=offsets[key])

        # Draw the equinoxes too. Solstices are too crowded what with
        # all the other special dates.

        def draw_equinox(start, whicheq, offsets):
            equinox = ephem.next_equinox(start)
            self.observer.date = self.gmt_for_time_on_date(equinox, (12, 0, 0))
            self.sun.compute(self.observer)
            x, y = self.project(self.sun.az, self.sun.alt)
            self.draw_dot(self.specialgc, x, y, 7)
            x1 = x + offsets[0] * 20
            self.drawing_area.window.draw_line(self.specialgc, x, y, x1, y)
            eqstr = "%s equinox\n%s" % (whicheq, str(equinox).split(' ')[0])
            self.draw_string(eqstr, x1, y, self.specialgc, offsets)

        draw_equinox("%d/1/1" % self.year, "Vernal", (-1, 0))
        draw_equinox(observer.date, "Autumnal", (1, 0))

    def special_dates_str(self):
        if not self.special_dates:
            self.calc_special_dates()
        s = '''
Longest day: %d hours on %s
Shortest day: %d hours on %s
Earliest sunrise: %s
Latest sunrise: %s
Earliest sunset: %s
Latest sunset: %s
''' %      (self.special_dates["longest day len"],
            str(self.special_dates["longest day"]),
            self.special_dates["shortest day len"],
            str(self.special_dates["shortest day"]),
            str(self.special_dates["earliest sunrise"]),
            str(self.special_dates["latest sunrise"]),
            str(self.special_dates["earliest sunset"]),
            str(self.special_dates["latest sunset"]))
        return s

    def local_mean_time(self, d, reverse=False):
        '''Adjust GMT to local time.
           We don't know time zone, but we can adjust for actual
           local noon since we know the Observer's longitude:
        '''
        return ephem.date(ephem.date(d) \
                    + float(self.observer.lon) * 12 / math.pi * ephem.hour)

    def local_to_gmt(self, d, reverse=False):
        '''Adjust GMT to local time.
           We don't know time zone, but we can adjust for actual
           local noon since we know the Observer's longitude:
        '''
        return ephem.date(ephem.date(d) \
                    - float(self.observer.lon) * 12 / math.pi * ephem.hour)

    def ephemdate_to_hours(self, edate):
        if isinstance(edate, int):
            return edate
        etuple = edate.tuple()
        return etuple[3] + etuple[4]/60. + etuple[5]/3600.

    def draw_dot(self, gc, x, y, dotsize):
        # Draw the dot centered, not hanging off to the lower right:
        x = int(x - dotsize / 2)
        y = int(y - dotsize / 2)

        if dotsize == 1:
            self.drawing_area.window.draw_points(gc, [(x, y)])
        elif dotsize <= 4:
            self.drawing_area.window.draw_rectangle(gc, True, x, y,
                                                    dotsize, dotsize)
        else:
            self.drawing_area.window.draw_arc(gc, True, x, y,
                                              dotsize, dotsize, 0, 23040)

    def draw_string(self, label, x, y, gc=None, offsets=None):
        '''Draw a string at the specified point.
           offsets is an optional tuple specifying where the string will
           be drawn relative to the coordinates passed in;
           for instance, if offsets are (-1, -1) the string will be
           drawn with the bottom right edge at the given x, y.
        '''
        layout = self.drawing_area.create_pango_layout(label)
        # layout.set_font_description(self.font_desc)
        if not gc:
            gc = self.xgc
        if offsets:
            # pango draws text with the upper left corner at x, y.
            # So that's an offset of (1, 1). Adjust if offsets are different.
            width, height = layout.get_pixel_size()
            if offsets[0] == 0:
                x -= int(width/2)
            elif offsets[0] != 1:
                x += int(width * offsets[0])
            if offsets[1] != 1:
                y += int(height * offsets[1] - height/2)
        self.drawing_area.window.draw_layout(gc, x, y, layout)

    def project_rectangular(self, az, alt):
        """Rectangular -- don't do any projection, just scaling"""

        y = int((math.pi/2 - alt) * (self.height * 2 / math.pi))
        x = int(az * self.width / math.pi - self.width/2)

        return (x, y)

    def project_sinusoidal(self, lon, lat):
        """Return a sinusoidal projection as (x, y)"""
        # XXX Actually this is bogus, it's not being used right for alt/az.

        # Sinusoidal projection
        y = int((math.pi/2 - lat) * self.height * 2 / math.pi)

        if lat > 90:
            print "lat is", lat
            return (0, 0)

        if lon < math.pi/2:
            gc = self.bgc
            lon = math.pi - lon
        elif lon > 3*math.pi/2:
            gc = self.bgc
            lon = 3 * math.pi - lon
        else:
            gc = self.xgc

        x = int(((lon - math.pi) * math.cos(lat) * self.width / math.pi)
                 + self.width/2)

        if dotsize > 0:
            self.draw_dot(gc, x, y, dotsize)

        #print int(lon*180/math.pi), int(lat*180/math.pi), x, y

        return (x, y)

    def project_and_draw(self, az, alt, dotsize):
        if az < math.pi/2:
            gc = self.bgc
            az = math.pi - az
        elif az > 3*math.pi/2:
            gc = self.bgc
            az = 3 * math.pi - az
        else:
            gc = self.xgc

        x, y = self.project(az, alt)

        if dotsize > 0:
            self.draw_dot(gc, x, y, dotsize)

    def project(self, az, alt):
        if self.sinusoidal:
            return self.project_sinusoidal(az, alt)
        else:
            return self.project_rectangular(az, alt)

    def expose_handler(self, widget, event):
        # print "Expose"
        if not self.xgc:
            self.xgc = widget.window.new_gc()
            self.bgc = widget.window.new_gc()
            self.specialgc = widget.window.new_gc()
        self.width, self.height = self.drawing_area.window.get_size()

        # Draw a blue background. But if we're using a sinusoidal
        # projection, then only color the projected part blue.
        self.xgc.set_rgb_fg_color(gtk.gdk.Color(0, 0, 65535))
        if self.sinusoidal:
        # the "backside" GC will have a different color
            self.bgc.set_rgb_fg_color(gtk.gdk.Color(0, 0, 0))
            self.drawing_area.window.draw_rectangle(self.bgc, True, 0, 0,
                                                    self.width, self.height)
            for f in range(0, int(math.pi * 100)):
                theta = f/200.
                (x, y) = self.project_sinusoidal(math.pi/2, theta, 0)
                #print f, theta, x, y
                self.drawing_area.window.draw_rectangle(self.xgc, True,
                                                        x, y,
                                                        self.width - 2*x, 4)
        else:
            self.drawing_area.window.draw_rectangle(self.xgc, True, 0, 0,
                                                    self.width, self.height)

        # "Special" gc to be used for showing special dates
        self.specialgc.set_rgb_fg_color(gtk.gdk.Color(65535, 65535, 65535))

        # Draw some projected grid lines
        #self.xgc.set_rgb_fg_color(gtk.gdk.Color(16384, 16384, 16384))
        self.xgc.set_rgb_fg_color(gtk.gdk.Color(65535, 65535, 65535))
        for f in range(0, int(math.pi * 100), 5):
            theta = f/200.   # i is going from 0 to pi/2
            # Draw the equator: (doesn't actually show up)
            # self.project_and_draw(theta + math.pi/2, 0., 1)
            # self.project_and_draw(theta + math.pi, 0., 1)

            # Central meridian (180 dgrees)
            self.project_and_draw(math.pi, theta, 1)

            # and a few other lines
            # self.project_and_draw(math.pi * .75, theta, 1)
            # self.project_and_draw(math.pi*1.25, theta, 1)

        # Then prepare to draw the sun in yellow:
        self.xgc.set_rgb_fg_color(gtk.gdk.Color(65535, 65535, 0))

        # the "backside" GC will have a different color
        self.bgc.set_rgb_fg_color(gtk.gdk.Color(65535, 32767, 0))

        # Calculate earliest sunrise and suchlike.
        self.calc_special_dates()

        # Draw three analemmas, showing the sun positions at 7:40 am,
        # noon, and 4:40 pm ... in each case adjusted for mean solar time,
        # i.e. the observer's position within their timezone.
        for time in [ '8:00', '12:00', '16:00' ]:
            for m in range(1, 13):
                self.draw_sun_position('%d/%d/1 %s' % (self.year, m, time))
                self.draw_sun_position('%d/%d/10 %s' % (self.year, m, time))
                self.draw_sun_position('%d/%d/20 %s' % (self.year, m, time))

        # Mark special dates for mean solar noon.
        self.draw_special_dates("12:00")

        # Make a label
        if observer.name == "custom":
            obslabel = "Observer at %.1f N, %.1f E" % (observer.lat,
                                                       observer.lon)
        else:
            obslabel = "Observer in " + self.observer.name
        self.draw_string(obslabel, 10, 10)

    def show_window(self):
        win = gtk.Window()
        self.drawing_area = gtk.DrawingArea()
        self.drawing_area.connect("expose-event", self.expose_handler)
        win.add(self.drawing_area)
        self.drawing_area.show()
        win.connect("destroy", gtk.main_quit)
        win.set_default_size(1025, 512)
        win.show()
        gtk.main()

if __name__ == "__main__":
    def Usage():
        progname = os.path.basename(sys.argv[0])
        print """Usage: %s [cityname]
       %s [lat lon]""" % (progname, progname)
        sys.exit(0)
    if len(sys.argv) == 2:
        if sys.argv[1] == "-h" or sys.argv[1] == "--help":
            Usage()
        observer = ephem.city(sys.argv[1])
    elif len(sys.argv) == 3:
        observer = ephem.Observer()
        observer.name = "Custom"
        observer.lon = sys.argv[1]
        observer.lat = sys.argv[2]
        
        #y=Here.here()[1]
        #observer.lon = y
        #observer.lat = x 
        #observer.name = "San Jose"
        #observer.lon = '-121:56.8'
        #observer.lat = '37:15.55'        
    else:
        # default to San Jose
        # pyephem doesn't know ephem.city('San Jose')
        # Houge Park is -121^56.53' 37^15.38'
        observer = ephem.Observer()
        observer.name = "Manila"
        #x, y =Here.here()
        #x = str(x);y=str(y)
        #observer.lon = "121:05.7"
        #observer.lat = "14:59.7"
        observer.lon = '-241:56.8'
        observer.lat = '37:15.55'                
        observer.elevation = 100

    awin = AnalemmaWindow(observer, ephem.now().triple()[0])
    x, y =Here.here()
    print awin.special_dates_str(),x,y
    awin.show_window()

14° 47' 50.7264'' N
121° 3' 26.932'' E


x, y = Here.here()
print x,y

!rm /usr/lib/python2.7/dist-packages/gtk-2.0/gtk/__init__.pyc

https://pythonhosted.org/astral/module.html

>>> from astral import GoogleGeocoder
>>> a = Astral(GoogleGeocoder)

or

>>> from astral import GoogleGeocoder
>>> a = Astral()
>>> a.geocoder = GoogleGeocoder()



from astral import GoogleGeocoder
a = Astral(GoogleGeocoder)

import SearchFilename
filename = "astralGOOD.txt"
length = 4
SearchFilename.searchfilename(filename, length)

import Here
import datetime
import datetime
from astral import Astral
city_name = 'London'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
timezone = city.timezone
sun = city.sun(date=datetime.date(2009, 4, 22), local=True)
dt = str(sun['sunrise'])[0:-6]
now = datetime.datetime.now()
date = now.strftime("%Y/%m/%d/%H")
x , y = Here.here()
print x, y
gatech = ephem.Observer()
gatech.lon = str(x)
gatech.lat = str(y)
gatech.elevation = 2100
gatech.date = dt
v = ephem.Sun(gatech)
#print('%s %s' % (v.alt, v.az))


#solar_azimuth(dateandtime, latitude, longitude)
solar_azimuth(dateandtime=None)

"""
DEMO TO COMPUTE SOLAR ZENITH ANGLE
version 6 April 2017
by Antti Lipponen

Copyright (c) 2017 Antti Lipponen

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"""

import numpy as np  # numerics & matrix algebra
from datetime import datetime  # dates and times
import time  # for measuring time
import matplotlib as mpl  # plotting
import matplotlib.pyplot as plt  # plotting
from mpl_toolkits.basemap import Basemap  # map

#################################################################################
# USER GIVEN PARAMETERS

# time
t = datetime(2017, 4, 6, 9, 30, 0)  # 6th April 2017 09:30:00 UTC

# grid dimensions
Nlats = 90
Nlons = 180

#################################################################################


#################################################################################
# FUNCTION TO COMPUTE SOLAR AZIMUTH AND ZENITH ANGLE
# translated to Python from http://www.psa.es/sdg/sunpos.htm
#################################################################################
def szafunc(day, dLongitude, dLatitude):
    """
        inputs: day: datetime object
                dLongitude: longitudes (scalar or Numpy array)
                dLatitude: latitudes (scalar or Numpy array)
        output: solar zenith angles
    """
    dHours, dMinutes, dSeconds = day.hour, day.minute, day.second
    iYear, iMonth, iDay = day.year, day.month, day.day

    dEarthMeanRadius = 6371.01
    dAstronomicalUnit = 149597890

    ###################################################################
    # Calculate difference in days between the current Julian Day
    # and JD 2451545.0, which is noon 1 January 2000 Universal Time
    ###################################################################
    # Calculate time of the day in UT decimal hours
    dDecimalHours = dHours + (dMinutes + dSeconds / 60.0) / 60.0
    # Calculate current Julian Day
    liAux1 = int((iMonth - 14) / 12)
    liAux2 = int((1461 * (iYear + 4800 + liAux1)) / 4) + int((367 * (iMonth - 2 - 12 * liAux1)) / 12) - int((3 * int((iYear + 4900 + liAux1) / 100)) / 4) + iDay - 32075
    dJulianDate = liAux2 - 0.5 + dDecimalHours / 24.0
    # Calculate difference between current Julian Day and JD 2451545.0
    dElapsedJulianDays = dJulianDate - 2451545.0

    ###################################################################
    # Calculate ecliptic coordinates (ecliptic longitude and obliquity of the
    # ecliptic in radians but without limiting the angle to be less than 2*Pi
    # (i.e., the result may be greater than 2*Pi)
    ###################################################################
    dOmega = 2.1429 - 0.0010394594 * dElapsedJulianDays
    dMeanLongitude = 4.8950630 + 0.017202791698 * dElapsedJulianDays  # Radians
    dMeanAnomaly = 6.2400600 + 0.0172019699 * dElapsedJulianDays
    dEclipticLongitude = dMeanLongitude + 0.03341607 * np.sin(dMeanAnomaly) + 0.00034894 * np.sin(2 * dMeanAnomaly) - 0.0001134 - 0.0000203 * np.sin(dOmega)
    dEclipticObliquity = 0.4090928 - 6.2140e-9 * dElapsedJulianDays + 0.0000396 * np.cos(dOmega)

    ###################################################################
    # Calculate celestial coordinates ( right ascension and declination ) in radians
    # but without limiting the angle to be less than 2*Pi (i.e., the result may be
    # greater than 2*Pi)
    ###################################################################
    dSin_EclipticLongitude = np.sin(dEclipticLongitude)
    dY = np.cos(dEclipticObliquity) * dSin_EclipticLongitude
    dX = np.cos(dEclipticLongitude)
    dRightAscension = np.arctan2(dY, dX)
    if dRightAscension < 0.0:
        dRightAscension = dRightAscension + 2.0 * np.pi
    dDeclination = np.arcsin(np.sin(dEclipticObliquity) * dSin_EclipticLongitude)

    ###################################################################
    # Calculate local coordinates ( azimuth and zenith angle ) in degrees
    ###################################################################
    dGreenwichMeanSiderealTime = 6.6974243242 + 0.0657098283 * dElapsedJulianDays + dDecimalHours
    dLocalMeanSiderealTime = (dGreenwichMeanSiderealTime * 15 + dLongitude) * (np.pi / 180)
    dHourAngle = dLocalMeanSiderealTime - dRightAscension
    dLatitudeInRadians = dLatitude * (np.pi / 180)
    dCos_Latitude = np.cos(dLatitudeInRadians)
    dSin_Latitude = np.sin(dLatitudeInRadians)
    dCos_HourAngle = np.cos(dHourAngle)
    dZenithAngle = (np.arccos(dCos_Latitude * dCos_HourAngle * np.cos(dDeclination) + np.sin(dDeclination) * dSin_Latitude))
    dY = -np.sin(dHourAngle)
    dX = np.tan(dDeclination) * dCos_Latitude - dSin_Latitude * dCos_HourAngle
    dAzimuth = np.arctan2(dY, dX)
    dAzimuth[dAzimuth < 0.0] = dAzimuth[dAzimuth < 0.0] + 2.0 * np.pi
    dAzimuth = dAzimuth / (np.pi / 180)
    # Parallax Correction
    dParallax = (dEarthMeanRadius / dAstronomicalUnit) * np.sin(dZenithAngle)
    dZenithAngle = (dZenithAngle + dParallax) / (np.pi / 180)

    return dAzimuth - 180.0, dZenithAngle


#################################################################################
# COMPUTE ZENITH ANGLES AND AZIMUTHS
#################################################################################

# coordinates in grid
lat, lon = np.linspace(-90.0, 90.0, Nlats + 1), np.linspace(-180.0, 180.0, Nlons + 1)  # lat and lon vectors for grid boundaries
latC, lonC = 0.5 * (lat[:-1] + lat[1:]), 0.5 * (lon[:-1] + lon[1:])  # center points

# make grid
latgrid, longrid = np.meshgrid(latC, lonC)

t0 = time.time()  # measure time to compute szas
# compute solar zenith angle and azimuth (be careful with azimuth: I haven't checked this at all)
saz, sza = szafunc(t, longrid.ravel(), latgrid.ravel())
print('Computed {} solar zenith angles and azimuths and it took {:.04f} seconds'.format(len(longrid.ravel()), time.time() - t0))


#################################################################################
# PLOT RESULTS
#################################################################################

# get colormap viridis (http://matplotlib.org/examples/color/colormaps_reference.html)
cmap = mpl.cm.viridis

# save colorbar to separate figure (solar zenith angle)
fig = plt.figure(figsize=(14, 8))
axCB = fig.add_axes([0.05, 0.10, 0.90, 0.03])
cb1 = mpl.colorbar.ColorbarBase(axCB, cmap=cmap, norm=mpl.colors.Normalize(vmin=0.0, vmax=90.0), orientation='horizontal')
cb1.set_label('Solar zenith angle')
plt.savefig('colormapSZA.png', dpi=150, bbox_inches='tight', pad_inches=0)
plt.close()

# save colorbar to separate figure (solar azimuth angle)
fig = plt.figure(figsize=(14, 8))
axCB = fig.add_axes([0.05, 0.10, 0.90, 0.03])
cb1 = mpl.colorbar.ColorbarBase(axCB, cmap=cmap, norm=mpl.colors.Normalize(vmin=-180.0, vmax=180.0), orientation='horizontal')
cb1.set_label('Solar azimuth angle')
plt.savefig('colormapSAZ.png', dpi=150, bbox_inches='tight', pad_inches=0)
plt.close()


# plot map of solar zenith angles
fig = plt.figure(figsize=(14, 8), frameon=False)
ax = fig.add_axes([0.05, 0.10, 0.9, 0.9])

# cylindrical projection
m = Basemap(projection='cyl', llcrnrlat=-90, urcrnrlat=90, llcrnrlon=-180, urcrnrlon=180, resolution='c')
m.drawcoastlines()
m.drawmeridians(np.arange(-180., 181., 30.), linewidth=0.5, color='#A0A0A0')
m.drawparallels(np.arange(-90., 91., 30.), linewidth=0.5, color='#A0A0A0')

x, y = m(longrid, latgrid)  # convert to map projection coordinates
contour = m.contourf(x, y, sza.reshape(Nlons, Nlats), np.linspace(0.0, 90.0, 90.0), cmap=cmap)
plt.title('Solar zenith angle, {}'.format(t.strftime('%d.%m.%Y %H:%M:%S UTC')))
plt.savefig('SZAmap.png', dpi=150, bbox_inches='tight', pad_inches=0)
plt.close()


# plot map of solar azimuth angles
fig = plt.figure(figsize=(14, 8), frameon=False)
ax = fig.add_axes([0.05, 0.10, 0.9, 0.9])

# cylindrical projection
m = Basemap(projection='cyl', llcrnrlat=-90, urcrnrlat=90, llcrnrlon=-180, urcrnrlon=180, resolution='c')
m.drawcoastlines()
m.drawmeridians(np.arange(-180., 181., 30.), linewidth=0.5, color='#A0A0A0')
m.drawparallels(np.arange(-90., 91., 30.), linewidth=0.5, color='#A0A0A0')

x, y = m(longrid, latgrid)  # convert to map projection coordinates
contour = m.contourf(x, y, saz.reshape(Nlons, Nlats), np.linspace(-180.0, 180.0, 360.0), cmap=cmap)
plt.title('Solar azimuth angle, {}'.format(t.strftime('%d.%m.%Y %H:%M:%S UTC')))
plt.savefig('SAZmap.png', dpi=150, bbox_inches='tight', pad_inches=0)
plt.close()

# and we're done!


!showme SAZmap.png

https://chrisramsay.co.uk/posts/2017/03/fun-with-the-sun-and-pyephem/

http://new-learn.info/packages/clear/thermal/climate/sun/sunpath_diagrams.html
https://stackoverflow.com/questions/43627983/how-to-make-a-continuous-parabolic-arc-with-only-3-known-points    
http://shallowsky.com/blog/tags/analemma/
https://recalll.co/app/?q=python%20-%20Matplotlib%20inset%20polar%20plot
http://rhodesmill.org/pyephem/quick.html#transit-rising-setting  
https://github.com/akkana/scripts 
    http://pythonhosted.org/astral/#example

try:
    import urllib2
    from bs4 import BeautifulSoup
    from time import sleep
    import os
    import sys
    from time import sleep
except ImportError:
    print "ImportError !"
url = 'http://jacknorthrup.com/PDFshort.html'
path = "mathbooks/"
headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36'}
request = urllib2.Request(url,None,headers)
html = urllib2.urlopen(request)
soup = BeautifulSoup(html.read(), "html.parser")
soup.prettify()
#modifying the url for concatonation with 
url =  url.split('/') 
del url[-1]
url.append('')
url = '/'.join(url)
urls = []
names = []
for anchor in soup.findAll('a', href=True): #Going inside links
    req = urllib2.Request(anchor['href'],None,headers)
    pag = urllib2.urlopen(req)
    pgf = pag.read()
    soup1 = BeautifulSoup(pgf, "html.parser")
    for i, link in enumerate(soup1.findAll('a')): # Download all pdf inside each link
        fullurl = url + str(link.get('href'))
        #print fullurl

        if fullurl.endswith('.pdf'):
            #print fullurl
            urls.append(fullurl)
            names.append(soup1.select('a')[i].attrs['href'])

names_urls = zip(names, urls)
os.chdir(path)

for name, url1 in names_urls:
    try:
        if os.path.isfile(name):
            print name, "Already exists skipping..."
            pass
        else:
            rq = urllib2.Request(url1)
            res = urllib2.urlopen(rq)
            with open(name, 'wb') as pdf:
                pdf.write(res.read())
            print name, "Downloaded"
    except:
        print name, "Failed to download"
        pass
    sleep(1)

import astral
help(astral)

import astral
astral.Location


import ephem
from astral import *
import Here
a = Astral()
location = a['London']
timezone = location.timezone
from datetime import date
nd = datetime.date(1917, 10, 16)
nt = datetime.time(19, 10, 16)
print nd, nt
#sun = location.sun(local=True, date=d)
Time = str(sun['dawn'])
x , y = Here.here()
print x, y
gatech = ephem.Observer()
gatech.lon = str(x)
gatech.lat = str(y)





print Astral.solar_azimuth(nd,nt)

from datetime import date
nd = datetime.date(1917, 10, 16)
nt = datetime.time(19, 10, 16)
print nd, nt


import datetime
datetime.date(9999, 12, 31)

import datetime
help(datetime)

def solar_azimuth(self, dateandtime=None):
    """Calculates the solar azimuth angle for a specific date/time.
    :param dateandtime: The date and time for which to calculate the angle.
    :type dateandtime: :class:`~datetime.datetime`
    :returns: The azimuth angle in degrees clockwise from North.
    :rtype: float
    """
    if self.astral is None:
         self.astral = Astral()
    if dateandtime is None:
         dateandtime = datetime.datetime.now(self.tz)
    elif not dateandtime.tzinfo:
         dateandtime = self.tz.localize(dateandtime)
    dateandtime = dateandtime.astimezone(pytz.UTC)
    return self.astral.solar_azimuth(dateandtime, self.latitude, self.longitude)


%reset -f 

from datetime import time
help(time)

time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) 

from datetime import time
time = time(12,24,32, 23, UTC)
print time

from astral import *
a = Astral()
location = a['London']
timezone = location.timezone
from datetime import date
d = date(2009,4,22)
sun = location.sun(local=True, date=d)
s= str(sun['dawn'])

print s

import Here
from astral import *
def update_sun_position(utc_point_in_time):
    """Calculate the position of the sun."""
    from astral import Astral
 
    solar_azimuth = Astral().solar_azimuth(
        utc_point_in_time,
        astral.Location.latitude,
        astral.Location.longitude)
 
    solar_elevation = Astral().solar_elevation(
        utc_point_in_time,

        astral.Location.latitude,
        astral.Location.longitude)  
    
latitude, longitude = Here.here()
latitude = float(latitude)
longitude = float(longitude)
date = time.strftime("%x ")+ time.strftime("%X")
update_sun_position(date)   

import Here
from astral import *
def update_sun_position(utc_point_in_time):
    """Calculate the position of the sun."""
    from astral import Astral
 
    solar_azimuth = Astral().solar_azimuth(
        utc_point_in_time,
        astral.Location.latitude,
        astral.Location.longitude)
 
    solar_elevation = Astral().solar_elevation(
        utc_point_in_time,

        astral.Location.latitude,
        astral.Location.longitude)  
    
latitude, longitude = Here.here()
latitude = float(latitude)
longitude = float(longitude)
date = time.strftime("%x ")+ time.strftime("%X")
update_sun_position(date)   

import time
import datetime
import Here
latitude, longitude = Here.here()
latitude = float(latitude)
longitude = float(longitude)
print latitude, longitude, time.strftime("%x ")+ time.strftime("%X")

#!/usr/bin/python
 
import time
 
now = time.strftime("%c")
## date and time representation
print "Current date & time " + time.strftime("%c")
 
## Only date representation
print "Current date "  + time.strftime("%x")
 
## Only time representation
print "Current time " + time.strftime("%X")
 
## Display current date and time from now variable 
print ("Current time %s"  % now )

print  time.strftime("%x ")+ time.strftime("%X")

import astropy

http://docs.astropy.org/en/stable/generated/examples/coordinates/plot_obs-planning.html

from pylab import *
import SUNposition
#from SUNposition import sunposition
from datetime import datetime

#evaluate on a 2 degree grid
lon  = linspace(-180,180,181)
lat = linspace(-90,90,91)
LON, LAT = meshgrid(lon,lat)
#at the current time
now = datetime.utcnow()
az,zen = sunposition(now,LAT,LON,0)[:2] #discard RA, dec, H
#convert zenith to elevation
elev = 90 - zen
#convert azimuth to vectors
u, v = cos((90-az)*pi/180), sin((90-az)*pi/180)
#plot
figure()
imshow(elev,cmap=cm.CMRmap,origin='lower',vmin=-90,vmax=90,extent=(-180,180,-90,90))
s = slice(5,-1,5) # equivalent to 5:-1:5
quiver(lon[s],lat[s],u[s,s],v[s,s])
contour(lon,lat,elev,[0])
cb = colorbar()
cb.set_label('Elevation Angle (deg)')
gca().set_aspect('equal')
xticks(arange(-180,181,45)); yticks(arange(-90,91,45))

import sunpos
loc=sunpos.cLocation()
loc.dLatitude = 43.1
loc.dLongitude = 131.9

time=sunpos.cTime()
time.iYear = 2013 #imteger, year
time.iMonth = 10 #Integer, month
time.iDay = 13 #integer, day
time.dHours = 16 #double, hours UTC
time.dMinutes = 32 #double, minutes
time.dSeconds = 12 #double, seconds
#calculations
res = sunpos.sunposf(time, loc)
#or 
res = sunpos.cSunCoordinates()
sunpos.sunpos(time, loc, res)
print res.dZenithAngle # sun zenith  angle
print res.dAzimuth # sun azimuth  angle:


%%writefile calcSun.py
# UTILS/calcSun
"""
*********************
**Module**: utils.calcSun
*********************
This subpackage contains def to calculate sunrise/sunset

This includes the following defs:
    * :func:`utils.calcSun.getJD`: 
        calculate the julian date from a python datetime object
    * :func:`utils.calcSun.calcTimeJulianCent`: 
        convert Julian Day to centuries since J2000.0.
    * :func:`utils.calcSun.calcGeomMeanLongSun`: 
        calculate the Geometric Mean Longitude of the Sun (in degrees)
    * :func:`utils.calcSun.calcGeomMeanAnomalySun`: 
        calculate the Geometric Mean Anomaly of the Sun (in degrees)
    * :func:`utils.calcSun.calcEccentricityEarthOrbit`: 
        calculate the eccentricity of earth's orbit (unitless)
    * :func:`utils.calcSun.calcSunEqOfCenter`: 
        calculate the equation of center for the sun (in degrees)
    * :func:`utils.calcSun.calcSunTrueLong`: 
        calculate the true longitude of the sun (in degrees)
    * :func:`utils.calcSun.calcSunTrueAnomaly`: 
        calculate the true anamoly of the sun (in degrees)
    * :func:`utils.calcSun.calcSunRadVector`: 
        calculate the distance to the sun in AU (in degrees)
    * :func:`utils.calcSun.calcSunApparentLong`: 
        calculate the apparent longitude of the sun (in degrees)
    * :func:`utils.calcSun.calcMeanObliquityOfEcliptic`: 
        calculate the mean obliquity of the ecliptic (in degrees)
    * :func:`utils.calcSun.calcObliquityCorrection`: 
        calculate the corrected obliquity of the ecliptic (in degrees)
    * :func:`utils.calcSun.calcSunRtAscension`: 
        calculate the right ascension of the sun (in degrees)
    * :func:`utils.calcSun.calcSunDeclination`: 
        calculate the declination of the sun (in degrees)
    * :func:`utils.calcSun.calcEquationOfTime`: 
        calculate the difference between true solar time and mean solar time (output: equation of time in minutes of time)
    * :func:`utils.calcSun.calcHourAngleSunrise`: 
        calculate the hour angle of the sun at sunrise for the latitude (in radians)
    * :func:`utils.calcSun.calcAzEl`: 
        calculate sun azimuth and zenith angle
    * :func:`utils.calcSun.calcSolNoonUTC`: 
        calculate time of solar noon the given day at the given location on earth (in minutes since 0 UTC)
    * :func:`utils.calcSun.calcSolNoon`: 
        calculate time of solar noon the given day at the given location on earth (in minutes)
    * :func:`utils.calcSun.calcSunRiseSetUTC`: 
        calculate sunrise/sunset the given day at the given location on earth (in minutes since 0 UTC)
    * :func:`utils.calcSun.calcSunRiseSet`: 
        calculate sunrise/sunset the given day at the given location on earth (in minutes)
    * :func:`utils.calcSun.calcTerminator`: 
        calculate terminator position and solar zenith angle for a given julian date-time within latitude/longitude limits
        note that for plotting only, basemap has a built-in terminator

Source: http://www.esrl.noaa.gov/gmd/grad/solcalc/
Translated to Python by Sebastien de Larquier

*******************************
"""
import math
import numpy


def calcTimeJulianCent( jd ):
    """
Convert Julian Day to centuries since J2000.0.
    """
    T = (jd - 2451545.0)/36525.0
    return T



def calcGeomMeanLongSun( t ):
    """
Calculate the Geometric Mean Longitude of the Sun (in degrees)
    """
    L0 = 280.46646 + t * ( 36000.76983 + t*0.0003032 )
    while L0 > 360.0:
        L0 -= 360.0
    while L0 < 0.0:
        L0 += 360.0
    return L0 # in degrees



def calcGeomMeanAnomalySun( t ):
    """
Calculate the Geometric Mean Anomaly of the Sun (in degrees)
    """
    M = 357.52911 + t * ( 35999.05029 - 0.0001537 * t)
    return M # in degrees



def calcEccentricityEarthOrbit( t ):
    """
Calculate the eccentricity of earth's orbit (unitless)
    """
    e = 0.016708634 - t * ( 0.000042037 + 0.0000001267 * t)
    return e # unitless



def calcSunEqOfCenter( t ):
    """
Calculate the equation of center for the sun (in degrees)
    """
    mrad = numpy.radians(calcGeomMeanAnomalySun(t))
    sinm = numpy.sin(mrad)
    sin2m = numpy.sin(mrad+mrad)
    sin3m = numpy.sin(mrad+mrad+mrad)
    C = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289
    return C # in degrees



def calcSunTrueLong( t ):
    """
Calculate the true longitude of the sun (in degrees)
    """
    l0 = calcGeomMeanLongSun(t)
    c = calcSunEqOfCenter(t)
    O = l0 + c
    return O # in degrees



def calcSunTrueAnomaly( t ):
    """
Calculate the true anamoly of the sun (in degrees)
    """
    m = calcGeomMeanAnomalySun(t)
    c = calcSunEqOfCenter(t)
    v = m + c
    return v # in degrees



def calcSunRadVector( t ):
    """
Calculate the distance to the sun in AU (in degrees)
    """
    v = calcSunTrueAnomaly(t)
    e = calcEccentricityEarthOrbit(t)
    R = (1.000001018 * (1. - e * e)) / ( 1. + e * numpy.cos( numpy.radians(v) ) )
    return R # n AUs



def calcSunApparentLong( t ):
    """
Calculate the apparent longitude of the sun (in degrees)
    """
    o = calcSunTrueLong(t)
    omega = 125.04 - 1934.136 * t
    SunLong = o - 0.00569 - 0.00478 * numpy.sin(numpy.radians(omega))
    return SunLong # in degrees



def calcMeanObliquityOfEcliptic( t ):
    """
Calculate the mean obliquity of the ecliptic (in degrees)
    """
    seconds = 21.448 - t*(46.8150 + t*(0.00059 - t*(0.001813)))
    e0 = 23.0 + (26.0 + (seconds/60.0))/60.0
    return e0 # in degrees



def calcObliquityCorrection( t ):
    """
Calculate the corrected obliquity of the ecliptic (in degrees)
    """
    e0 = calcMeanObliquityOfEcliptic(t)
    omega = 125.04 - 1934.136 * t
    e = e0 + 0.00256 * numpy.cos(numpy.radians(omega))
    return e # in degrees



def calcSunRtAscension( t ):
    """
Calculate the right ascension of the sun (in degrees)
    """
    e = calcObliquityCorrection(t)
    SunLong = calcSunApparentLong(t)
    tananum = ( numpy.cos(numpy.radians(e)) * numpy.sin(numpy.radians(SunLong)) )
    tanadenom = numpy.cos(numpy.radians(SunLong))
    alpha = numpy.degrees(anumpy.arctan2(tananum, tanadenom))
    return alpha # in degrees



def calcSunDeclination( t ):
    """
Calculate the declination of the sun (in degrees)
    """
    e = calcObliquityCorrection(t)
    SunLong = calcSunApparentLong(t)
    sint = numpy.sin(numpy.radians(e)) * numpy.sin(numpy.radians(SunLong))
    theta = numpy.degrees(numpy.arcsin(sint))
    return theta # in degrees



def calcEquationOfTime( t ):
    """
Calculate the difference between true solar time and mean solar time (output: equation of time in minutes of time)  
    """
    epsilon = calcObliquityCorrection(t)
    l0 = calcGeomMeanLongSun(t)
    e = calcEccentricityEarthOrbit(t)
    m = calcGeomMeanAnomalySun(t)
    y = numpy.tan(numpy.radians(epsilon/2.0))
    y *= y

    sin2l0 = numpy.sin(numpy.radians(2.0 * l0))
    sinm   = numpy.sin(numpy.radians(m))
    cos2l0 = numpy.cos(numpy.radians(2.0 * l0))
    sin4l0 = numpy.sin(numpy.radians(4.0 * l0))
    sin2m  = numpy.sin(numpy.radians(2.0 * m))

    Etime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0 - 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m
    return numpy.degrees(Etime*4.0) # in minutes of time



def calcHourAngleSunrise( lat, solarDec ):
    """
Calculate the hour angle of the sun at sunrise for the latitude (in radians)
    """
    latRad = numpy.radians(lat)
    sdRad  = numpy.radians(solarDec)
    HAarg = numpy.cos(numpy.radians(90.833)) / ( numpy.cos(latRad)*numpy.cos(sdRad) ) - numpy.tan(latRad) * numpy.tan(sdRad)
    HA = numpy.arccos(HAarg);
    return HA # in radians (for sunset, use -HA)



def calcAzEl( t, localtime, latitude, longitude, zone ):
    """
Calculate sun azimuth and zenith angle
    """
    eqTime = calcEquationOfTime(t)
    theta  = calcSunDeclination(t)

    solarTimeFix = eqTime + 4.0 * longitude - 60.0 * zone
    earthRadVec = calcSunRadVector(t)

    trueSolarTime = localtime + solarTimeFix
    while trueSolarTime > 1440:
        trueSolarTime -= 1440.

    hourAngle = trueSolarTime / 4.0 - 180.0
    if hourAngle < -180.: 
        hourAngle += 360.0

    haRad = numpy.radians(hourAngle)
    csz = numpy.sin(numpy.radians(latitude)) * numpy.sin(numpy.radians(theta)) + numpy.cos(numpy.radians(latitude)) * numpy.cos(numpy.radians(theta)) * numpy.cos(haRad)
    if csz > 1.0: 
        csz = 1.0 
    elif csz < -1.0: 
        csz = -1.0
    zenith = numpy.degrees(numpy.arccos(csz))
    azDenom = numpy.cos(numpy.radians(latitude)) * numpy.sin(numpy.radians(zenith))
    if abs(azDenom) > 0.001: 
        azRad = (( numpy.sin(numpy.radians(latitude)) * numpy.cos(numpy.radians(zenith)) ) - numpy.sin(numpy.radians(theta))) / azDenom
        if abs(azRad) > 1.0: 
            if azRad < 0.: 
                azRad = -1.0 
            else:
                azRad = 1.0
        
        azimuth = 180.0 - numpy.degrees(numpy.arccos(azRad))
        if hourAngle > 0.0: 
            azimuth = -azimuth
    else:
        if latitude > 0.0: 
            azimuth = 180.0 
        else:
            azimuth = 0.0
    if azimuth < 0.0: 
        azimuth += 360.0
    exoatmElevation = 90.0 - zenith

    # Atmospheric Refraction correction
    if exoatmElevation > 85.0: 
        refractionCorrection = 0.0
    else:
        te = numpy.tan(numpy.radians(exoatmElevation))
        if exoatmElevation > 5.0: 
            refractionCorrection = 58.1 / te - 0.07 / (te*te*te) + 0.000086 / (te*te*te*te*te) 
        elif exoatmElevation > -0.575: 
            refractionCorrection = 1735.0 + exoatmElevation * (-518.2 + exoatmElevation * (103.4 + exoatmElevation * (-12.79 + exoatmElevation * 0.711) ) ) 
        else:
            refractionCorrection = -20.774 / te
        refractionCorrection = refractionCorrection / 3600.0

    solarZen = zenith - refractionCorrection
    
    return azimuth, solarZen



def calcSolNoonUTC( jd, longitude ):
    """
Calculate time of solar noon the given day at the given location on earth (in minute since 0 UTC)
    """
    tnoon = calcTimeJulianCent(jd)
    eqTime = calcEquationOfTime(tnoon)
    solNoonUTC = 720.0 - (longitude * 4.) - eqTime # in minutes
    return solNoonUTC



def calcSolNoon( jd, longitude, timezone, dst ):
    """
Calculate time of solar noon the given day at the given location on earth (in minute)
    """
    timeUTC    = calcSolNoonUTC(jd, longitude)
    newTimeUTC = calcSolNoonUTC(jd + timeUTC/1440.0, longitude)
    solNoonLocal = newTimeUTC + (timezone*60.0) # in minutes
    if dst: 
        solNoonLocal += 60.0
    return solNoonLocal



def calcSunRiseSetUTC( jd, latitude, longitude ):
    """
Calculate sunrise/sunset the given day at the given location on earth (in minute since 0 UTC)
    """
    t = calcTimeJulianCent(jd)
    eqTime = calcEquationOfTime(t)
    solarDec = calcSunDeclination(t)
    hourAngle = calcHourAngleSunrise(latitude, solarDec)
    # Rise time
    delta = longitude + numpy.degrees(hourAngle)
    riseTimeUTC = 720. - (4.0 * delta) - eqTime # in minutes
    # Set time
    hourAngle = -hourAngle
    delta = longitude + numpy.degrees(hourAngle)
    setTimeUTC = 720. - (4.0 * delta) - eqTime # in minutes
    return riseTimeUTC, setTimeUTC



def calcSunRiseSet( jd, latitude, longitude, timezone, dst ):
    """
Calculate sunrise/sunset the given day at the given location on earth (in minutes)
    """
    rtimeUTC, stimeUTC = calcSunRiseSetUTC(jd, latitude, longitude)
    # calculate local sunrise time (in minutes)
    rnewTimeUTC, snewTimeUTC = calcSunRiseSetUTC(jd + rtimeUTC/1440.0, latitude, longitude)
    rtimeLocal = rnewTimeUTC + (timezone * 60.0)
    rtimeLocal += 60.0 if dst else 0.0
    if rtimeLocal < 0.0 or rtimeLocal >= 1440.0: 
        jday = jd
        increment = 1. if rtimeLocal < 0. else -1.
        while rtimeLocal < 0.0 or rtimeLocal >= 1440.0:
            rtimeLocal += increment * 1440.0
            jday -= increment
    # calculate local sunset time (in minutes)
    rnewTimeUTC, snewTimeUTC = calcSunRiseSetUTC(jd + stimeUTC/1440.0, latitude, longitude)
    stimeLocal = snewTimeUTC + (timezone * 60.0)
    stimeLocal += 60.0 if dst else 0.0
    if stimeLocal < 0.0 or stimeLocal >= 1440.0: 
        jday = jd
        increment = 1. if stimeLocal < 0. else -1.
        while stimeLocal < 0.0 or stimeLocal >= 1440.0:
            stimeLocal += increment * 1440.0
            jday -= increment
    # return
    return rtimeLocal, stimeLocal



def calcTerminator( date, latitudes, longitudes ):
    """
Calculate terminator position and solar zenith angle for a given julian date-time within 
latitude/longitude limits
Note that for plotting only, basemap has a built-in terminator
    """
    jd = getJD(date)
    t = calcTimeJulianCent(jd)
    ut = ( jd - (int(jd - 0.5) + 0.5) )*1440.
    npoints = 50
    zen = numpy.zeros((npoints,npoints))
    lats = numpy.linspace(latitudes[0], latitudes[1], num=npoints)
    lons = numpy.linspace(longitudes[0], longitudes[1], num=npoints)
    term = []
    for ilat in range(1,npoints+1):
        for ilon in range(npoints):
            az,el = calcAzEl(t, ut, lats[-ilat], lons[ilon], 0.) 
            zen[-ilat,ilon] = el
        a = (90 - zen[-ilat,:])
        mins = numpy.r_[False, a[1:]*a[:-1] <= 0] | \
            numpy.r_[a[1:]*a[:-1] <= 0, False] 
        zmin = mins & numpy.r_[False, a[1:] < a[:-1]]
        if True in zmin:
            ll = numpy.interp(0, a[zmin][-1::-1], lons[zmin][-1::-1])
            term.append([lats[-ilat], ll])
        zmin = mins & numpy.r_[a[:-1] < a[1:], False]
        if True in zmin:
            ll = numpy.interp(0, a[zmin], lons[zmin])
            term.insert(0, [lats[-ilat], ll])
    return lats, lons, zen, numpy.array(term)



def getJD( date ):
    """
Calculate julian date for given day, month and year
    """
    from dateutil.relativedelta import relativedelta
    
    if date.month < 2: 
        date.replace(year=date.year-1)
        date += relativedelta(month=12)

    A = numpy.floor(date.year/100.)
    B = 2. - A + numpy.floor(A/4.)
    jd = numpy.floor(365.25*(date.year + 4716.)) + numpy.floor(30.6001*(date.month+1)) + date.day + B - 1524.5
    jd = jd + date.hour/24.0 + date.minute/1440.0 + date.second/86400.0
    return jd



from datetime import datetime
dateandtime = datetime.utcnow()

dnt = dateandtime
print dnt

import calcSun
from datetime import datetime
date = datetime.utcnow()
calcSun.getJD( date )

import calcSun
from datetime import datetime
date = datetime.utcnow()
calcSun.getJD( date )

import calcSun
from datetime import datetime
import Here
date = datetime.utcnow()
jd = calcSun.getJD( date )
latitude, longitude = Here.here()
import matplotlib.pyplot as plt
#at the current time
#now = datetime.utcnow()
#calcSun.RiseSetUTC( jd, latitude, longitude )
#14.797424 121.057481
calcSun.calcTerminator( date, (14.797424,14.434346), (121.057481,121.454549) )


import calcSun
from datetime import datetime
import Here
date = datetime.utcnow()
jd = calcSun.getJD( date )
latitude, longitude = Here.here()
import matplotlib.pyplot as plt
#at the current time
#now = datetime.utcnow()
#calcSun.RiseSetUTC( jd, latitude, longitude )
#14.797424 121.057481
a  = calcSun.calcTerminator( date, (14.797424,14.434346), (121.057481,121.454549) )
a[0],a[1],a[2] 
print a[0],a[1],a[2] 



import calcSun
from datetime import datetime
import Here
import matplotlib.pyplot as plt
date = datetime.utcnow()
jd = calcSun.getJD( date )
latitude, longitude = Here.here()

#at the current time
#now = datetime.utcnow()
#calcSun.RiseSetUTC( jd, latitude, longitude )
#14.797424 121.057481
a  = calcSun.calcTerminator( date, (14.797424,14.434346), (121.057481,121.454549) )
a[0],a[1],a[2] 

plt.plot(a[0])
plt.ylabel('some numbers')
plt.show()


import calcSun
from datetime import datetime
import Here
import matplotlib.pyplot as plt
date = datetime.utcnow()
jd = calcSun.getJD( date )
latitude, longitude = Here.here()

#at the current time
#now = datetime.utcnow()
#calcSun.RiseSetUTC( jd, latitude, longitude )
#14.797424 121.057481
a  = calcSun.calcTerminator( date, (14.797424,14.434346), (121.057481,121.454549) )
a[0],a[1],a[2] 
plt.plot(a[0], a[1], 'ro')
plt.axis([14.4, 14.85, 120.9,121.7])
plt.show()

import calcSun
from datetime import datetime
import Here
import matplotlib.pyplot as plt
date = datetime.utcnow()
jd = calcSun.getJD( date )
latitude, longitude = Here.here()

#at the current time
#now = datetime.utcnow()
#calcSun.RiseSetUTC( jd, latitude, longitude )
#14.797424 121.057481
a  = calcSun.calcTerminator( date, (14.797424,14.434346), (121.057481,121.454549) )
a[0],a[1],a[2] 



# red dashes, blue squares and green triangles
#plt.axis([60.8, 62, -1,55])
plt.plot(a[1], a[2],  'ro' )
plt.show()

from datetime import datetime, timedelta
from pytz import timezone
import pytz
utc = pytz.utc
utc.zone

import calcSun
from datetime import datetime
import Here
import matplotlib.pyplot as plt
from astral import *
from datetime import datetime, timedelta
from pytz import timezone
import pytz
utc = pytz.utc
UTC = utc.zone
a = Astral()
location = a['Manila']
zone = location.timezone
date = datetime.utcnow()
jd = calcSun.getJD( date )
latitude, longitude = Here.here()
t = calcTimeJulianCent( jd )
localtime = datetime
calcAzEl( t, localtime, 14.797424, 121.057481, +0200 )



def calcAzEl( t, localtime, latitude, longitude, zone ):
    """
Calculate sun azimuth and zenith angle
    """
    eqTime = calcEquationOfTime(t)
    theta  = calcSunDeclination(t)

    solarTimeFix = eqTime + 4.0 * longitude - 60.0 * zone
    earthRadVec = calcSunRadVector(t)

    trueSolarTime = localtime + solarTimeFix
    while trueSolarTime > 1440:
        trueSolarTime -= 1440.

    hourAngle = trueSolarTime / 4.0 - 180.0
    if hourAngle < -180.: 
        hourAngle += 360.0

    haRad = numpy.radians(hourAngle)
    csz = numpy.sin(numpy.radians(latitude)) * numpy.sin(numpy.radians(theta)) + numpy.cos(numpy.radians(latitude)) * numpy.cos(numpy.radians(theta)) * numpy.cos(haRad)
    if csz > 1.0: 
        csz = 1.0 
    elif csz < -1.0: 
        csz = -1.0
    zenith = numpy.degrees(numpy.arccos(csz))
    azDenom = numpy.cos(numpy.radians(latitude)) * numpy.sin(numpy.radians(zenith))
    if abs(azDenom) > 0.001: 
        azRad = (( numpy.sin(numpy.radians(latitude)) * numpy.cos(numpy.radians(zenith)) ) - numpy.sin(numpy.radians(theta))) / azDenom
        if abs(azRad) > 1.0: 
            if azRad < 0.: 
                azRad = -1.0 
            else:
                azRad = 1.0
        
        azimuth = 180.0 - numpy.degrees(numpy.arccos(azRad))
        if hourAngle > 0.0: 
            azimuth = -azimuth
    else:
        if latitude > 0.0: 
            azimuth = 180.0 
        else:
            azimuth = 0.0
    if azimuth < 0.0: 
        azimuth += 360.0
    exoatmElevation = 90.0 - zenith

    # Atmospheric Refraction correction
    if exoatmElevation > 85.0: 
        refractionCorrection = 0.0
    else:
        te = numpy.tan(numpy.radians(exoatmElevation))
        if exoatmElevation > 5.0: 
            refractionCorrection = 58.1 / te - 0.07 / (te*te*te) + 0.000086 / (te*te*te*te*te) 
        elif exoatmElevation > -0.575: 
            refractionCorrection = 1735.0 + exoatmElevation * (-518.2 + exoatmElevation * (103.4 + exoatmElevation * (-12.79 + exoatmElevation * 0.711) ) ) 
        else:
            refractionCorrection = -20.774 / te
        refractionCorrection = refractionCorrection / 3600.0

    solarZen = zenith - refractionCorrection
    
    return azimuth, solarZen

import calcSun
from datetime import datetime
import Here
import matplotlib.pyplot as plt
from astral import *
from datetime import datetime, timedelta
from pytz import timezone
import pytz
utc = pytz.utc
UTC = utc.zone
a = Astral()
location = a['Manila']
zone = location.timezone
date = datetime.utcnow()
jd = calcSun.getJD( date )
latitude, longitude = Here.here()
t = calcTimeJulianCent( jd )
localtime = datetime.datetime
#calcAzEl( t, localtime, 14.797424, 121.057481, +0200 )
#eqTime = calcEquationOfTime(t)
#theta  = calcSunDeclination(t)
#solarTimeFix = eqTime + 4.0 - 60.0 * 3
#trueSolarTime = localtime + solarTimeFix
print localtime


%%writefile calcSun.py
# UTILS/calcSun
"""
*********************
**Module**: utils.calcSun
*********************
This subpackage contains def to calculate sunrise/sunset

This includes the following defs:
    * :func:`utils.calcSun.getJD`: 
        calculate the julian date from a python datetime object
    * :func:`utils.calcSun.calcTimeJulianCent`: 
        convert Julian Day to centuries since J2000.0.
    * :func:`utils.calcSun.calcGeomMeanLongSun`: 
        calculate the Geometric Mean Longitude of the Sun (in degrees)
    * :func:`utils.calcSun.calcGeomMeanAnomalySun`: 
        calculate the Geometric Mean Anomaly of the Sun (in degrees)
    * :func:`utils.calcSun.calcEccentricityEarthOrbit`: 
        calculate the eccentricity of earth's orbit (unitless)
    * :func:`utils.calcSun.calcSunEqOfCenter`: 
        calculate the equation of center for the sun (in degrees)
    * :func:`utils.calcSun.calcSunTrueLong`: 
        calculate the true longitude of the sun (in degrees)
    * :func:`utils.calcSun.calcSunTrueAnomaly`: 
        calculate the true anamoly of the sun (in degrees)
    * :func:`utils.calcSun.calcSunRadVector`: 
        calculate the distance to the sun in AU (in degrees)
    * :func:`utils.calcSun.calcSunApparentLong`: 
        calculate the apparent longitude of the sun (in degrees)
    * :func:`utils.calcSun.calcMeanObliquityOfEcliptic`: 
        calculate the mean obliquity of the ecliptic (in degrees)
    * :func:`utils.calcSun.calcObliquityCorrection`: 
        calculate the corrected obliquity of the ecliptic (in degrees)
    * :func:`utils.calcSun.calcSunRtAscension`: 
        calculate the right ascension of the sun (in degrees)
    * :func:`utils.calcSun.calcSunDeclination`: 
        calculate the declination of the sun (in degrees)
    * :func:`utils.calcSun.calcEquationOfTime`: 
        calculate the difference between true solar time and mean solar time (output: equation of time in minutes of time)
    * :func:`utils.calcSun.calcHourAngleSunrise`: 
        calculate the hour angle of the sun at sunrise for the latitude (in radians)
    * :func:`utils.calcSun.calcAzEl`: 
        calculate sun azimuth and zenith angle
    * :func:`utils.calcSun.calcSolNoonUTC`: 
        calculate time of solar noon the given day at the given location on earth (in minutes since 0 UTC)
    * :func:`utils.calcSun.calcSolNoon`: 
        calculate time of solar noon the given day at the given location on earth (in minutes)
    * :func:`utils.calcSun.calcSunRiseSetUTC`: 
        calculate sunrise/sunset the given day at the given location on earth (in minutes since 0 UTC)
    * :func:`utils.calcSun.calcSunRiseSet`: 
        calculate sunrise/sunset the given day at the given location on earth (in minutes)
    * :func:`utils.calcSun.calcTerminator`: 
        calculate terminator position and solar zenith angle for a given julian date-time within latitude/longitude limits
        note that for plotting only, basemap has a built-in terminator

Source: http://www.esrl.noaa.gov/gmd/grad/solcalc/
Translated to Python by Sebastien de Larquier

*******************************
"""
import math
import numpy


def calcTimeJulianCent( jd ):
    """
Convert Julian Day to centuries since J2000.0.
    """
    T = (jd - 2451545.0)/36525.0
    return T



def calcGeomMeanLongSun( t ):
    """
Calculate the Geometric Mean Longitude of the Sun (in degrees)
    """
    L0 = 280.46646 + t * ( 36000.76983 + t*0.0003032 )
    while L0 > 360.0:
        L0 -= 360.0
    while L0 < 0.0:
        L0 += 360.0
    return L0 # in degrees



def calcGeomMeanAnomalySun( t ):
    """
Calculate the Geometric Mean Anomaly of the Sun (in degrees)
    """
    M = 357.52911 + t * ( 35999.05029 - 0.0001537 * t)
    return M # in degrees



def calcEccentricityEarthOrbit( t ):
    """
Calculate the eccentricity of earth's orbit (unitless)
    """
    e = 0.016708634 - t * ( 0.000042037 + 0.0000001267 * t)
    return e # unitless



def calcSunEqOfCenter( t ):
    """
Calculate the equation of center for the sun (in degrees)
    """
    mrad = numpy.radians(calcGeomMeanAnomalySun(t))
    sinm = numpy.sin(mrad)
    sin2m = numpy.sin(mrad+mrad)
    sin3m = numpy.sin(mrad+mrad+mrad)
    C = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289
    return C # in degrees



def calcSunTrueLong( t ):
    """
Calculate the true longitude of the sun (in degrees)
    """
    l0 = calcGeomMeanLongSun(t)
    c = calcSunEqOfCenter(t)
    O = l0 + c
    return O # in degrees



def calcSunTrueAnomaly( t ):
    """
Calculate the true anamoly of the sun (in degrees)
    """
    m = calcGeomMeanAnomalySun(t)
    c = calcSunEqOfCenter(t)
    v = m + c
    return v # in degrees



def calcSunRadVector( t ):
    """
Calculate the distance to the sun in AU (in degrees)
    """
    v = calcSunTrueAnomaly(t)
    e = calcEccentricityEarthOrbit(t)
    R = (1.000001018 * (1. - e * e)) / ( 1. + e * numpy.cos( numpy.radians(v) ) )
    return R # n AUs



def calcSunApparentLong( t ):
    """
Calculate the apparent longitude of the sun (in degrees)
    """
    o = calcSunTrueLong(t)
    omega = 125.04 - 1934.136 * t
    SunLong = o - 0.00569 - 0.00478 * numpy.sin(numpy.radians(omega))
    return SunLong # in degrees



def calcMeanObliquityOfEcliptic( t ):
    """
Calculate the mean obliquity of the ecliptic (in degrees)
    """
    seconds = 21.448 - t*(46.8150 + t*(0.00059 - t*(0.001813)))
    e0 = 23.0 + (26.0 + (seconds/60.0))/60.0
    return e0 # in degrees



def calcObliquityCorrection( t ):
    """
Calculate the corrected obliquity of the ecliptic (in degrees)
    """
    e0 = calcMeanObliquityOfEcliptic(t)
    omega = 125.04 - 1934.136 * t
    e = e0 + 0.00256 * numpy.cos(numpy.radians(omega))
    return e # in degrees



def calcSunRtAscension( t ):
    """
Calculate the right ascension of the sun (in degrees)
    """
    e = calcObliquityCorrection(t)
    SunLong = calcSunApparentLong(t)
    tananum = ( numpy.cos(numpy.radians(e)) * numpy.sin(numpy.radians(SunLong)) )
    tanadenom = numpy.cos(numpy.radians(SunLong))
    alpha = numpy.degrees(anumpy.arctan2(tananum, tanadenom))
    return alpha # in degrees



def calcSunDeclination( t ):
    """
Calculate the declination of the sun (in degrees)
    """
    e = calcObliquityCorrection(t)
    SunLong = calcSunApparentLong(t)
    sint = numpy.sin(numpy.radians(e)) * numpy.sin(numpy.radians(SunLong))
    theta = numpy.degrees(numpy.arcsin(sint))
    return theta # in degrees



def calcEquationOfTime( t ):
    """
Calculate the difference between true solar time and mean solar time (output: equation of time in minutes of time)  
    """
    epsilon = calcObliquityCorrection(t)
    l0 = calcGeomMeanLongSun(t)
    e = calcEccentricityEarthOrbit(t)
    m = calcGeomMeanAnomalySun(t)
    y = numpy.tan(numpy.radians(epsilon/2.0))
    y *= y

    sin2l0 = numpy.sin(numpy.radians(2.0 * l0))
    sinm   = numpy.sin(numpy.radians(m))
    cos2l0 = numpy.cos(numpy.radians(2.0 * l0))
    sin4l0 = numpy.sin(numpy.radians(4.0 * l0))
    sin2m  = numpy.sin(numpy.radians(2.0 * m))

    Etime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0 - 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m
    return numpy.degrees(Etime*4.0) # in minutes of time



def calcHourAngleSunrise( lat, solarDec ):
    """
Calculate the hour angle of the sun at sunrise for the latitude (in radians)
    """
    latRad = numpy.radians(lat)
    sdRad  = numpy.radians(solarDec)
    HAarg = numpy.cos(numpy.radians(90.833)) / ( numpy.cos(latRad)*numpy.cos(sdRad) ) - numpy.tan(latRad) * numpy.tan(sdRad)
    HA = numpy.arccos(HAarg);
    return HA # in radians (for sunset, use -HA)



def calcAzEl( t, localtime, latitude, longitude, zone ):
    """
Calculate sun azimuth and zenith angle
    """
    eqTime = calcEquationOfTime(t)
    theta  = calcSunDeclination(t)

    solarTimeFix = eqTime + 4.0 * longitude - 60.0 * zone
    earthRadVec = calcSunRadVector(t)

    trueSolarTime = localtime + solarTimeFix
    while trueSolarTime > 1440:
        trueSolarTime -= 1440.

    hourAngle = trueSolarTime / 4.0 - 180.0
    if hourAngle < -180.: 
        hourAngle += 360.0

    haRad = numpy.radians(hourAngle)
    csz = numpy.sin(numpy.radians(latitude)) * numpy.sin(numpy.radians(theta)) + numpy.cos(numpy.radians(latitude)) * numpy.cos(numpy.radians(theta)) * numpy.cos(haRad)
    if csz > 1.0: 
        csz = 1.0 
    elif csz < -1.0: 
        csz = -1.0
    zenith = numpy.degrees(numpy.arccos(csz))
    azDenom = numpy.cos(numpy.radians(latitude)) * numpy.sin(numpy.radians(zenith))
    if abs(azDenom) > 0.001: 
        azRad = (( numpy.sin(numpy.radians(latitude)) * numpy.cos(numpy.radians(zenith)) ) - numpy.sin(numpy.radians(theta))) / azDenom
        if abs(azRad) > 1.0: 
            if azRad < 0.: 
                azRad = -1.0 
            else:
                azRad = 1.0
        
        azimuth = 180.0 - numpy.degrees(numpy.arccos(azRad))
        if hourAngle > 0.0: 
            azimuth = -azimuth
    else:
        if latitude > 0.0: 
            azimuth = 180.0 
        else:
            azimuth = 0.0
    if azimuth < 0.0: 
        azimuth += 360.0
    exoatmElevation = 90.0 - zenith

    # Atmospheric Refraction correction
    if exoatmElevation > 85.0: 
        refractionCorrection = 0.0
    else:
        te = numpy.tan(numpy.radians(exoatmElevation))
        if exoatmElevation > 5.0: 
            refractionCorrection = 58.1 / te - 0.07 / (te*te*te) + 0.000086 / (te*te*te*te*te) 
        elif exoatmElevation > -0.575: 
            refractionCorrection = 1735.0 + exoatmElevation * (-518.2 + exoatmElevation * (103.4 + exoatmElevation * (-12.79 + exoatmElevation * 0.711) ) ) 
        else:
            refractionCorrection = -20.774 / te
        refractionCorrection = refractionCorrection / 3600.0

    solarZen = zenith - refractionCorrection
    
    return azimuth, solarZen



def calcSolNoonUTC( jd, longitude ):
    """
Calculate time of solar noon the given day at the given location on earth (in minute since 0 UTC)
    """
    tnoon = calcTimeJulianCent(jd)
    eqTime = calcEquationOfTime(tnoon)
    solNoonUTC = 720.0 - (longitude * 4.) - eqTime # in minutes
    return solNoonUTC



def calcSolNoon( jd, longitude, timezone, dst ):
    """
Calculate time of solar noon the given day at the given location on earth (in minute)
    """
    timeUTC    = calcSolNoonUTC(jd, longitude)
    newTimeUTC = calcSolNoonUTC(jd + timeUTC/1440.0, longitude)
    solNoonLocal = newTimeUTC + (timezone*60.0) # in minutes
    if dst: 
        solNoonLocal += 60.0
    return solNoonLocal



def calcSunRiseSetUTC( jd, latitude, longitude ):
    """
Calculate sunrise/sunset the given day at the given location on earth (in minute since 0 UTC)
    """
    t = calcTimeJulianCent(jd)
    eqTime = calcEquationOfTime(t)
    solarDec = calcSunDeclination(t)
    hourAngle = calcHourAngleSunrise(latitude, solarDec)
    # Rise time
    delta = longitude + numpy.degrees(hourAngle)
    riseTimeUTC = 720. - (4.0 * delta) - eqTime # in minutes
    # Set time
    hourAngle = -hourAngle
    delta = longitude + numpy.degrees(hourAngle)
    setTimeUTC = 720. - (4.0 * delta) - eqTime # in minutes
    return riseTimeUTC, setTimeUTC



def calcSunRiseSet( jd, latitude, longitude, timezone, dst ):
    """
Calculate sunrise/sunset the given day at the given location on earth (in minutes)
    """
    rtimeUTC, stimeUTC = calcSunRiseSetUTC(jd, latitude, longitude)
    # calculate local sunrise time (in minutes)
    rnewTimeUTC, snewTimeUTC = calcSunRiseSetUTC(jd + rtimeUTC/1440.0, latitude, longitude)
    rtimeLocal = rnewTimeUTC + (timezone * 60.0)
    rtimeLocal += 60.0 if dst else 0.0
    if rtimeLocal < 0.0 or rtimeLocal >= 1440.0: 
        jday = jd
        increment = 1. if rtimeLocal < 0. else -1.
        while rtimeLocal < 0.0 or rtimeLocal >= 1440.0:
            rtimeLocal += increment * 1440.0
            jday -= increment
    # calculate local sunset time (in minutes)
    rnewTimeUTC, snewTimeUTC = calcSunRiseSetUTC(jd + stimeUTC/1440.0, latitude, longitude)
    stimeLocal = snewTimeUTC + (timezone * 60.0)
    stimeLocal += 60.0 if dst else 0.0
    if stimeLocal < 0.0 or stimeLocal >= 1440.0: 
        jday = jd
        increment = 1. if stimeLocal < 0. else -1.
        while stimeLocal < 0.0 or stimeLocal >= 1440.0:
            stimeLocal += increment * 1440.0
            jday -= increment
    # return
    return rtimeLocal, stimeLocal



def calcTerminator( date, latitudes, longitudes ):
    """
Calculate terminator position and solar zenith angle for a given julian date-time within 
latitude/longitude limits
Note that for plotting only, basemap has a built-in terminator
    """
    jd = getJD(date)
    t = calcTimeJulianCent(jd)
    ut = ( jd - (int(jd - 0.5) + 0.5) )*1440.
    npoints = 50
    zen = numpy.zeros((npoints,npoints))
    lats = numpy.linspace(latitudes[0], latitudes[1], num=npoints)
    lons = numpy.linspace(longitudes[0], longitudes[1], num=npoints)
    term = []
    for ilat in range(1,npoints+1):
        for ilon in range(npoints):
            az,el = calcAzEl(t, ut, lats[-ilat], lons[ilon], 0.) 
            zen[-ilat,ilon] = el
        a = (90 - zen[-ilat,:])
        mins = numpy.r_[False, a[1:]*a[:-1] <= 0] | \
            numpy.r_[a[1:]*a[:-1] <= 0, False] 
        zmin = mins & numpy.r_[False, a[1:] < a[:-1]]
        if True in zmin:
            ll = numpy.interp(0, a[zmin][-1::-1], lons[zmin][-1::-1])
            term.append([lats[-ilat], ll])
        zmin = mins & numpy.r_[a[:-1] < a[1:], False]
        if True in zmin:
            ll = numpy.interp(0, a[zmin], lons[zmin])
            term.insert(0, [lats[-ilat], ll])
    return lats, lons, zen, numpy.array(term)



def getJD( date ):
    """
Calculate julian date for given day, month and year
    """
    from dateutil.relativedelta import relativedelta
    
    if date.month < 2: 
        date.replace(year=date.year-1)
        date += relativedelta(month=12)

    A = numpy.floor(date.year/100.)
    B = 2. - A + numpy.floor(A/4.)
    jd = numpy.floor(365.25*(date.year + 4716.)) + numpy.floor(30.6001*(date.month+1)) + date.day + B - 1524.5
    jd = jd + date.hour/24.0 + date.minute/1440.0 + date.second/86400.0
    return jd



import calcSun
from datetime import datetime
import Here
date = datetime.utcnow()
jd = calcSun.getJD( date )
latitude, longitude = Here.here()
print latitude, longitude

from datetime import date
nd = datetime.date(1917, 10, 16)
nt = datetime.time(19, 10, 16)
print nd, nt



from astral import *
a = Astral()
location = a['London']
timezone = location.timezone
from datetime import date
d = date(2009,4,22)
sun = location.sun(local=True, date=d)
s= str(sun['dawn'])

print s




import calcSun
from datetime import datetime
import Here
date = datetime.utcnow()
jd = calcSun.getJD( date )
latitude, longitude = Here.here()
#at the current time
now = datetime.utcnow()
calcSun.calcSunRiseSetUTC( jd, latitude, longitude )

import calcSun
from datetime import datetime

#evaluate on a 2 degree grid
lon  = linspace(-180,180,181)
lat = linspace(-90,90,91)
LON, LAT = meshgrid(lon,lat)
#at the current time
now = datetime.utcnow()

from astral import *
a = Astral()
location = a['Manila']
timezone = location.timezone
from datetime import date
d = date(2009,4,22)
sun = location.sun(local=True, date=d)
s= str(sun['dawn'])

print s

from astral import *
a = Astral()
location = a['Manila']
timezone = location.timezone
print timezone

from datetime import datetime
from pytz import timezone

fmt = "%Y-%m-%d %H:%M:%S %Z%z"
timezonelist = ['UTC','US/Pacific','Europe/Berlin']
for zone in timezonelist:

    now_time = datetime.now(timezone(zone))
    print now_time.strftime(fmt)

import TLE

def alt_lonlat(lon, lat, t):
    topo = earth + Topos(lat, lon)
    alt, az, dist = topo.at(trise).observe(sun).apparent().altaz() ## apparent() args for atmospheric refraction
    return alt.degrees

from skyfield.api import load, Topos
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as spo

data  = load('de421.bsp')
ts    = load.timescale()
# your example:  '2017-10-17', sunset = '10:00 PM', sunrise = '7:30 AM'
trise  = ts.utc(2017, 10, 27,  5, 30, 0)
tset   = ts.utc(2017, 10, 27, 6,  0, 0)

earth = data['earth']
sun   = data['sun']

zerozero = earth + Topos(0.0, 0.0)   # gotta start looking somewhere!
alt, az, dist = zerozero.at(trise).observe(sun).apparent().altaz() ## apparent() args for atmospheric refraction

print "at trise, JD = ", trise.tt
print "at (0N, 0E) Sun's altitude: ", alt.degrees, "azimuth: ", az.degrees
print "at (0N, 0E) Sun's distance (km): ", dist.km

# Find points on equator where sun is on horizon (rise or set) at t=trise
limits   = ((0, 180.), (180, 360.))
lonzeros = []
for a, b in limits:

    answer, info = spo.brentq(alt_lonlat, a, b,
                              args=(0.0, trise),
                              full_output = True )
    if info.converged:
        lonzeros.append(answer)
        print "limits ", a, b, " converged! Found longitude (deg): ", answer
    else:
        print "limits ", a, b, "whaaaa?"
        lonzeros.append(None)

# make some curves
lats = np.linspace(-60, 60, 13)
longis = []
for lon0 in lonzeros:
    lons = []
    for lat in lats:
        answer, info = spo.brentq(alt_lonlat, lon0-90, lon0+90,
                                  args=(lat, trise),
                                  full_output = True )
        if info.converged:
            lons.append(answer)
        else:
            lons.append(None)

        lons = [(lon+180)%360.-180 for lon in lons]  # wraparound at +/- 180
    longis.append(lons)
plt.figure()

for lons in longis:
    plt.plot(lons, lats)

for lons in longis:
    plt.plot(lons, lats, 'ok')

plt.xlim(-180, 180)
plt.ylim(-90, 90)

plt.title("at trise, JD = " + str(trise.tt))

plt.show()



https://chrisramsay.co.uk/posts/2017/03/fun-with-the-sun-and-pyephem/

# Import some bits
import Here
import ephem, math, datetime
x , y = Here.here()
# Get retina display quality for plots
%config InlineBackend.figure_format = 'retina'

home = ephem.Observer()
# Set up
#home.date = '2017-1-1 09:00:00'
home.lat = x
home.lon = y

home.date = '2017-10-15 09:00:00'
home.lat = '53.4975'
home.lon = '-0.3154'

home.elev

home.temp

home.pressure

sun = ephem.Sun()
sun.compute(home)

rising = home.previous_rising(sun).datetime()
print('Sunrise is at {}:{}:{}'.format(rising.hour, rising.minute, rising.second))

transit = home.next_transit(sun).datetime()
print('Local noon is at {}:{}:{}'.format(transit.hour, transit.minute, transit.second))

setting = home.next_setting(sun).datetime()
print('Sunset is at {}:{}:{}'.format(setting.hour, setting.minute, setting.second))


import matplotlib.pyplot as plt
import pandas as pd
import matplotlib
import ephem, math, datetime
matplotlib.style.use('ggplot')
home = ephem.Observer()
# Prepare
home.date = '2017/1/1'
sun = ephem.Sun()
times = []

def get_diff(tm):
    """Return a difference in seconds between tm and 12:00:00 on tm's date"""
    a = datetime.datetime.combine(tm, datetime.time(12, 0))
    return (a-tm).total_seconds()/60

# Prepare the data
for i in range(1, 368):
    home.date += ephem.Date(1)
    trans = home.next_transit(sun).datetime()
    times.append(get_diff(trans))

# Set up
ts = pd.Series(times, index=pd.date_range('2017/1/1', periods=len(times)))

ts.loc['2017-10-1':'2017-10-16']

ax = ts.plot()
ax.set_xlabel(u'Date', fontsize=11)
ax.set_ylabel(u'Variation (minutes)', fontsize=11)
plt.rcParams["figure.figsize"] = [9, 6]
plt.show()

# Prepare
home.date = '2017/10/15 9:00:00'
sun = ephem.Sun()
posx = []
posy = []

# Solstice altitude
phi = 90 - math.degrees(home.lat)
# Earth axial tilt
epsilon = 23.439

def get_sun_az(tm):
    """Get the azimuth based on a date"""
    sun.compute(tm)
    return math.degrees(sun.az)

def get_sun_alt(tm):
    """Get the altitude based on a date"""
    sun.compute(tm)
    return math.degrees(sun.alt)

# Prepare the data
for i in range(1, 368):
    home.date += ephem.Date(1)
    trans = home.next_transit(sun).datetime()
    posx.append(get_sun_az(home))
    posy.append(get_sun_alt(home))

# Set up
fig, ax = plt.subplots()
ax.plot(posx, posy)
ax.grid(True)
ax.set_xlabel(u'Azimuth (°)', fontsize=11)
ax.set_ylabel(u'Altitude (°)', fontsize=11)
# Add some labels, lines & resize
ax.annotate('Vernal equinox', xy=(min(posx), phi + 1), xytext=(min(posx), phi + 1))
ax.annotate('Autumnal equinox', xy=(max(posx) -2, phi + 1), xytext=(max(posx) -2, phi + 1))
ax.annotate('Nothern solstice', xy=(180.1, phi + epsilon + 1), xytext=(180.1, phi + epsilon + 1))
ax.annotate('Southern solstice', xy=(180.1, phi - epsilon - 2), xytext=(180.1, phi - epsilon - 2))
plt.plot((min(posx), max(posx)), (phi + epsilon, phi + epsilon), 'blue')
plt.plot((min(posx), max(posx)), (phi, phi), 'pink')
plt.plot((min(posx), max(posx)), (phi - epsilon, phi - epsilon), 'green')
plt.axvline(180, color='yellow')
plt.rcParams["figure.figsize"] = [12, 8]
plot_margin = 4
x0, x1, y0, y1 = plt.axis()
plt.axis((x0, x1, y0 - plot_margin, y1 + plot_margin))
plt.show()

# Prepare
home.date = '2017/10/15 09:00:00'
home.horizon = '0'
sun = ephem.Sun()
posy = []
posx = []

def get_sun_az(tm):
    """Get the azimuth based on a date"""
    sun.compute(tm)
    return math.degrees(sun.az)

def get_sun_alt(tm):
    """Get the altitude based on a date"""
    sun.compute(tm)
    return math.degrees(sun.alt)

# Prepare the data
for i in range(1, 368):
    home.date += ephem.Date(1)
    posy.append(get_sun_alt(home))
    posx.append(get_sun_az(home))

# Set up
fig, ax = plt.subplots()
ax.plot(posx, posy)
# Add some labels & resize
ax.set_xlabel(u'Azimuth (°)', fontsize=11)
ax.set_ylabel(u'Altitude (°)', fontsize=11)
plt.rcParams["figure.figsize"] = [9, 6]
# Fire
plt.show()



# Prepare
import Here
import ephem, math, datetime
x , y = Here.here()
# Get retina display quality for plots
%config InlineBackend.figure_format = 'retina'
home = ephem.Observer()
home.date = '2017/10/15 9:00:00'
moon = ephem.Moon()
posx = []
posy = []
# Solstice altitude
phi = 90 - math.degrees(home.lat)
# Earth axial tilt
epsilon = 23.439
def get_moon_az(tm):
    """Get the azimuth based on a date"""
    moon.compute(tm)
    return math.degrees(moon.az)
def get_moon_alt(tm):
    """Get the altitude based on a date"""
    moon.compute(tm)
    return math.degrees(moon.alt)
# Prepare the data
for i in range(1, 368):
    home.date += ephem.Date(1)
    trans = home.next_transit(moon).datetime()
    posx.append(get_moon_az(home))
    posy.append(get_moon_alt(home))
# Set up
fig, ax = plt.subplots()
ax.plot(posx, posy)
ax.grid(True)
ax.set_xlabel(u'Azimuth (°)', fontsize=11)
ax.set_ylabel(u'Altitude (°)', fontsize=11)
# Add some labels, lines & resize
ax.annotate('Vernal equinox', xy=(min(posx), phi + 1), xytext=(min(posx), phi + 1))
ax.annotate('Autumnal equinox', xy=(max(posx) -2, phi + 1), xytext=(max(posx) -2, phi + 1))
ax.annotate('Nothern solstice', xy=(180.1, phi + epsilon + 1), xytext=(180.1, phi + epsilon + 1))
ax.annotate('Southern solstice', xy=(180.1, phi - epsilon - 2), xytext=(180.1, phi - epsilon - 2))
plt.plot((min(posx), max(posx)), (phi + epsilon, phi + epsilon), 'blue')
plt.plot((min(posx), max(posx)), (phi, phi), 'pink')
plt.plot((min(posx), max(posx)), (phi - epsilon, phi - epsilon), 'green')
plt.axvline(180, color='yellow')
plot_margin = 4
x0, x1, y0, y1 = plt.axis()
plt.axis((x0, x1, y0 - plot_margin, y1 + plot_margin))
plt.rcParams["figure.figsize"] = [18, 12]
plt.show()

# Prepare
home.date = '2017/10/15 09:00:00'
home.horizon = '0'
moon = ephem.Moon()
posy = []
posx = []
def get_moon_az(tm):
    """Get the azimuth based on a date"""
    moon.compute(tm)
    return math.degrees(moon.az)
def get_moon_alt(tm):
    """Get the altitude based on a date"""
    moon.compute(tm)
    return math.degrees(moon.alt)
# Prepare the data
for i in range(1, 368):
    home.date += ephem.Date(1)
    posy.append(get_moon_alt(home))
    posx.append(get_moon_az(home))
# Set up
fig, ax = plt.subplots()
ax.plot(posx, posy)
# Add some labels & resize
ax.set_xlabel(u'Azimuth (°)', fontsize=11)
ax.set_ylabel(u'Altitude (°)', fontsize=11)
plt.rcParams["figure.figsize"] = [9, 6]
plt.show()

initial_set = home.next_setting(sun).datetime() # zero edge
next_set = home.next_setting(sun, use_center=True).datetime() # zero centre

print('Centre sunset is at {}:{}:{}'.format(next_set.hour, next_set.minute, next_set.second))
print('Edge sunset is at {}:{}:{}'.format(initial_set.hour, initial_set.minute, initial_set.second))

delta = initial_set - next_set
print('Time difference is {} mins, {} secs'.format(delta.seconds/60, delta.seconds%60))


http://www.tle.info/data/visual.txt

def get_setting_twilights(obs, body):
    """Returns a list of twilight datetimes in epoch format"""
    results = []
    # Twilights, their horizons and whether to use the centre of the Sun or not
    twilights = [('0', False), ('-6', True), ('-12', True), ('-18', True)]
    for twi in twilights:
        # Zero the horizon
        obs.horizon = twi[0]
        try:
            # Get the setting time and date
            now = obs.next_setting(body, use_center=twi[1]).datetime()
            # Get seconds elapsed since midnight
            results.append(
                (now - now.replace(hour=0, minute=0, second=0, microsecond=0)).total_seconds()
            )
        except ephem.AlwaysUpError:
            # There will be occasions where the sun stays up, make that max seconds
            results.append(86400.0)
    return results

home.horizon = '0'
twilights = get_setting_twilights(home, sun)
twilights

# Prepare
home.date = '2017/10/15 9:00:00'
home.horizon = '0'
sun = ephem.Sun()
twidataset = []

# Calculate just over a year of data
for i in range(1, 368):
    home.date += ephem.Date(1)
    twidataset.append(get_setting_twilights(home, sun))

twidataset[150:160]

df = pd.DataFrame(twidataset, columns=['Sunset', 'Civil', 'Nautical', 'Astronomical'])

df[275:375]

from matplotlib.ticker import FuncFormatter
import numpy as np

def timeformatter(x, pos):
    """The two args are the value and tick position"""
    return '{}:{}:{:02d}'.format(int(x/3600), int(x/24/60), int(x%60))

def dateformatter(x, pos):
    """The two args are the value and tick position"""
    dto = datetime.date.fromordinal(datetime.date(2017, 1, 1).toordinal() + int(x) - 1)
    return '{}-{:02d}'.format(dto.year, dto.month)

plt.rcParams["figure.figsize"] = [9, 6]
ax = df.plot.area(stacked=False, color=['#e60000', '#80ccff', '#33adff', '#008ae6'], alpha=0.2)
# Sort out x-axis
# Demarcate months
dim = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
ax.xaxis.set_ticks(np.cumsum(dim))
ax.xaxis.set_major_formatter(FuncFormatter(dateformatter))
ax.set_xlabel(u'Date', fontsize=11)
# Sort out y-axis
ax.yaxis.set_major_formatter(FuncFormatter(timeformatter))
ax.set_ylim([55000, 86400])
ax.set_ylabel(u'Time', fontsize=11)
labels = ax.get_xticklabels()
plt.setp(labels, rotation=30, fontsize=9)
# Done
plt.show()


df.loc[df['Sunset'] == 86400.0].head(1)

df.loc[df['Astronomical'] == 86400.0].tail(1)

# Prepare
home.date = '2017/10/15 9:00:00'
home.horizon = '0'
sun = ephem.Sun()


s_start = home.next_setting(sun, use_center=False).datetime()
s_start


home.horizon = '-0.53'
s_end = home.next_setting(sun, use_center=False).datetime()
s_end


delta = s_end - s_start
delta.total_seconds()

home.date = '2017/10/15 9:00:00'
settings = []
sun = ephem.Sun()
for i in range(1, 368):
    home.date += ephem.Date(1)
    home.horizon = '0'
    start = home.next_setting(sun, use_center=False).datetime()
    #width of the Sun in Degrees
    home.horizon = '-0.53'
    end = home.next_setting(sun, use_center=False).datetime()
    settings.append((end - start).total_seconds())
    
ts = pd.Series(settings, index=pd.date_range('2017/10/1', periods=len(settings)))

ts[0:12]

ts.max(), ts.min()

ts.max() - ts.min()

ax = ts.plot.area(alpha=0.2)
plt.rcParams["figure.figsize"] = [9, 6]
ax.set_xlabel(u'Date', fontsize=16)
ax.set_ylabel(u'Sunset length (seconds)', fontsize=11)
ax.set_ylim([math.floor(ts.min()) - 15, math.floor(ts.max()) + 15])
# Show Plot
plt.show()

Apogee = 29.94;Perigee = 33.66
Av = (Apogee+Perigee)/2
print Av

home.date = '2017/10/15 9:00:00'
settings = []
moon = ephem.Moon()
for i in range(1, 368):
    home.date += ephem.Date(1)
    home.horizon = '0'
    start = home.next_setting(moon, use_center=False).datetime()
    #Using the largest (perigee) width of the Moon in Degrees
    home.horizon = '-0.33.66'
    end = home.next_setting(moon, use_center=False).datetime()
    settings.append((end - start).total_seconds())
    
ts = pd.Series(settings, index=pd.date_range('2017/10/1', periods=len(settings)))

print "Longest  Moonset in seconds  : ",ts.max(),"\n",\
"Shortest Moonset in seconds : ",ts.min(),"\n",\
"Longest to the Shortest : ",ts.max() - ts.min()



ts[0:12]

ts.max() - ts.min()

ax = ts.plot.area(alpha=0.2)
plt.rcParams["figure.figsize"] = [9, 6]
ax.set_xlabel(u'Date', fontsize=11)
ax.set_ylabel(u'Moonset length (seconds)', fontsize=11)
ax.set_ylim([math.floor(ts.min()) - 15, math.floor(ts.max()) + 15])
# Show Plot
plt.show()

import Here
Here.here()

!mkdir mathbooks

import grab_pdfs
base_url='https://gist.githubusercontent.com/raylee/bd6c59d4fcd30baa5f77/raw/c20ec05dc4669b93f16d0b5c5824615dea42a956/springer-free-maths-books.md'
grab_pdfs.get_page(base_url)
get_all_links(html)

import os
import urllib

DOWNLOADS_DIR = 'mathbooks/'

# For every line in the file
for url in open('maths-booksnb.txt'):
    # Split on the rightmost / and take everything on the right side of that
    name = url.rsplit('', 1)[-1]

    # Combine the name and the downloads directory to get the local filename
    filename = os.path.join(DOWNLOADS_DIR, name)

    # Download the file if it does not exist
    if not os.path.isfile(filename):
        urllib.urlretrieve(url, filename)

import os
import urllib

DOWNLOADS_DIR = 'mathbooks/'

# For every line in the file
for url in open('maths-booksnb.txt'):
    # Split on the rightmost / and take everything on the right side of that
    name = url.rsplit('/', 1)[-1]

    # Combine the name and the downloads directory to get the local filename
    filename = os.path.join(DOWNLOADS_DIR, name)

    # Download the file if it does not exist
    if not os.path.isfile(filename):
        urllib.urlretrieve(url, filename)

import requests


links = ['https://www.fizyka.umk.pl/wfaiis/files/06_PyEphem.pdf']
for link in links:
    book_name = link.split('/')[-1]
    with open('PyEphem_swedish.pdf', 'wb') as book:
        a = requests.get(link, stream=True)

        for block in a.iter_content(512):
            if not block:
                break

            book.write(block)

!wget -O book.pdf http://link.springer.com/content/pdf/10.1007/978-1-4684-9936-0.pdf

from os import path
from urllib import urlretrieve
from urlparse import urlparse

src_url = 'http://link.springer.com/content/pdf/10.1007/978-1-4684-9936-0.pdf'
tgt_path = 'mathbooks/978-1-4684-9936-0.pdf'
urlretrieve(src_url, tgt_path)

import argparse

parser = argparse.ArgumentParser()
parser.add_argument("url", help="The base page where to search for PDF files.")
parser.add_argument("path", help="Where to save the files")
parser.add_argument("--create-directory", "-p", action="store_true", help="Create the directory if it does not exist")
locals().update(vars(parser.parse_args()))
if not os.path.isdir(path):
    if create_directory:
        os.makedirs(path)
    else:
        raise OSError("Directory {} does not exist. Use the '-p' flag to create it".format(path))

import os
import urllib

DOWNLOADS_DIR = '/python-downloader/downloaded'

# For every line in the file
for url in open('urls.txt'):
    # Split on the rightmost / and take everything on the right side of that
    name = url.rsplit('/', 1)[-1]

    # Combine the name and the downloads directory to get the local filename
    filename = os.path.join(DOWNLOADS_DIR, name)

    # Download the file if it does not exist
    if not os.path.isfile(filename):
        urllib.urlretrieve(url, filename)

from os import path
from urllib import urlretrieve
from urlparse import urlparse

src_url = 'http://path/to/document.pdf'
tgt_path = path.split(urlparse(src_url).path)[-1]
urlretrieve(src_url, tgt_path)

import requests


links = ['https://www.ics.uci.edu/%7Egopi/CS211B/opengl_programming_guide_8th_edition.pdf']
for link in links:
    book_name = link.split('/')[-1]
    with open(book_name, 'wb') as book:
        a = requests.get(link, stream=True)

        for block in a.iter_content(512):
            if not block:
                break

            book.write(block)

from pattern.web import URL

url = URL('http://query.nytimes.com/mem/archive-free/pdf?res=9A00EEDE1431E13BBC4850DFBF66838A649FDE')
f = open('nytimes.pdf', 'wb')
f.write(url.download(cached=False))
f.close()

import grab_pdfs
import sys
from requests import get
from urlparse import urljoin
from os import path, getcwd
from bs4 import BeautifulSoup as soup
from sys import argv
base_url='http://jacknorthrup.com/PDF.html'
grab_pdfs.get_page(base_url)

base_dir = "/home/jack/Desktop/text_stuff/mathbooks"
grab_pdfs.get_pdf(base_url, base_dir)
get_page('http://jacknorthrup.com/PDF.html')
get_pdf(base_url, base_dir)
#!python grab_pdfs.py base_url, base_dir

%tb

def get_pdf(base_url, base_dir):
    html= get_page()
    links= get_all_links(html)
    if len(links)==0:
        raise Exception('No links found on the webpage')
    n_pdfs= 0
    for link in links:
        if link['href'][-4:]=='.pdf':
            n_pdfs+= 1
            content= get(urljoin(base_url, link['href']))
            if content.status==200 and content.headers['content-type']=='application/pdf':
                with open(path.join(base_dir, link.text+'.pdf'), 'wb') as pdf:
                    pdf.write(content.content)
    if n_pdfs==0:
        raise Exception('No pdfs found on the page')
    print "{0} pdfs downloaded and saved in {1}".format(n_pdfs, base_dir)

    
base_dir = "/home/jack/Desktop/text_stuff/mathbooks"
base_url='http://jacknorthrup.com/PDF.html'
html = 'http://jacknorthrup.com/PDF.html'
get_pdf(base_url, base_dir)    

import requests
try:
    import urllib2
    from bs4 import BeautifulSoup
    from time import sleep
    import os
    import sys
    from time import sleep
except ImportError:
    print "ImportError !"
url = 'http://jacknorthrup.com/PDFshort.html'
path = "mathbooks/"


headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36'}
request = urllib2.Request(url,None,headers)
html = urllib2.urlopen(request)
soup = BeautifulSoup(html.read(), "html.parser")
soup.prettify()
#modifying the url for concatonation with 
url =  url.split('/') 
del url[-1]
url.append('')
url = '/'.join(url)
urls = []
names = []
for anchor in soup.findAll('a', href=True): #Going inside links
    req = urllib2.Request(anchor['href'],None,headers)
    pag = urllib2.urlopen(req)
    pgf = pag.read()
    soup1 = BeautifulSoup(pgf, "html.parser")
    for i, link in enumerate(soup1.findAll('a')): # Download all pdf inside each link
        fullurl = url + str(link.get('href'))
        print fullurl


import requests
try:
    import urllib2
    from bs4 import BeautifulSoup
    from time import sleep
    import os
    import sys
    from time import sleep
except ImportError:
    print "ImportError !"
url = 'http://jacknorthrup.com/PDF.html'
path = "mathbooks/"


headers = {'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36'}
request = urllib2.Request(url,None,headers)
html = urllib2.urlopen(request)
soup = BeautifulSoup(html.read(), "html.parser")
soup.prettify()
#modifying the url for concatonation with 
url =  url.split('/') 
del url[-1]
url.append('')
url = '/'.join(url)
urls = []
names = []
for anchor in soup.findAll('a', href=True): #Going inside links
    req = urllib2.Request(anchor['href'],None,headers)
    pag = urllib2.urlopen(req)
    pgf = pag.read()
    soup1 = BeautifulSoup(pgf, "html.parser")
    for i, link in enumerate(soup1.findAll('a')): # Download all pdf inside each link
        fullurl = url + str(link.get('href'))
        #print fullurl

        if fullurl.endswith('.pdf'):
            #print fullurl
            urls.append(fullurl)
            names.append(soup1.select('a')[i].attrs['href'])

names_urls = zip(names, urls)
os.chdir(path)

for name, url1 in names_urls:
    try:
        if os.path.isfile(name):
            print name, "Already exists skipping..."
            pass
        else:
            links = [name]
            for link in links:
                book_name = link.split('/')[-1]
                with open(book_name, 'wb') as book:
                    a = requests.get(link, stream=True)

                    for block in a.iter_content(512):
                        if not block:
                            break

                        book.write(block)            

                        print name, "Downloaded"
    except:
        print name, "Failed to download"
        pass
    sleep(1)

import urllib
from urllib import urlretrieve
from time import sleep
import textract

with open("PDF.list") as pdfs:
    link_list = pdfs.readlines()
    for link in link_list:
        urlretrieve(link)
        
        # Open A PDF and Save as TEXT file
        # keywords read pdf as text , save pdf as text
        # pdf2txt , textract
        lines = textract.process(link)
        Tfile = open(link+".txt","a")
        Tfile.closed
        for line in lines.split("."):
            #line = line.replace(".",".\n")
            line = line.replace("	"," ")
            Tfile = open(link+".txt","a")
            Tfile.write(line)
            #print line
            Tfile.close()
            print link," :converted"

        

from time import sleep
# modules we're using (you'll need to download lxml)
import lxml.html, urllib2, urlparse
import sys
import urllib
from urllib import urlretrieve
# the url of the page you want to scrape
base_url = 'https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md#python'

# fetch the page
res = urllib2.urlopen(base_url)

# parse the response into an xml tree
tree = lxml.html.fromstring(res.read())

# construct a namespace dictionary to pass to the xpath() call
# this lets us use regular expressions in the xpath
ns = {'re': 'http://exslt.org/regular-expressions'}

# iterate over all <a> tags whose href ends in ".pdf" (case-insensitive)
for node in tree.xpath('//a[re:test(@href, "\.pdf$", "i")]', namespaces=ns):
    print urlparse.urljoin(base_url, node.attrib['href'])
    

%%writefile PDF.html
https://www.ics.uci.edu/%7Egopi/CS211B/opengl_programming_guide_8th_edition.pdf
https://www.math.upenn.edu/%7Ewilf/AlgoComp.pdf
http://cslibrary.stanford.edu/110/BinaryTrees.pdf
http://www-inst.eecs.berkeley.edu/%7Ecs61b/fa14/book2/data-structures.pdf
http://lib.mdp.ac.id/ebook/Karya%20Umum/Dsa.pdf
http://cslibrary.stanford.edu/103/LinkedListBasics.pdf
http://cslibrary.stanford.edu/105/LinkedListProblems.pdf
http://www.jjj.de/fxt/fxtbook.pdf
http://www.cs.cmu.edu/%7Erwh/theses/okasaki.pdf
http://igm.univ-mlv.fr/%7Emac/REC/text-algorithms.pdf
http://www.designofapproxalgs.com/book.pdf
http://cslibrary.stanford.edu/109/TreeListRecursion.pdf
http://www.ethoberon.ethz.ch/WirthPubl/CBEAll.pdf
http://lampwww.epfl.ch/%7Eschinz/thesis-final-A4.pdf
http://www.stack.nl/%7Emarcov/compiler.pdf
http://www.dcs.warwick.ac.uk/%7Ehugh/TTM/Database-Explorations-revision-2.pdf
http://public.dhe.ibm.com/software/dw/db2/express-c/wiki/Database_fundamentals.pdf
http://www.dcs.warwick.ac.uk/%7Ehugh/TTM/DTATRM.pdf
http://arxiv.org/pdf/1206.1754v2.pdf
http://www.csee.umbc.edu/csee/research/cadip/readings/IR.report.120600.book.pdf
http://ciml.info/dl/v0_9/ciml-v0_9-all.pdf
https://www.ics.uci.edu/%7Ewelling/teaching/ICS273Afall11/IntroMLBook.pdf
http://www.iro.umontreal.ca/%7Ebengioy/papers/ftml_book.pdf
http://www.math.stonybrook.edu/%7Eaknapp/download/a2-alg-inside.pdf
http://www.math.stonybrook.edu/%7Eaknapp/download/b2-alg-inside.pdf
http://www.cis.upenn.edu/%7Ejean/math-basics.pdf
http://ocw.mit.edu/ans7870/resources/Strang/Edited/Calculus/Calculus.pdf
http://home.iitk.ac.in/%7Earlal/book/mth202.pdf
http://ramanujan.math.trinity.edu/wtrench/texts/TRENCH_DIFF_EQNS_I.PDF
https://www.math.ucdavis.edu/%7Elinear/linear-guest.pdf
http://www.ii.uib.no/%7Emichal/und/i227/book/book.pdf
http://www.tec-it.com/download/PDF/Barcode_Reference_EN.pdf
https://d28rh4a8wq0iu5.cloudfront.net/bitcointech/readings/princeton_bitcoin_book.pdf
http://www.usingcsp.com/cspbook.pdf
http://openmymind.net/FoundationsOfProgramming.pdf
http://softwarebyrob.wpengine.netdna-cdn.com/assets/Software_by_Rob%20_How_to_Become_a%20_Programmer_1.0.pdf
http://florida.theorangegrove.org/og/file/49843a6a-9a9d-4bad-b4d4-d053f9cdf73e/1/InfoTechNetworkedEconomy.pdf
http://www.cse.buffalo.edu/%7Erapaport/Papers/phics.pdf
http://cslibrary.stanford.edu/102/PointersAndMemory.pdf
http://ocw.mit.edu/resources/res-6-004-principles-of-computer-system-design-an-introduction-spring-2009/online-textbook/part_ii_open_5_0.pdf
http://ai.stanford.edu/%7Enilsson/QAI/qai.pdf
http://hintjens.wdfiles.com/local--files/main%3Afiles/cc1pe.pdf
http://pages.di.unipi.it/ricci/501302.pdf
http://public.dhe.ibm.com/software/dw/db2/express-c/wiki/Getting_started_with_open_source_development_p2.pdf
http://artofcommunityonline.org/Art_of_Community_Second_Edition.pdf
http://www.nobius.org/%7Edbg/practical-file-system-design.pdf
http://www.cs.bham.ac.uk/%7Eexr/lectures/opsys/10_11/lectures/os-dev.pdf
http://download.red-gate.com/ebooks/DJRTD_eBook.pdf
http://ptgmedia.pearsoncmg.com/images/0131407333/downloads/0131407333.pdf
http://downloads.nakedobjects.net/resources/Pawson%20thesis.pdf
http://www.bon-method.com/book_print_a4.pdf
http://www.tac.mta.ca/tac/reprints/articles/22/tr22.pdf
https://www.cs.cmu.edu/%7Erwh/pfpl/2nded.pdf
http://carlos.bueno.org/optimization/mature-optimization.pdf
http://www.cs.uni.edu/%7Emccormic/4740/guide-c2ada.pdf
http://www.adapower.com/pdfs/AdaDistilled07-27-2003.pdf
http://www.ada-auth.org/standards/12rm/RM-Final.pdf
http://www.tutorialspoint.com/android/android_tutorial.pdf
http://blog.hit.edu.cn/jsx/upload/AT%EF%BC%86TAssemblyLanguage.pdf
http://mirror.unicorncloud.org/savannah-nongnu//pgubook/ProgrammingGroundUp-1-0-booksize.pdf
http://linux-training.be/linuxfun.pdf
http://cslibrary.stanford.edu/101/EssentialC.pdf
https://www.raspberrypi.org/magpi-issues/Essentials_C_v1.pdf
http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf
http://www.planetpdf.com/codecuts/pdfs/ooc.pdf
http://www.crasseux.com/books/ctut.pdf
https://www.exceptionnotfound.net/downloads/dailydesignpattern.pdf
http://ptgmedia.pearsoncmg.com/images/9780131879058/downloads/0131879057_Ezust_book.pdf
http://www.stroustrup.com/JSF-AV-rules.pdf
http://www.jjj.de/fxt/fxtbook.pdf
http://opendatastructures.org/ods-cpp.pdf
http://supertech.csail.mit.edu/cilk/manual-5.4.6.pdf
http://daly.axiom-developer.org/clojure.pdf
http://yusman.staff.gunadarma.ac.id/Downloads/files/33460/COBOL_Programming_Fundamental.pdf
http://open-cobol.sourceforge.net/guides/OpenCOBOL%20Programmers%20Guide.pdf
https://www.eecis.udel.edu/%7Ecavazos/cisc672/docs/cool-manual.pdf
http://www.nvidia.com/content/cudazone/download/OpenCL/NVIDIA_OpenCL_ProgrammingGuide.pdf
http://public.dhe.ibm.com/software/dw/db2/express-c/wiki/Getting_Started_with_DB2_Express_v9.7_p4.pdf
http://public.dhe.ibm.com/software/dw/db2/express-c/wiki/Getting_Started_with_IBM_Data_Studio_for_DB2_p3.pdf
http://public.dhe.ibm.com/software/dw/db2/express-c/wiki/Getting_Started_with_DB2_App_Dev_p2.pdf
http://ftp.icm.edu.pl/packages/fpc/docs-pdf/ref.pdf
https://www.gnu.org/software/emacs/manual/pdf/emacs.pdf
http://www.cs.indiana.edu/%7Egeobrown/book.pdf
http://www.erlang.org/download/erlang-book-part1.pdf
https://github.com/esl/erlang-handbook/raw/master/output/ErlangHandbook.pdf
http://www.erlang.org/download/armstrong_thesis_2003.pdf
http://www.itu.dk/courses/BPRD/E2009/plcsd-1-2.pdf
https://web.archive.org/web/20131209081736/http://media.developerforce.com/workbooks/HerokuPostgres_Workbooks_Web_Final.pdf
http://ficl.sourceforge.net/pdf/Forth_Primer.pdf
http://www.mpeforth.com/arena/ProgramForth.pdf
http://people.cs.vt.edu/%7Easandu/Deposit/Fortran95_notes.pdf
http://www.mrao.cam.ac.uk/%7Erachael/compphys/SelfStudyF95.pdf
https://github.com/pluralsight/git-internals-pdf/raw/master/drafts/peepcode-git.pdf
https://docs.gradle.org/current/userguide/userguide.pdf
http://grails.github.io/grails-doc/latest/guide/single.pdf
http://lintool.github.io/MapReduceAlgorithms/MapReduce-book-final.pdf
http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf
http://www.andres-loeh.de/ExploringGH.pdf
https://fldit-www.cs.uni-dortmund.de/%7Epeter/PS07/HR.pdf
http://hal3.name/docs/daume02yaht.pdf
http://everythingcomputerscience.com/books/RoadMapiOS.pdf
http://isabelle.in.tum.de/doc/tutorial.pdf
http://www.jsoftware.com/books/pdf/arithmetic.pdf
http://www.jsoftware.com/books/pdf/brief.pdf
http://www.jsoftware.com/books/pdf/calculus.pdf
http://www.jsoftware.com/books/pdf/cmc.pdf
http://www.jsoftware.com/books/pdf/easyj.pdf
http://www.jsoftware.com/books/pdf/expmath.pdf
http://www.mat.uniroma2.it/%7Epicard/SMC/didattica/materiali_did/Java/Java_3D/Java_3D_Programming.pdf
http://ptgmedia.pearsoncmg.com/images/0131478303/downloads/Iverson_book.pdf
http://dept.cs.williams.edu/%7Ebailey/JavaStructures/Book_files/JavaStructures.pdf
http://www.oracle.com/events/global/en/java-outreach/resources/java-a-beginners-guide-1720064.pdf
https://ptgmedia.pearsoncmg.com/images/013143697X/downloads/013143697X_book.pdf
http://nioframework.sourceforge.net/NIO_Paper.pdf
http://opendatastructures.org/ods-java.pdf
https://docs.oracle.com/javaee/6/tutorial/doc/javaeetutorial6.pdf
https://docs.oracle.com/javaee/7/JEETT.pdf
http://jasperreports.sourceforge.net/JasperReports-Ultimate-Guide-3.pdf
http://docs.spring.io/spring/docs/current/spring-framework-reference/pdf/spring-framework-reference.pdf
http://docs.spring.io/spring-boot/docs/current/reference/pdf/spring-boot-reference.pdf
http://media.wiley.com/product_ancillary/28/07645334/DOWNLOAD/all.pdf
http://markdaggett.com/images/ExpertJavaScript-ch6.pdf
http://nikhilm.github.io/uvbook/An%20Introduction%20to%20libuv.pdf
http://www.bogotobogo.com/DevOps/Jenkins/images/Intro_install/jenkins-the-definitive-guide.pdf
http://bogumilkaminski.pl/files/julia_express.pdf
https://tobi.oetiker.ch/lshort/lshort.pdf
http://pgfplots.sourceforge.net/TeX-programming-notes.pdf
http://download.openvz.org/doc/OpenVZ-Users-Guide.pdf
http://ptgmedia.pearsoncmg.com/imprint_downloads/informit/perens/0130091154.pdf
https://help.ubuntu.com/16.04/serverguide/serverguide.pdf
http://www.akkadia.org/drepper/cpumemory.pdf
http://franz.com/resources/educational_resources/cooper.book.pdf
http://www.civilized.com/files/lispbook.pdf
https://github.com/clojurians-org/lisp-ebook/blob/master/Successful%20Lisp%20How%20to%20Understand%20and%20Use%20Common%20Lisp%20-%20David%20B.%20Lamkins.pdf
http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf
http://www.science.smith.edu/%7Ejcardell/Courses/EGR326/Intro-to-MATLAB.pdf
http://www.maths.dundee.ac.uk/software/MatlabNotes.pdf
http://www.mercurylang.org/information/doc-release/user_guide.pdf
http://downloads.mysql.com/docs/mysql-tutorial-excerpt-5.5-en.pdf
http://info.neotechnology.com/rs/neotechnology/images/GraphDatabases.pdf
http://download.red-gate.com/ebooks/DotNet/Under_the_Hood_of_.NET_Management.pdf
http://publications.lib.chalmers.se/records/fulltext/155048.pdf
http://www.christof-strauch.de/nosqldbs.pdf
http://ssw.jku.at/Research/Books/Oberon2.pdf
http://www.openmp.org/mp-documents/OpenMP4.0.0.pdf
http://perlhacks.com/dmp.pdf
http://cslibrary.stanford.edu/108/EssentialPerl.pdf
http://greenteapress.com/thinkperl6/thinkperl6.pdf
http://book.cakephp.org/2.0/_downloads/en/CakePHPCookbook.pdf
https://www.drupal.org/files/tiny-book-of-rules.pdf
http://www.informit.com/content/images/013147149X/downloads/013147149X_book.pdf
https://symfony.com/pdf/Symfony_book_2.8.pdf
http://www.ravichaganti.com//blog/wp-content/uploads/2010/12/A%20layman's%20guide%20to%20PowerShell%202.0%20remoting-v2.pdf
http://www.jonathanmedd.net/wp-content/uploads/2010/09/PowerShell_2_One_Cmdlet_at_a_Time.pdf
http://www.gprolog.org/manual/gprolog.pdf
http://www.oreilly.com/programming/free/files/a-whirlwind-tour-of-python.pdf
http://biopython.org/DIST/docs/tutorial/Tutorial.pdf
http://www.itmaybeahack.com/book/oodesign-python-2.1/latex/BuildingSkillsinOODesign.pdf
http://www.itmaybeahack.com/book/python-2.6/latex/BuildingSkillsinPython.pdf
http://python.cs.southern.edu/pythonbook/pythonbook.pdf
http://ianozsvald.com/HighPerformancePythonfromTrainingatEuroPython2011_v0.2.pdf
http://www.oreilly.com/programming/free/files/how-to-make-mistakes-in-python.pdf
https://www.ida.liu.se/%7E732A47/literature/PythonBook.pdf
http://www.clips.ua.ac.be/sites/default/files/modeling-creativity.pdf
https://launchpadlibrarian.net/165489933/PracticalProgrammingPython2014.pdf
http://programmingcomputervision.com/downloads/ProgrammingComputerVision_CCdraft.pdf
http://www.kevinsheppard.com/images/0/09/Python_introduction.pdf
http://safehammad.com/downloads/python-idioms-2014-01-16.pdf
https://upload.wikimedia.org/wikipedia/commons/9/91/Python_Programming.pdf
https://media.readthedocs.org/pdf/django/1.5.x/django.pdf
https://media.readthedocs.org/pdf/django/1.7.x/django.pdf
https://media.readthedocs.org/pdf/django/1.9.x/django.pdf
https://media.readthedocs.org/pdf/django/1.10.x/django.pdf
http://cran.r-project.org/web/packages/IPSUR/vignettes/IPSUR.pdf
http://cran.r-project.org/doc/contrib/Faraway-PRA.pdf
http://www.columbia.edu/%7Ecjd11/charles_dimaggio/DIRE/resources/spatialEpiBook.pdf
http://www.columbia.edu/%7Ecjd11/charles_dimaggio/DIRE/resources/R/practicalsBookNoAns.pdf
http://www.burns-stat.com/pages/Tutor/R_inferno.pdf
http://www.cs.unca.edu/%7Ebruce/Fall14/360/RPiUsersGuide.pdf
https://www.raspberrypi.org/magpi-issues/Projects_Book_v1.pdf
http://www.oreilly.com/programming/free/files/why-rust.pdf
http://wstein.org/books/sagebook/sagebook.pdf
http://www.scala-lang.org/docu/files/ScalaTutorial.pdf
http://homepages.cwi.nl/%7Eai/MScThesis-A-Izmaylova.pdf
http://www.scala-lang.org/old/sites/default/files/FrederikThesis.pdf
http://www.scala-lang.org/docu/files/ScalaByExample.pdf
http://examples.oreilly.com/9781449339616-files/Scala_Cookbook_bonus_chapters.pdf
http://www.tutorialspoint.com/scala/scala_tutorial.pdf
http://simply.liftweb.net/Simply_Lift.pdf
http://download.red-gate.com/ebooks/SQL/defensive-database-programming.pdf
http://download.red-gate.com/ebooks/SQL/sql-server-execution-plans.pdf
http://download.red-gate.com/ebooks/SQL/eBOOK_SQLServerExecutionPlans_2Ed_G_Fritchey.pdf
http://www.pllab.riec.tohoku.ac.jp/smlsharp/smlIntroSlides.pdf
http://www.cs.cmu.edu/%7Erwh/isml/book.pdf
http://ptgmedia.pearsoncmg.com/images/0131855182/downloads/Nagel_book.pdf
https://developer.tizen.org/sites/default/files/blogs/tizenfordummiesmainchangelist.pdf
http://web.stanford.edu/class/cs124/kwc-unix-for-poets.pdf
http://hep.uchicago.edu/%7Etangjian/SVT_sub/FTK_ATLAS/AUX/vhdl-tutorial.pdf
http://www.truth.sk/vim/vimbook-OPL.pdf
https://web.archive.org/web/20130302172911/http://vim.runpaint.org/vim-recipes.pdf
http://restfulwebapis.org/RESTful_Web_Services.pdf

import sys
from requests import get
from urlparse import urljoin
from os import path, getcwd
from bs4 import BeautifulSoup as soup
from sys import argv
base_dir = "/home/jack/Desktop/text_stuff/mathbooks"
base_url='https://gist.githubusercontent.com/raylee/bd6c59d4fcd30baa5f77/raw/c20ec05dc4669b93f16d0b5c5824615dea42a956/springer-free-maths-books.md'
html = "https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md#python"
def get_page(base_url):
    req= get(base_url)
    if req.status_code==200:
        return req.text
    raise Exception('Error {0}'.format(req.status_code))

def get_all_links(html):
    bs= soup(html)
    links= bs.findAll('a')
    return links

def get_pdf(base_url, base_dir):
    html= get_page()
    links= get_all_links(html)
    if len(links)==0:
        raise Exception('No links found on the webpage')
    n_pdfs= 0
    for link in links:
        if link['href'][-4:]=='.pdf':
            n_pdfs+= 1
            content= get(urljoin(base_url, link['href']))
            if content.status==200 and content.headers['content-type']=='application/pdf':
                with open(path.join(base_dir, link.text+'.pdf'), 'wb') as pdf:
                    pdf.write(content.content)
    if n_pdfs==0:
        raise Exception('No pdfs found on the page')
    print "{0} pdfs downloaded and saved in {1}".format(n_pdfs, base_dir)

if __name__=='__main__':
    base_dir = "/home/jack/Desktop/text_stuff/mathbooks"
    if len(argv) not in (2, 3):
        print 'Error! Invalid arguments'
        print __doc__
        exit(-1)
    arg= ''
    url= argv[1]
    if len(argv)==3:
        arg= argv[2]
    base_dir= [getcwd(), arg][path.isdir(arg)]
    
    try:
        get_pdf(base_dir)
    except Exception, e:
        print e
#exit(-1)
#sys.exit()

from urllib.request import urlretrieve

for link in link_list:
    urlretrieve(link)

#%%writefile grab_pdfs.py
#!/usr/bin/env python

"""
Download all the pdfs linked on a given webpage
Usage -
    python grab_pdfs.py url <path/to/directory>
        url is required
        path is optional. Path needs to be absolute
        will save in the current directory if no path is given
        will save in the current directory if given path does not exist
Requires - requests >= 1.0.4
           beautifulsoup >= 4.0.0
Download and install using
    
    pip install requests
    pip install beautifulsoup4
"""

__author__= 'elssar <elssar@altrawcode.com>'
__license__= 'MIT'
__version__= '1.0.0'
import sys
from requests import get
from urlparse import urljoin
from os import path, getcwd
from bs4 import BeautifulSoup as soup
from sys import argv
base_dir = "/home/jack/Desktop/text_stuff/mathbooks"
base_url='https://gist.githubusercontent.com/raylee/bd6c59d4fcd30baa5f77/raw/c20ec05dc4669b93f16d0b5c5824615dea42a956/springer-free-maths-books.md'

def get_page(base_url):
    req= get(base_url)
    if req.status_code==200:
        return req.text
    raise Exception('Error {0}'.format(req.status_code))

def get_all_links("https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md#python"):
    bs= soup(html)
    links= bs.findAll('a')
    return links

def get_pdf(base_url, base_dir):
    html= get_page()
    links= get_all_links(html)
    if len(links)==0:
        raise Exception('No links found on the webpage')
    n_pdfs= 0
    for link in links:
        if link['href'][-4:]=='.pdf':
            n_pdfs+= 1
            content= get(urljoin(base_url, link['href']))
            if content.status==200 and content.headers['content-type']=='application/pdf':
                with open(path.join(base_dir, link.text+'.pdf'), 'wb') as pdf:
                    pdf.write(content.content)
    if n_pdfs==0:
        raise Exception('No pdfs found on the page')
    print "{0} pdfs downloaded and saved in {1}".format(n_pdfs, base_dir)

if __name__=='__main__':
    base_dir = "/home/jack/Desktop/text_stuff/mathbooks"
    if len(argv) not in (2, 3):
        print 'Error! Invalid arguments'
        print __doc__
        exit(-1)
    arg= ''
    url= argv[1]
    if len(argv)==3:
        arg= argv[2]
    base_dir= [getcwd(), arg][path.isdir(arg)]
    
    try:
        get_pdf(base_dir)
    except Exception, e:
        print e
#exit(-1)
#sys.exit()

from astral import Astral

city_name = 'London'

a = Astral()
a.solar_depression = 'civil'

city = a[city_name]
timezone = city.timezone


#>>> print('Latitude: %.02f; Longitude: %.02f\n' % \
#>>>     (city.latitude, city.longitude))
#Latitude: 51.60; Longitude: 0.08
import Here
x = float(Here.here()[0])
y = float(Here.here()[1])
dateandtime = '2017/10/15 9:00:00'
Astral.solar_azimuth(dateandtime, x, y)

import datetime
from astral import Astral
city_name = 'Manila'
a = Astral()
a.solar_depression = 'civil'
city = a[city_name]
timezone = city.timezone
print('Timezone: %s' % timezone)

import Here
x = float(Here.here()[0])
y = float(Here.here()[1])
print x,y

from astral import *
from datetime import date
import Here
x = float(Here.here()[0])
y = float(Here.here()[1])
a = Astral()
#location = Location(info = ('Manila', 'Philippines', 14.797424, 121.057481, 'Asia/Manila', 100))
location = Location(info = ('Manila', 'Philippines', x, y, 'Asia/Manila', 100))
location.timezone = 'Asia/Manila'
print('Information for %s' % location.name)
timezone = location.timezone
print('Timezone: %s' % timezone)
print('Latitude: %.02f; Longitude: %.02f' % (location.latitude, location.longitude))
year = 2017
print 'year -',year,'\n'
for month in [10]:
	for day in range(1,32):
		sun = location.sun(local=True, date=date(year, month, day))
		sunrise = sun['sunrise']
		sunset = sun['sunset']
		daylength = sunset - sunrise
		print('%d/%d/%d\tSunrise: %s\tSunset: %s\tDay Length: %s' % (
month, day, year, sunrise.strftime('%X'), sunset.strftime('%X'), daylength))

import datetime
import pytz
from pytz import timezone
from pyexiftool import exiftool
from astral import Astral

longitude_tag = 'Composite:GPSLongitude'
latitude_tag = 'Composite:GPSLatitude'
gps_date_tag = 'EXIF:GPSDateStamp'
gps_time_tag = 'EXIF:GPSTimeStamp'

def solar_info(gps_date, gps_time, timezone_name, lon, lat):
    """
    Returns sun elevation and sun azimuth for a given position at a given date and time
    Args:
        gps_date: Date as 'YYYY:MM:DD'
        gps_time: Time in UTC as 'HH:MM:SS.sss'
        timezone_name: Name of timezone, e.g. Africa/Johnannesburg
        lon: Longitude
        lat: Latitude

    Returns:
        (sun elevation, sun azimuth)
    """
    gps_date_split = gps_date.split(':')
    year = int(gps_date_split[0])
    month = int(gps_date_split[1])
    day = int(gps_date_split[2])
    gps_time_split = gps_time.split(':')
    hour = int(gps_time_split[0])
    minutes = int(gps_time_split[1])
    dt = datetime.datetime(year, month, day, hour, minutes, 0)
    utc_dt = pytz.timezone('UTC').localize(dt)
    sat_timezone = timezone(timezone_name)
    sat_dt = utc_dt.astimezone(sat_timezone)

    astral = Astral()
    sun_elevation = astral.solar_elevation(sat_dt, lat, lon)
    sun_azimuth = astral.solar_azimuth(sat_dt, lat, lon)

    return (sun_elevation, sun_azimuth)

def solar_info_for_file(filename, timezone_name):
    tags = [ longitude_tag, latitude_tag, gps_date_tag, gps_time_tag ]
    with exiftool.ExifTool() as et:
        metadata = et.get_tags(tags, filename)
        gps_date = metadata[gps_date_tag]
        gps_time = metadata[gps_time_tag]
        lon = metadata[longitude_tag]
        lat = metadata[latitude_tag]
        return solar_info(gps_date, gps_time, timezone_name, lon, lat)

sun_elevation, sun_azimuth = solar_info_for_file('003\\IMG_170228_085706_0719_RED.TIF', 'Africa/Johannesburg')
print('Sun elevation: {0:.1f}  Sun azimuth: {1:.1f}'.format(sun_elevation, sun_azimuth))

#%%writefile TLE.py
#!/usr/bin/python
# -*- coding: ascii -*-
import numpy as np
import pylab as plt
import ephem
import datetime
from skyfield.api import EarthSatellite
import SatInfo
a,b,c = SatInfo.reuse()
sat = EarthSatellite(b,c,a)
# Setup lat long of telescope
oxford = ephem.Observer()
oxford.lat = np.deg2rad(51.75)
oxford.long = np.deg2rad(-1.259)
oxford.date = datetime.datetime.now()

# Load Satellite TLE data.
l1 = 'VANGUARD 1'
l2 = '1 5U 58002B   17288.51066995 +.00000265 +00000-0 +31484-3 0  9993'
l3 = '2 5 034.2621 354.4712 1846789 281.0386 058.8921 10.84748461099264'

biif1 = ephem.readtle(b,c,a)

# Make some datetimes
midnight = datetime.datetime.replace(datetime.datetime.now(), hour=0)
dt  = [midnight + datetime.timedelta(minutes=20*x) for x in range(0, 24*3)]

# Compute satellite locations at each datetime
sat_alt, sat_az = [], []
for date in dt:
    oxford.date = date
    biif1.compute(oxford)
    sat_alt.append(np.rad2deg(biif1.alt))
    sat_az.append(np.rad2deg(biif1.az))

# Plot satellite tracks
plt.subplot(211)
plt.plot(dt, sat_alt)
plt.ylabel("Altitude (deg)")
plt.xticks(rotation=25)
plt.subplot(212)
plt.plot(dt, sat_az)
plt.ylabel("Azimuth (deg)")
plt.xticks(rotation=25)
plt.show()

# Plot satellite track in polar coordinates
plt.polar(np.deg2rad(sat_az), 90-np.array(sat_alt))
plt.ylim(0,90)
plt.show()
"""
..This script creates a pyEphem observer and a satellite object, computes the altitude and azimuth
..of the satellite as seen from the observer, and then plots the results. 
If you find the..datetime.datetime stuff confusing, I highly recommend Salty Crane?s cheat sheet...
After the script has run, you should see this polar plot of the satellite?s trajectory:..
Finally, here?s a simple function to read in a text file filled with TLE data:..
"""
def loadTLE(filename):
    """ Loads a TLE file and creates a list of satellites."""
    f = open(filename)
    satlist = []
    l1 = f.readline()
    while l1:
        l2 = f.readline()
        l3 = f.readline()
        sat = ephem.readtle(l1,l2,l3)
        satlist.append(sat)
        print sat.name
        l1 = f.readline()

    f.close()
    print "%i satellites loaded into list"%len(satlist)
    return satlist
loadTLE('ALL_TTL.TXT')

import TLE

http://blog.thetelegraphic.com/2012/gps-sattelite-tracking-in-python-using-pyephem/

from skyfield.api import JulianDate

jd = JulianDate(utc=(2017,10,15))

print jd.tt, "days"
print jd.tt % 1, "day fraction"
print ((jd.tt % 1) - 0.5) * 24. * 3600, "seconds"



#@title Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

!sudo apt -y install libportaudio2
!pip install tflite-model-maker

import tensorflow as tf
import tflite_model_maker as mm
from tflite_model_maker import audio_classifier
import os

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import itertools
import glob
import random

from IPython.display import Audio, Image
from scipy.io import wavfile

print(f"TensorFlow Version: {tf.__version__}")
print(f"Model Maker Version: {mm.__version__}")

birds_dataset_folder = tf.keras.utils.get_file('birds_dataset.zip',
                                                'https://storage.googleapis.com/laurencemoroney-blog.appspot.com/birds_dataset.zip',
                                                cache_dir='./',
                                                cache_subdir='dataset',
                                                extract=True)
                                                

# @title [Run this] Util functions and data structures.

data_dir = './dataset/small_birds_dataset'

bird_code_to_name = {
  'wbwwre1': 'White-breasted Wood-Wren',
  'houspa': 'House Sparrow',
  'redcro': 'Red Crossbill',  
  'chcant2': 'Chestnut-crowned Antpitta',
  'azaspi1': "Azara's Spinetail",   
}

birds_images = {
  'wbwwre1': 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/22/Henicorhina_leucosticta_%28Cucarachero_pechiblanco%29_-_Juvenil_%2814037225664%29.jpg/640px-Henicorhina_leucosticta_%28Cucarachero_pechiblanco%29_-_Juvenil_%2814037225664%29.jpg', # 	Alejandro Bayer Tamayo from Armenia, Colombia 
  'houspa': 'https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/House_Sparrow%2C_England_-_May_09.jpg/571px-House_Sparrow%2C_England_-_May_09.jpg', # 	Diliff
  'redcro': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/49/Red_Crossbills_%28Male%29.jpg/640px-Red_Crossbills_%28Male%29.jpg', #  Elaine R. Wilson, www.naturespicsonline.com
  'chcant2': 'https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Chestnut-crowned_antpitta_%2846933264335%29.jpg/640px-Chestnut-crowned_antpitta_%2846933264335%29.jpg', # 	Mike's Birds from Riverside, CA, US
  'azaspi1': 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/Synallaxis_azarae_76608368.jpg/640px-Synallaxis_azarae_76608368.jpg', # https://www.inaturalist.org/photos/76608368
}

test_files = os.path.abspath(os.path.join(data_dir, 'test/*/*.wav'))

def get_random_audio_file():
  test_list = glob.glob(test_files)
  random_audio_path = random.choice(test_list)
  return random_audio_path


def show_bird_data(audio_path):
  sample_rate, audio_data = wavfile.read(audio_path, 'rb')

  bird_code = audio_path.split('/')[-2]
  print(f'Bird name: {bird_code_to_name[bird_code]}')
  print(f'Bird code: {bird_code}')
  display(Image(birds_images[bird_code]))

  plttitle = f'{bird_code_to_name[bird_code]} ({bird_code})'
  plt.title(plttitle)
  plt.plot(audio_data)
  display(Audio(audio_data, rate=sample_rate))

print('functions and data structures created')

random_audio = get_random_audio_file()
show_bird_data(random_audio)

spec = audio_classifier.YamNetSpec(
    keep_yamnet_and_custom_heads=True,
    frame_step=3 * audio_classifier.YamNetSpec.EXPECTED_WAVEFORM_LENGTH,
    frame_length=6 * audio_classifier.YamNetSpec.EXPECTED_WAVEFORM_LENGTH)

train_data = audio_classifier.DataLoader.from_folder(
    spec, os.path.join(data_dir, 'train'), cache=True)
train_data, validation_data = train_data.split(0.8)
test_data = audio_classifier.DataLoader.from_folder(
    spec, os.path.join(data_dir, 'test'), cache=True)

batch_size = 128
epochs = 100

print('Training the model')
model = audio_classifier.create(
    train_data,
    spec,
    validation_data,
    batch_size=batch_size,
    epochs=epochs)

print('Evaluating the model')
model.evaluate(test_data)

def show_confusion_matrix(confusion, test_labels):
  """Compute confusion matrix and normalize."""
  confusion_normalized = confusion.astype("float") / confusion.sum(axis=1)
  axis_labels = test_labels
  ax = sns.heatmap(
      confusion_normalized, xticklabels=axis_labels, yticklabels=axis_labels,
      cmap='Blues', annot=True, fmt='.2f', square=True)
  plt.title("Confusion matrix")
  plt.ylabel("True label")
  plt.xlabel("Predicted label")

confusion_matrix = model.confusion_matrix(test_data)
show_confusion_matrix(confusion_matrix.numpy(), test_data.index_to_label)

serving_model = model.create_serving_model()

print(f'Model\'s input shape and type: {serving_model.inputs}')
print(f'Model\'s output shape and type: {serving_model.outputs}')

# if you want to try another file just uncoment the line below
random_audio = get_random_audio_file()
show_bird_data(random_audio)

sample_rate, audio_data = wavfile.read(random_audio, 'rb')

audio_data = np.array(audio_data) / tf.int16.max
input_size = serving_model.input_shape[1]

splitted_audio_data = tf.signal.frame(audio_data, input_size, input_size, pad_end=True, pad_value=0)

print(f'Test audio path: {random_audio}')
print(f'Original size of the audio data: {len(audio_data)}')
print(f'Number of windows for inference: {len(splitted_audio_data)}')

print(random_audio)

results = []
print('Result of the window ith:  your model class -> score,  (spec class -> score)')
for i, data in enumerate(splitted_audio_data):
  yamnet_output, inference = serving_model(data)
  results.append(inference[0].numpy())
  result_index = tf.argmax(inference[0])
  spec_result_index = tf.argmax(yamnet_output[0])
  t = spec._yamnet_labels()[spec_result_index]
  result_str = f'Result of the window {i}: ' \
  f'\t{test_data.index_to_label[result_index]} -> {inference[0][result_index].numpy():.3f}, ' \
  f'\t({spec._yamnet_labels()[spec_result_index]} -> {yamnet_output[0][spec_result_index]:.3f})'
  print(result_str)


results_np = np.array(results)
mean_results = results_np.mean(axis=0)
result_index = mean_results.argmax()
print(f'Mean result: {test_data.index_to_label[result_index]} -> {mean_results[result_index]}')

models_path = './birds_models'
print(f'Exporing the TFLite model to {models_path}')

model.export(models_path, tflite_filename='my_birds_model.tflite')

model.export(models_path, export_format=[mm.ExportFormat.SAVED_MODEL, mm.ExportFormat.LABEL])

info = open("list.html", "r").read()
print(info)

!pwd

AustralianAnimals = []
info1 = info.replace("<h1>","xxx\n<h1>")
info2 = info1.replace("</h1>","</h1>\nxxx")
info3 = info2.split("\n")
for line in info3:
    if "<h2>" in line and "span" not in line and "<br>" not in line:
        line = line.replace("<h2>","")
        line = line.replace("</h2>","")
        #print (line)
        AustralianAnimals.append(line)

import re

#Split the string at every white-space character:
txt = "The rain in Spain"
x = re.split("\s", txt)
print(x)

[x.group() for x in re.finditer( r'h (.*?) h', info)]
# Output: ['all cats are', 'all dogs are']

print(AustralianAnimals)

import re
s = info
pattern = "<h1>(.*?)</h2>"

substring = re.search(pattern, s).group(1)
print(substring)

import re
sequence = 'aaabbbaaacccdddeeefff'
query = 'aaa'
r = re.compile(query)
[[m.start(),m.end()] for m in r.finditer(sequence)]

import re
start = '<h1>'
end = '</h1>'
s = info
txt= re.findall(start)+len(start),s


print(txt)

# Open file
count=0
f = info
lines = f.split("\n")
for line in lines:
    count=count+1
    if "h1" in line:
        print("\n",count,line,"\n")

    

# Open file
count=0
f = open('list.html', 'r').read()
lines = f.split("\n")
for line in lines:
    if "<h1>" in line:
            count=count+1
            print("\n",count,line,"\n")

    

#[x.group() for x in re.finditer(r'{.*}', s)]
[x.group() for x in re.finditer(r'<h1>.*', s)]

result = re.findall(r'var="(.*?)"', test)
print(result)  # ['this', 'that']

re.findall( r'h1 (.*?) h1', s)
# Output: ['cats', 'dogs']

re.findall( r'all (.*?) are', 'all cats are smarter than dogs, all dogs are dumber than cats')
# Output: ['cats', 'dogs']

[x.group() for x in re.finditer( r'all (.*?) are', 'all cats are smarter than dogs, all dogs are dumber than cats')]
# Output: ['all cats are', 'all dogs are']

s = info

def find_between( s, first, last ):
    try:
        start = s.index( first ) + len( first )
        end = s.index( last, start )
        return s[start:end]
    except ValueError:
        return ""

def find_between_r( s, first, last ):
    try:
        start = s.rindex( first ) + len( first )
        end = s.rindex( last, start )
        return s[start:end]
    except ValueError:
        return ""


print (find_between( s, "<h1>", "</h1>" ))
print (find_between_r( s, "<h1>", "</h1>" ))

cnt=0
info1 = info.split("\n")
for line in info1:
    cnt=cnt+1
    if "<h1>" in line: # and "</h1>" in line:
        print(cnt,line,"\n")

str = '<h1>purple</h1> alice-b@google.com monkey <h1>dishwasher</h1> alice-b@google.com monkey dishwasher'


str = '<h1>purple</h1> alice-b@google.com monkey <h1>dishwasher</h1> alirce -b@google.com monkey dishwasher'
match = re.search(r'\w+r\w+', str)
if match:
    print(match.group())  ## 'b@google'

import re

str = 'an example word:cat!!'
match = re.search(r'word:\w\w\w', str)
# If-statement after search() tests if it succeeded
if match:
    print('found', match.group()) ## 'found word:cat'
else:
    print('did not find')

import re

str = info
match = re.search(r'word:Animal', str)
# If-statement after search() tests if it succeeded
if match:
    print('found', match.group()) ## 'found word:cat'
else:
    print('did not find')

match = re.search("h1", s)
for mat in match:
    print (mat)



#@title Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import tensorflow as tf

@tf.function(input_signature=[
    tf.TensorSpec(shape=[None], dtype=tf.float32)
])
def f(x):
  return tf.cosh(x)

# Evaluate the tf.function
result = f(tf.constant([0.0]))
print (f"result = {result}")

# Convert the tf.function
converter = tf.lite.TFLiteConverter.from_concrete_functions(
    [f.get_concrete_function()], f)
try:
  fb_model = converter.convert()
except Exception as e:
  print(f"Got an exception: {e}")

@tf.lite.experimental.authoring.compatible
@tf.function(input_signature=[
    tf.TensorSpec(shape=[None], dtype=tf.float32)
])
def f(x):
  return tf.cosh(x)

# Evaluate the tf.function
result = f(tf.constant([0.0]))
print (f"result = {result}")


compatibility_log = '\n'.join(f.get_compatibility_log())
print (f"compatibility_log = {compatibility_log}")

@tf.lite.experimental.authoring.compatible(raise_exception=True)
@tf.function(input_signature=[
    tf.TensorSpec(shape=[None], dtype=tf.float32)
])
def f(x):
  return tf.cosh(x)

# Evaluate the tf.function
try:
  result = f(tf.constant([0.0]))
  print (f"result = {result}")
except Exception as e:
  print(f"Got an exception: {e}")

target_spec = tf.lite.TargetSpec()
target_spec.supported_ops = [
    tf.lite.OpsSet.TFLITE_BUILTINS,
    tf.lite.OpsSet.SELECT_TF_OPS,
]
@tf.lite.experimental.authoring.compatible(converter_target_spec=target_spec, raise_exception=True)
@tf.function(input_signature=[
    tf.TensorSpec(shape=[None], dtype=tf.float32)
])
def f(x):
  return tf.cosh(x)

# Evaluate the tf.function
result = f(tf.constant([0.0]))
print (f"result = {result}")


target_spec = tf.lite.TargetSpec()
target_spec.supported_ops = [
    tf.lite.OpsSet.TFLITE_BUILTINS,
    tf.lite.OpsSet.SELECT_TF_OPS,
]
target_spec.experimental_supported_backends = ["GPU"]
@tf.lite.experimental.authoring.compatible(converter_target_spec=target_spec)
@tf.function(input_signature=[
    tf.TensorSpec(shape=[4, 4], dtype=tf.float32)
])
def func(x):
  y = tf.cosh(x)
  return y + tf.slice(x, [1, 1], [1, 1])

result = func(tf.ones(shape=(4,4), dtype=tf.float32))

%%writefile auto_canny.py
# import the necessary packages
import numpy as np
import argparse
import glob
import cv2
def auto_canny(image, sigma=0.33):
	# compute the median of the single channel pixel intensities
	v = np.median(image)
	# apply automatic Canny edge detection using the computed median
	lower = int(max(0, (1.0 - sigma) * v))
	upper = int(min(255, (1.0 + sigma) * v))
	edged = cv2.Canny(image, lower, upper)
	# return the edged image
	return edged

# construct the argument parse and parse the arguments
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--images", required=True,
	help="path to input dataset of images")
args = vars(ap.parse_args())
# loop over the images
for imagePath in glob.glob(args["images"] + "/*.jpg"):
	# load the image, convert it to grayscale, and blur it slightly
	image = cv2.imread(imagePath)
	gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
	blurred = cv2.GaussianBlur(gray, (3, 3), 0)
	# apply Canny edge detection using a wide threshold, tight
	# threshold, and automatically determined threshold
	wide = cv2.Canny(blurred, 10, 200)
	tight = cv2.Canny(blurred, 225, 250)
	auto = auto_canny(blurred)
	# show the images
	cv2.imshow("Original", image)
	cv2.imshow("Edges", np.hstack([wide, tight, auto]))
	cv2.waitKey(0)


import numpy as np
import argparse
import glob
import cv2
import imageio
def auto_canny(image, sigma=0.33):
	# compute the median of the single channel pixel intensities
	v = np.median(image)
	# apply automatic Canny edge detection using the computed median
	lower = int(max(0, (1.0 - sigma) * v))
	upper = int(min(255, (1.0 + sigma) * v))
	edged = cv2.Canny(image, lower, upper)
	# return the edged image
	return edged


#note7
from PIL import Image
import numpy as np
import cv2
import imageio
from FileNameP import FilenameByTime


def auto_canny(image, sigma=0.33):
    # compute the median of the single channel pixel intensities
    v = np.median(image)
    # apply automatic Canny edge detection using the computed median
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)
    # return the edged image
    return edged

#image = cv2.imread('mahotastest/orig-color.png')
filename1 = '/home/jack/Desktop/Imagedata/0-original-images/07082orig.jpg'
image = cv2.imread(filename1)
edged = auto_canny(image, sigma=0.33)
inverted = cv2.bitwise_not(edged)
cv2.imwrite("mahotastest/temp2.png", inverted)
cv2.imwrite(FilenameByTime("mahotastest/"), inverted)



# Open Front Image
#frontimage = Image.open('mahotastest/inverted-bitwise-note3_6.png').convert("1")
frontimage = Image.open('mahotastest/temp2.png').convert("1")
frontImage = frontimage.convert("RGBA")
datas = frontImage.getdata()


newData = []
for item in datas:
    if item[0] == 255 and item[1] == 255 and item[2] == 255:
        newData.append((255, 255, 255, 0))
    else:
        newData.append(item)

frontImage.putdata(newData)
#frontImage.save("mahotastest/frontImage-note7.png", "PNG")

# Back Image
#image = cv2.imread('mahotastest/orig-color.png')
#filename1 = '/home/jack/Desktop/Imagedata/0-original-images/05140orig.jpg'
# Open Background Image
background = Image.open(filename1)
#background = cv2.imread('mahotastest/orig-color.png')#.convert("RGBA")

# Convert image to RGBA
#frontImage = frontImage.convert("RGBA")

# Convert image to RGBA
#background = background.convert("RGBA")

# Calculate width to be at the center
width = (frontimage.width - frontimage.width) // 2

# Calculate height to be at the center
height = (frontimage.height - frontimage.height) // 2

# Paste the frontImage at (width, height)
background.paste(frontImage, (width, height), frontImage)

# Save this image
background.save("mahotastest/-atlast000.png", format="png")
savefile = FilenameByTime("mahotastest/")
background.save(savefile, format="png")
#background = background.convert("RGB")

%%writefile OutlineImage.py
"""
USE:
from OutlineImage import *
orig_file = "junk/00000.jpg"
new_extension = ".jnk"
NEW = change_extension(orig_file,new_extension)
print(NEW)

filename1 = '/home/jack/Desktop/Imagedata/0-original-images/07082orig.jpg' 
outfile_png = '/home/jack/Desktop/dockercommands/images/useresult.png'
outlineJ(filename1,outfile_jpg)
outlineP(filename1,outfile_png)

"""
from PIL import Image
import numpy as np
import cv2
import imageio
from FileNameP import FilenameByTime
from pathlib import Path as change_ext
#p = change_ext('mysequence.jpg')
#p.rename(p.with_suffix('.png'))

def auto_canny(image, sigma=0.33):
    # compute the median of the single channel pixel intensities
    v = np.median(image)
    # apply automatic Canny edge detection using the computed median
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)
    # return the edged image
    return edged

#image = cv2.imread('mahotastest/orig-color.png')
def change_extension(orig_file,new_extension):
    p = change_ext(orig_file)
    new_name = p.rename(p.with_suffix(new_extension))
    return new_name
    
def outlineJ(filename1,outfile_jpg):
    image = cv2.imread(filename1)
    edged = auto_canny(image, sigma=0.33)
    inverted = cv2.bitwise_not(edged)
    cv2.imwrite("mahotastest/temp2.png", inverted)
    cv2.imwrite(FilenameByTime("mahotastest/"), inverted)
    # Open Front Image
    #frontimage = Image.open('mahotastest/inverted-bitwise-note3_6.png').convert("1")
    frontimage = Image.open('mahotastest/temp2.png').convert("1")
    frontImage = frontimage.convert("RGBA")
    datas = frontImage.getdata()
    newData = []
    for item in datas:
        if item[0] == 255 and item[1] == 255 and item[2] == 255:
            newData.append((255, 255, 255, 0))
        else:
            newData.append(item)

    frontImage.putdata(newData)
    # Open Background Image
    background = Image.open(filename1)
    # Calculate width to be at the center
    width = (frontimage.width - frontimage.width) // 2
    # Calculate height to be at the center
    height = (frontimage.height - frontimage.height) // 2
    # Paste the frontImage at (width, height)
    background.paste(frontImage, (width, height), frontImage)
    # Save this image
    background.save(outfile_jpg, format="jpg")
    savefile = FilenameByTime("mahotastest/")
    background.save(savefile, format="jpg")
    #background = background.convert("RGB")
    return background
def outlineP(filename1,outfile_png):
    image = cv2.imread(filename1)
    edged = auto_canny(image, sigma=0.33)
    inverted = cv2.bitwise_not(edged)
    cv2.imwrite("mahotastest/temp2.png", inverted)
    cv2.imwrite(FilenameByTime("mahotastest/"), inverted)
    # Open Front Image
    #frontimage = Image.open('mahotastest/inverted-bitwise-note3_6.png').convert("1")
    frontimage = Image.open('mahotastest/temp2.png').convert("1")
    frontImage = frontimage.convert("RGBA")
    datas = frontImage.getdata()
    newData = []
    for item in datas:
        if item[0] == 255 and item[1] == 255 and item[2] == 255:
            newData.append((255, 255, 255, 0))
        else:
            newData.append(item)

    frontImage.putdata(newData)
    # Open Background Image
    background = Image.open(filename1)
    # Calculate width to be at the center
    width = (frontimage.width - frontimage.width) // 2
    # Calculate height to be at the center
    height = (frontimage.height - frontimage.height) // 2
    # Paste the frontImage at (width, height)
    background.paste(frontImage, (width, height), frontImage)
    # Save this image
    background.save(outfile_png, format="png")
    savefile = FilenameByTime("mahotastest/")
    background.save(savefile, format="png")
    #background = background.convert("RGB")
    return background

!ls junk

from OutlineImage import *
orig_file = "junk/00000.jpg"
new_extension = ".jnk"
NEW = change_extension(orig_file,new_extension)
print(NEW)

import OutlineImage
import cv2
filename1 = '/home/jack/Documents/FezEqP0XEAE4JdSl.jpg'
image = cv2.imread(filename1)
imout = OutlineImage.auto_canny(image)
cv2.imwrite('/home/jack/Documents/XXFezEqP0XEAE4JdSl.jpg', imout)

from OutlineImage import outlineP
#filename1 = '/home/jack/Desktop/Imagedata/textured-images/RANDOM-smoothness25.91-threshhold4_20220922230108.jpg' 
filename1 = '/home/jack/Documents/FezEqP0XEAE4JdSl.jpg'
outfileP = '/home/jack/Desktop/dockercommands/images/useresult25.png'
outlineP(filename1,outfileP)

from PIL import Image
im = Image.open(outfileP)
im

from PIL import Image
im = Image.open(savefile)
im

from PIL import Image
im = Image.open(filename1)
im



%%writefile auto_canny.py
# import the necessary packages
import numpy as np
import argparse
import glob
import cv2
def auto_canny(image, sigma=0.33):
	# compute the median of the single channel pixel intensities
	v = np.median(image)
	# apply automatic Canny edge detection using the computed median
	lower = int(max(0, (1.0 - sigma) * v))
	upper = int(min(255, (1.0 + sigma) * v))
	edged = cv2.Canny(image, lower, upper)
	# return the edged image
	return edged

# construct the argument parse and parse the arguments
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--images", required=True,
	help="path to input dataset of images")
args = vars(ap.parse_args())
# loop over the images
for imagePath in glob.glob(args["images"] + "/*.jpg"):
	# load the image, convert it to grayscale, and blur it slightly
	image = cv2.imread(imagePath)
	gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
	blurred = cv2.GaussianBlur(gray, (3, 3), 0)
	# apply Canny edge detection using a wide threshold, tight
	# threshold, and automatically determined threshold
	wide = cv2.Canny(blurred, 10, 200)
	tight = cv2.Canny(blurred, 225, 250)
	auto = auto_canny(blurred)
	# show the images
	cv2.imshow("Original", image)
	cv2.imshow("Edges", np.hstack([wide, tight, auto]))
	cv2.waitKey(0)


import numpy as np
import argparse
import glob
import cv2
import imageio
def auto_canny(image, sigma=0.33):
	# compute the median of the single channel pixel intensities
	v = np.median(image)
	# apply automatic Canny edge detection using the computed median
	lower = int(max(0, (1.0 - sigma) * v))
	upper = int(min(255, (1.0 + sigma) * v))
	edged = cv2.Canny(image, lower, upper)
	# return the edged image
	return edged


#note7
from PIL import Image
import numpy as np
import cv2
import imageio
from FileNameP import FilenameByTime


def auto_canny(image, sigma=0.33):
    # compute the median of the single channel pixel intensities
    v = np.median(image)
    # apply automatic Canny edge detection using the computed median
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)
    # return the edged image
    return edged

#image = cv2.imread('mahotastest/orig-color.png')
filename1 = '/home/jack/Desktop/Imagedata/0-original-images/07082orig.jpg'
image = cv2.imread(filename1)
edged = auto_canny(image, sigma=0.33)
inverted = cv2.bitwise_not(edged)
cv2.imwrite("mahotastest/temp2.png", inverted)
cv2.imwrite(FilenameByTime("mahotastest/"), inverted)



# Open Front Image
#frontimage = Image.open('mahotastest/inverted-bitwise-note3_6.png').convert("1")
frontimage = Image.open('mahotastest/temp2.png').convert("1")
frontImage = frontimage.convert("RGBA")
datas = frontImage.getdata()


newData = []
for item in datas:
    if item[0] == 255 and item[1] == 255 and item[2] == 255:
        newData.append((255, 255, 255, 0))
    else:
        newData.append(item)

frontImage.putdata(newData)
#frontImage.save("mahotastest/frontImage-note7.png", "PNG")

# Back Image
#image = cv2.imread('mahotastest/orig-color.png')
#filename1 = '/home/jack/Desktop/Imagedata/0-original-images/05140orig.jpg'
# Open Background Image
background = Image.open(filename1)
#background = cv2.imread('mahotastest/orig-color.png')#.convert("RGBA")

# Convert image to RGBA
#frontImage = frontImage.convert("RGBA")

# Convert image to RGBA
#background = background.convert("RGBA")

# Calculate width to be at the center
width = (frontimage.width - frontimage.width) // 2

# Calculate height to be at the center
height = (frontimage.height - frontimage.height) // 2

# Paste the frontImage at (width, height)
background.paste(frontImage, (width, height), frontImage)

# Save this image
background.save("mahotastest/-atlast000q.png", format="png")
savefile = FilenameByTime("mahotastest/")
background.save(savefile, format="png")
#background = background.convert("RGB")
background

%%writefile OutlineImage.py
"""
USE:
from OutlineImage import *
orig_file = "junk/00000.jpg"
new_extension = ".jnk"
NEW = change_extension(orig_file,new_extension)
print(NEW)

filename1 = '/home/jack/Desktop/Imagedata/0-original-images/07082orig.jpg' 
outfile_png = '/home/jack/Desktop/dockercommands/images/useresult.png'
outlineJ(filename1,outfile_jpg)
outlineP(filename1,outfile_png)

"""
from PIL import Image
import numpy as np
import cv2
import imageio
from FileNameP import FilenameByTime
from pathlib import Path as change_ext
#p = change_ext('mysequence.jpg')
#p.rename(p.with_suffix('.png'))

def auto_canny(image, sigma=0.33):
    # compute the median of the single channel pixel intensities
    v = np.median(image)
    # apply automatic Canny edge detection using the computed median
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)
    # return the edged image
    return edged

#image = cv2.imread('mahotastest/orig-color.png')
def change_extension(orig_file,new_extension):
    p = change_ext(orig_file)
    new_name = p.rename(p.with_suffix(new_extension))
    return new_name
    
def outlineJ(filename1,outfile_jpg):
    image = cv2.imread(filename1)
    edged = auto_canny(image, sigma=0.33)
    inverted = cv2.bitwise_not(edged)
    cv2.imwrite("mahotastest/temp2.png", inverted)
    cv2.imwrite(FilenameByTime("mahotastest/"), inverted)
    # Open Front Image
    #frontimage = Image.open('mahotastest/inverted-bitwise-note3_6.png').convert("1")
    frontimage = Image.open('mahotastest/temp2.png').convert("1")
    frontImage = frontimage.convert("RGBA")
    datas = frontImage.getdata()
    newData = []
    for item in datas:
        if item[0] == 255 and item[1] == 255 and item[2] == 255:
            newData.append((255, 255, 255, 0))
        else:
            newData.append(item)

    frontImage.putdata(newData)
    # Open Background Image
    background = Image.open(filename1)
    # Calculate width to be at the center
    width = (frontimage.width - frontimage.width) // 2
    # Calculate height to be at the center
    height = (frontimage.height - frontimage.height) // 2
    # Paste the frontImage at (width, height)
    background.paste(frontImage, (width, height), frontImage)
    # Save this image
    background.save(outfile_jpg, format="jpg")
    savefile = FilenameByTime("mahotastest/")
    background.save(savefile, format="jpg")
    #background = background.convert("RGB")
    return background
def outlineP(filename1,outfile_png):
    image = cv2.imread(filename1)
    edged = auto_canny(image, sigma=0.33)
    inverted = cv2.bitwise_not(edged)
    cv2.imwrite("mahotastest/temp2.png", inverted)
    cv2.imwrite(FilenameByTime("mahotastest/"), inverted)
    # Open Front Image
    #frontimage = Image.open('mahotastest/inverted-bitwise-note3_6.png').convert("1")
    frontimage = Image.open('mahotastest/temp2.png').convert("1")
    frontImage = frontimage.convert("RGBA")
    datas = frontImage.getdata()
    newData = []
    for item in datas:
        if item[0] == 255 and item[1] == 255 and item[2] == 255:
            newData.append((255, 255, 255, 0))
        else:
            newData.append(item)

    frontImage.putdata(newData)
    # Open Background Image
    background = Image.open(filename1)
    # Calculate width to be at the center
    width = (frontimage.width - frontimage.width) // 2
    # Calculate height to be at the center
    height = (frontimage.height - frontimage.height) // 2
    # Paste the frontImage at (width, height)
    background.paste(frontImage, (width, height), frontImage)
    # Save this image
    background.save(outfile_png, format="png")
    savefile = FilenameByTime("mahotastest/")
    background.save(savefile, format="png")
    #background = background.convert("RGB")
    return background

!ls junk

from OutlineImage import *
orig_file = "junk/00000.jpg"
new_extension = ".jnk"
NEW = change_extension(orig_file,new_extension)
print(NEW)

import OutlineImage
import cv2
filename1 = '/home/jack/Documents/FezEqP0XEAE4JdSl.jpg'
image = cv2.imread(filename1)
imout = OutlineImage.auto_canny(image)
cv2.imwrite('/home/jack/Documents/XXFezEqP0XEAE4JdSl.jpg', imout)

from OutlineImage import outlineP
#filename1 = '/home/jack/Desktop/Imagedata/textured-images/RANDOM-smoothness25.91-threshhold4_20220922230108.jpg' 
filename1 = '/home/jack/Documents/margot-robbie.jpg'
outfileP = '/home/jack/Documents/margot-robbieol.jpg'
outlineP(filename1,outfileP)

from PIL import Image
im = Image.open(outfileP)
im

from PIL import Image
im = Image.open(savefile)
im

from PIL import Image
im = Image.open(filename1)
im



#@title Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

!pip install tensorflow_datasets

import tensorflow as tf
import tensorflow_datasets as tfds

# Check that GPU is available: cf. https://colab.research.google.com/notebooks/gpu.ipynb
assert(tf.test.gpu_device_name())

tf.keras.backend.clear_session()
tf.config.optimizer.set_jit(False) # Start with XLA disabled.

def load_data():
  result = tfds.load('cifar10', batch_size = -1)
  (x_train, y_train) = result['train']['image'],result['train']['label']
  (x_test, y_test) = result['test']['image'],result['test']['label']
  
  x_train = x_train.numpy().astype('float32') / 256
  x_test = x_test.numpy().astype('float32') / 256

  # Convert class vectors to binary class matrices.
  y_train = tf.keras.utils.to_categorical(y_train, num_classes=10)
  y_test = tf.keras.utils.to_categorical(y_test, num_classes=10)
  return ((x_train, y_train), (x_test, y_test))

(x_train, y_train), (x_test, y_test) = load_data()

def generate_model():
  return tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3, 3), padding='same', input_shape=x_train.shape[1:]),
    tf.keras.layers.Activation('relu'),
    tf.keras.layers.Conv2D(32, (3, 3)),
    tf.keras.layers.Activation('relu'),
    tf.keras.layers.MaxPooling2D(pool_size=(2, 2)),
    tf.keras.layers.Dropout(0.25),

    tf.keras.layers.Conv2D(64, (3, 3), padding='same'),
    tf.keras.layers.Activation('relu'),
    tf.keras.layers.Conv2D(64, (3, 3)),
    tf.keras.layers.Activation('relu'),
    tf.keras.layers.MaxPooling2D(pool_size=(2, 2)),
    tf.keras.layers.Dropout(0.25),

    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(512),
    tf.keras.layers.Activation('relu'),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(10),
    tf.keras.layers.Activation('softmax')
  ])

model = generate_model()

def compile_model(model):
  opt = tf.keras.optimizers.RMSprop(learning_rate=0.0001, decay=1e-6)
  model.compile(loss='categorical_crossentropy',
                optimizer=opt,
                metrics=['accuracy'])
  return model

model = compile_model(model)

def train_model(model, x_train, y_train, x_test, y_test, epochs=25):
  model.fit(x_train, y_train, batch_size=256, epochs=epochs, validation_data=(x_test, y_test), shuffle=True)

def warmup(model, x_train, y_train, x_test, y_test):
  # Warm up the JIT, we do not wish to measure the compilation time.
  initial_weights = model.get_weights()
  train_model(model, x_train, y_train, x_test, y_test, epochs=1)
  model.set_weights(initial_weights)

warmup(model, x_train, y_train, x_test, y_test)
%time train_model(model, x_train, y_train, x_test, y_test)

scores = model.evaluate(x_test, y_test, verbose=1)
print('Test loss:', scores[0])
print('Test accuracy:', scores[1])

# We need to clear the session to enable JIT in the middle of the program.
tf.keras.backend.clear_session()
tf.config.optimizer.set_jit(True) # Enable XLA.
model = compile_model(generate_model())
(x_train, y_train), (x_test, y_test) = load_data()

warmup(model, x_train, y_train, x_test, y_test)
%time train_model(model, x_train, y_train, x_test, y_test)

import os
import signal
pid = os.getpid()
os.kill(pid, signal.SIGTERM)

import os
import signal
pid = os.getpid()
os.kill(pid, signal.SIGTERM)

import subprocess
import os
from random import randint
from time import sleep
import time

import os
LIST = []
PATH = "/home/jack/Desktop/dockercommands/dragonfly-720x480/NewFolder/"
for files in sorted(os.listdir(PATH)):
    LIST.append(PATH+files)

print(len(LST))

from VID2img import *
from random import randint
from VIDEOZ import videoz
num = randint(0,len(videoz())-1)
print(num,len(videoz()))
filename = videoz()[num]
print(filename)
count = num
outputpath = "Experiment"
im = vid2img(count,filename,outputpath)
print(im.size,count)
im #1 orig #2 processed #3 twitterbot #4 processed #5 processed *6 binary

!mkdir Experiment

smoothness = randint(2000, 5000)*.01 
threshhold = randint(2, 10)
thresh = randint(1, 12)*.1
smoothness = str(smoothness)
thresh = str(thresh)
threshhold = str(threshhold)
filein = "result.png"    
filename = time.strftime("texture/RANDOM-smoothness"+smoothness+"-threshhold"+threshhold+"_%Y%m%d%H%M%S.jpg")
#gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
#gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
print(LIST[10])
print("gmic -input "+LIST[10]+ " -v 0 -texturize_canvas " +smoothness+","+threshhold+",,"+thresh+" o Experiment/test004.jpg")
#  -v 0 -texturize_canvas 32.3794,3,0.6 \

!gmic -input /home/jack/Desktop/dockercommands/dragonfly-720x480/NewFolder/00011.jpg -v 0 -texturize_canvas 39.31,7,,0.1 o Experiment/test004.jpg

from PIL import Image
Filein = "Experiment/test004.jpg"
im =Image.open(Filein)
im

#Posturize VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
import time
"""
Posturize Parameters
smoothness 150 - ( float  0 - 800 )
edges 30       - ( float  0 - 100 )
paint 1        - ( float  0 -  10 )
minimal area 9 - ( int    0 -  64 )
outline 0      - ( int    0 - 100)

-v -99 -fx_posterize 150,30,1,12,0,0,0,0
-v -99 -fx_posterize_preview 0,0,1.54472,12,8,17.0732,1,0

"""
# create a list in memory of a directory
LST = []
PATH = "output/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    

for count in range(0,len(LST)):
    filein = LST[count]
    filein = filein.replace("\n","")
    print (count,filein)
    sm =randint(40,4000)*.1
    edge =randint(200,1000)*.1    
    paint = randint(10,100)*.1
    #paint = randint(2,10)
    #mini = randint(0,640)*.1
    mini = randint(0,96)
    minix = randint(0,100)
    outline = randint(0,20)
    linez = randint(0,80)
    sm = str(sm)
    edge = str(edge)
    paint = str(paint)
    mini = str(mini)
    minix = str(minix)
    outline =str(outline)
    linez = str(linez) 
    filename = time.strftime("superjunk/"+str(count)+"_output_RANDOM-sm"+sm+"-edge"+edge+"-paint"+paint+"-mini"+mini+"-minix"+minix+"-outline"+outline+"-linez"+linez+"_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -fx_posterize "+sm+","+edge+","+paint+","+mini+","+minix+","+outline+","+linez+",0 \
    -normalize[-0] 0,255 -output "+filename, shell=True)
    #-v -99 -fx_posterize 150,20,1.54472,12,8,15,1,0
    sleep(1)
    print (count, end=". ")

def texturize(filein):
    sm =randint(40,4000)*.1
    edge =randint(200,1000)*.1    
    paint = randint(10,100)*.1
    #paint = randint(2,10)
    #mini = randint(0,640)*.1
    mini = randint(0,96)
    minix = randint(0,100)
    outline = randint(0,20)
    linez = randint(0,80)
    sm = str(sm)
    edge = str(edge)
    paint = str(paint)
    mini = str(mini)
    minix = str(minix)
    outline =str(outline)
    linez = str(linez) 
    filename = time.strftime("superjunk/"+str(count)+"_output_RANDOM-sm"+sm+"-edge"+edge+"-paint"+paint+"-mini"+mini+"-minix"+minix+"-outline"+outline+"-linez"+linez+"_%Y%m%d%H%M%S.jpg")
    return filename

   

 
#subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5

!ls 

#Thin Edges VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
import time
"""
old_photo
"""
# create a list in memory of a directory
LST = []
PATH = "videoframes/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print (count)

    threshhold = randint(20, 60)
    threshhold = str(threshhold)
    thresh = randint(150, 255)
    thresh = str(thresh)

    
    filename = time.strftime("old_photo/old_photo_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+"  -v 99 old_photo -normalize[-1] "+threshhold+","+thresh+" -output "+filename, shell=True)
    #  -v 0 -texturize_canvas 32.3794,3,0.6 \
    sleep(2)
    print (filename)

import subprocess
import os
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    print (count,filein)
    filename = time.strftime("cartoon/"+str(count)+"%Y%m%d%H%M%S.jpg")
    #com ="gmic -input "+filein+ " -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #-normalize[-0] 60,255 -output "+filename+", shell=True"
    #subprocess.call(com)
    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    -normalize[-0] 60,255 -output "+filename, shell=True) 


# cartoon Arguments:
### _smoothness,_sharpening,_threshold>=0,_thickness>=0,_color>=0,quantization>0

Description:<br />
Apply cartoon effect on selected images.<br />
Default values:<br />

smoothness=3, sharpening=150, threshold=20, thickness=0.25, color=1.5 and quantization=8.
Example of use:
$ gmic image.jpg cartoon 3,50,10,0.25,3,16

#smoothness=3, sharpening=150, threshold=20, thickness=0.25, color=1.5 and quantization=8.
#Example of use:
!gmic image.jpg cartoon 3,50,10,0.25,3,16

from PIL import Image
im = Image.open()

#Thin Edges VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
"""
-v 0 -texturize_canvas 27.65,5,0.6
Add canvas texture to image [0], with amplitude 27.65, \
fibrousness 5 and emboss level 0.6.

-v 0 -texturize_canvas 32.3794,3,0.6
-v 0 -texturize_canvas 32.3794,3,0.6
"""
# create a list in memory of a directory
LST = []
PATH = "output/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print (count,filein)
    #-v 0 -texturize_canvas 32.3794,3,0.6 \
    smoothness = randint(2000, 5000)*.01 
    threshhold = randint(2, 10)
    thresh = randint(1, 12)*.1
    smoothness = str(smoothness)
    thresh = str(thresh)
    threshhold = str(threshhold)
    
    filename = time.strftime("texture/RANDOM-smoothness"+smoothness+"-threshhold"+threshhold+"_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -texturize_canvas "+smoothness+","+threshhold+",,"+thresh+" -output "+filename, shell=True)
    #  -v 0 -texturize_canvas 32.3794,3,0.6 \
    sleep(5)
    print (filename)

!mkdir texture

count = 0
while True:
    filein = LST[count]
    print count,filein
    count = count +1
    if count==114:break

import os
import random
path0 = r"image_resources/"
random_filename0 = random.choice([
y for y in os.listdir(path0)
if os.path.isfile(os.path.join(path0, y)) ])
RandIm = path0+random_filename0
import os
os.system('gmic -i '+RandIm+' -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 -o cartoon0022.jpg')

#!gmic -i random_filename0 -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 -o cartoon0022A.jpg
!display cartoon0022.jpg


import os
import random
path0 = r"640x640/"
random_filename0 = random.choice([
y for y in os.listdir(path0)
if os.path.isfile(os.path.join(path0, y)) ])
RandIm = path0+random_filename0
!gmic -i 640x640/P_20180411_062100.jpg \
-v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
-o cartoon0022A.jpg
!showme cartoon0022A.jpg


f = open("640x640.list").readlines()
LST = []
for lines in f:
    line = lines.replace("\n","")
    PATH = "640x640/"+line
    LST.append(PATH)

!ls 640x640/P_20180416_164243.jpg

!ls cartoon

# WORKS GOOD cartoon
# 114 images in 640x640.list
import subprocess
count = 0
filein = LST[0]
filein = filein.replace("\n","")
count = count +1
print count,line
filename = time.strftime("cartoon/%Y%m%d%H%M%S.jpg")
com ="gmic -input "+filein+ "-resize2dx[-1] 1024 lh='{h}' --blur[-1] 0.35% \
-quantize[-1] 10  -output "+filename+", shell=True"
subprocess.call(com)

import subprocess
import os
filein = LST[0]
filein = filein.replace("\n","")
count = count +1
print count,line
filename = time.strftime("cartoon/%Y%m%d%H%M%S.jpg")

com ="gmic -input "+filein+ " -resize2dx[-1] 1024 lh='{h}' --blur[-1] 0.35% \
-quantize[-1] 10  -output "+filename+", shell=True"
subprocess.call(com)

!ls 640x640/P_20180416_164243.jpg

import subprocess
import os
import time
filein = LST[0]
filein = filein.replace("\n","")
count = count +1
print count,line
filename = time.strftime("cartoon/%Y%m%d%H%M%S.jpg")

com =["gmic -input 640x640/P_20180416_164243.jpg -resize2dx[-1] 1024 lh='{h}' --blur[-1] 0.35% \
-quantize[-1] 10  -output TESTING.jpg"]
subprocess.call(com)

# cartoon Images
!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/P_20180416_163956_BF.jpg \
-v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
-normalize[-0] 60,255 \
-o cartoon0022A.jpg
!showme cartoon0022A.jpg

# cartoon Images
!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/P_20180416_163956_BF.jpg \
-v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
-normalize[-0] 60,255 \
-o cartoon0022A.jpg
!showme cartoon0022A.jpg

!gmic -i 640x640/P_20180416_164243.jpg \
-normalize[-0] 60,255 \
-o junk/LIGHTER_P_20180416_164243.jpg
!showme junk/LIGHTER_P_20180416_164243.jpg


# 114 images in 640x640.list
import subprocess
count = 35
filein = LST[count]
count = count +1
print count,line
filename = time.strftime("junk/cartoon_%Y%m%d%H%M%S.jpg")
subprocess.call("gmic -input "+line+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0  -normalize[-0] 60,255 -output "+filename, shell=True) 




!gmic -v 99 -i 640x640/181.jpg -hotchocolate.gmic -o chocolate-test.jpg


# 114 images in 640x640.list
import subprocess
count = 0
filein = LST[count]
count = count +1
print count,line
filename = time.strftime("junk/%Y%m%d%H%M%S.jpg")
subprocess.call("gmic -input "+line+" -resize2dx[-1] 1024 lh='{h}' --blur[-1] 0.35% \
-quantize[-1] 8  -output "+filename, shell=True) 


!ls junk

!gmic v + sp tiger v

!ls /home/jack/.config/gmic/

!showme /home/jack/.config/gmic/sample_tiger.png

# %load /home/jack/.config/gmic/hotchocolate.gmic
#@gimp <span color="red">&#x2764; <b>One-click chocolate !</b></span> : gimp_hotchocolate, gimp_hotchocolate_preview
#@gimp : note = note{"Want to send a <b>free hot chocolate</b> to the <b>hard-working</b> developers who provide G'MIC <b>for free</b> ?\n
#@gimp : Just follow the link below (or copy/paste into your browser) and click <b>on the sponsored link</b> that is shown. It's as simple as that and
#@gimp : we'll drink to you :)"}
#@gimp : link = link{"Send a free hot chocolate to the G'MIC developers","http://gmic.eu/freechocolate.shtml"}
#@gimp : link = link{"http://gmic.eu/freechocolate.shtml"}
#@gimp : sep = separator()
#@gimp : note = note{"If you'd like to send <b>more</b> than a single hot chocolate for our efforts, please visit the following page where you can contribute
#@gimp : extra to help keep us motivated (via <b>Paypal</b>):"}
#@gimp : link = link{"Offer even more hot chocolate to the G'MIC developers","http://gmic.eu/morechocolate.shtml"}
#@gimp : link = link{"http://gmic.eu/morechocolate.shtml"}
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note:</b> This filter won't appear anymore after you re-run the plug-in. So, don't miss the occasion!</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/30/2015</i>.</small>")
gimp_hotchocolate : (10) -o. raw:/home/jack/.config/gmic/hotchocolate.gmic,uchar -rm. 
gimp_hotchocolate_preview : -gimp_hotchocolate -gimp_friends

!gmic -i 640x640/171.jpg

!gmic -v 6 -i 640x640/171.jpg

f = open("GMIC-documents.txt", "r").readlines()
count = 0
start = raw_input("Start: ")
for line in f:
    line = line.replace("\n", "")
    count = count +1
    start = int(start)
    end = start +150
    if count>start:
        print line

text = "gmic -i 640x640/153.jpg blur 3,0 sharpen 10 resize 200%,200% -o junk/.jpg"
name = "".join(text.split())
print name

!gmic -i 640x640/153.jpg resize 75%,75% -o junk/blur-sharpen-resize.jpg
!showme junk/blur-sharpen-resize.jpg

from random import randint
sm =randint(0,5)
sh =randint(50,250)
thres = randint(5,50)
thk = randint(1,5)*.1
col = randint(1,4)*.1
quant = randint(3,10)
print sm, sh, thres, thk, col, quant

Apply cartoon effect on selected images.
Default values: 
smoothness=3 sharpening=150 threshold=20 thickness=0.25 color=1.5 quantization=8

import os
import sys
sys.path.insert(0, "GRAPHICS/gmic")
from SEARCHdocs import searchdocs
searchdocs("GRAPHICS/gmic/GMIC-documents.txt")

from SEARCHdocs import searchdocs
searchdocs("/home/jack/.config/gmic/update222.gmic")

!gmic -v 99 -i posterize0022B.jpg old_photo -display


!gmic -v 99 -i posterize0022B.jpg sepia -display


v - noise 20 bilateral 30,60 b 2 sharpen 100 frame_fuzzy 8%,8%,6,3 to_rgb shadow_patch 0.75 n 0,255 sepia v +

from SEARCHdocs import searchdocs
searchdocs("GMIC-documents.txt")

f = open("GMIC-documents.txt", "r").readlines()
count = 0
search = raw_input("Search: ")
for line in f:
    line = line.replace("\n", "")
    count = count +1
    start = int(start)
    end = start +150
    if count>start:
        print line

!gmic -i 640x640/171.jpg -status

# create a list in memory of a directory
from time import sleep
import os
LST = []
PATH = "640x640/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
    
Then it may be used with:
    
    
for line in LST:
    print line    

for line in LST:
    print line

import subprocess
import os
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    filename = time.strftime("cartoon/RANDOM_%Y%m%d%H%M%S.jpg")

    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    -normalize[-0] 60,255 -output "+filename, shell=True) 


print (randint(1,4)*1.1)-1



import subprocess
import os
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    filename = time.strftime("cartoon/RANDOM_%Y%m%d%H%M%S.jpg")

    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    -normalize[-0] 60,255 -output "+filename, shell=True) 


!mkdir

import subprocess
import os
import time
directory = "cartoon"
if not os.path.exists(directory):
    os.makedirs(directory)
count = 0
while True:
    count = count +1
    if count==114:break
    filename = time.strftime(directory+"/TOON_%Y%m%d%H%M%S.jpg")
    filein = LST[count]
    
    
    print count,filein
    
    

#VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    sm =randint(0,5)
    sh =randint(50,250)
    thres = randint(5,50)
    thk = randint(1,5)*.1
    col = (randint(1,10)*1.1)-1
    quant = randint(3,10)
    sm = str(sm)
    quant = str(quant)
    col = str(col)
    thres = str(thres)
    thk = str(thk)
    sh = str(sh)
    filename = time.strftime("cartoon/RANDOM-sm"+sm+"-sh"+sh+"-thres"+thres+"-thk"+thk+"-col"+col+"-quant"+quant+"%Y%m%d%H%M%S.jpg")
-v -99 -fx_posterize 150,30,1,12,0,0,0,0
    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,"+sh+","+thres+","+thk+","+col+","+quant+",0 \
    -normalize[-0] 60,255 -output "+filename, shell=True)
    sleep(1)

import os
import random
path0 = r"640x640/"
random_filename0 = random.choice([
y for y in os.listdir(path0)
if os.path.isfile(os.path.join(path0, y)) ])
RandIm = path0+random_filename0
print RandIm

-v 0 -fx_halftone -15.3846,-35.5769,-26.9231,2.88462,12,11,57,5,2.76923,0

# 'density=50', 'thickness=10', 'max_angle=75', 'opacity=0.7' and 'smoothness=0'
!gmic -v 5 -i 640x640/101.jpg -cubism  50, 10, 75, 0.7,0 -display

# 'density=50', 'thickness=10', 'max_angle=75', 'opacity=0.7' and 'smoothness=0'
!gmic -i 640x640/P_20180415_164415.jpg \
-v 0 -cubism  50, 10, 75, 0.7,0 \
-o cubism22A.jpg
!showme cubism22A.jpg    

import os
import random
path0 = r"640x640/"
random_filename0 = random.choice([
y for y in os.listdir(path0)
if os.path.isfile(os.path.join(path0, y)) ])
RandIm = path0+random_filename0
#posterize0022A.jpg -v -99 -fx_posterize 150,30,1,12,0,0,0,0
#posterize0022c.jpg -v -99 -fx_posterize_preview 0,0,1.54472,12,8,17.0732,1,0
#posterize0022D.jpg -v -99 -fx_posterize 150,20,1.54472,12,8,15,1,0
#halftone0022E.jpg -v -99 -fx_halftone 0,0,0,0,8,6,10,5,0.5,0
#halftone0022f.jpg -v -99 -fx_halftone 0,0,0,0,5,8,8,5,0.1,0

!gmic -i 640x640/P_20180411_062100.jpg \
-v -99 -fx_halftone 0,0,0,0,5,8,8,5,0.1,0 \
-normalize[-0] 60,255 \
-o halftone0022f.jpg
!showme halftone0022f.jpg


!mkdir halftone

#Default values: 'strength=100', 'radius_min=70' and 'radius_max=90'.

!gmic -i 640x640/013.jpg \
-v -99 -fx_vignette 150.0,37.0,88.0,206,0,0,0  -display

# Good
!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/013.jpg -v -99 \
-fx_lightglow_preview 20.0,0.6,8,0.80,0,0 \
-v -99 -fx_vignette 150.0,37.0,88.0,206,0,0,0  -display

!gmic linear.png -input_gpl palette.gpl -x_colorize[0] 1,1024,1,[-1] -k[0] -s c,{3-s} -o[1] \
-display

!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/013.jpg -v -99 \
-to_rgba -replace_color 0,0,255,0,0,255,128,128,128,0 -display \
-o colorize.png


!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/013.jpg -v -99 \
-x_colorize 1,1024,1 -s c,{3-s} -o[-1] -display -o colorize.png

!showme colorize.png

!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/013.jpg -v -99 \
-fx_lightglow_preview 20.4819,0.610442,8,0.795181,0,0 -display

-v -99 -fx_vignette 43.4884,67.4419,88.3721,206,118,118,255

-v -99 -fx_lightglow_preview 20.4819,0.610442,8,0.795181,0,0

gmic lineart.png -x_colorize 1,1024,1 -s c,{3-s} -o[-1] colors.png
Here is another variant if you save also in this folder a palette.gpl file to get an additional palette dialog.  
gmic linear.png -input_gpl palette.gpl -x_colorize[0] 1,1024,1,[-1] -k[0] -s c,{3-s} -o[1] colors.png


# texturize_canvas
!gmic -input /home/jack/Desktop/GRAPHICS/gmic/640x640/P_20180412_173934.jpg \
 -v 99 old_photo \
-normalize[-1] 50,255 \
-output old-photo.jpg
!showme old-photo.jpg

randint(2000, 4000)*.01

!mkdir old_photo

!gmic -update

#Thin Edges VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
"""
Thin Edges
smoothness 0 4 
threshhold .2 10


-v -99 -fx_thin_edges 0.64257,7.83133,0,0
-v -99 -fx_thin_edges 1.16466,6.62651,0,0
"""
# create a list in memory of a directory
LST = []
PATH = "640x640/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    
    smoothness = randint(1, 400)*.01 
    threshhold = randint(20, 600)*.01
    smoothness = str(smoothness)
    threshhold = str(threshhold)
    
    filename = time.strftime("thinedges/RANDOM-smoothness"+smoothness+"-threshhold"+threshhold+"_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -fx_thin_edges "+smoothness+","+threshhold+"0,0 -output "+filename, shell=True)
    # -v -99 -fx_thin_edges 1.16466,6.62651,0,0
    sleep(5)
    print filename

#Halftone VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
"""
Halftone Parameters
brightness float -100 - 100
contrast float t -100 - 100
gama float -100 - 100
smoothness float 1 - 10

number 2 - 32 
size dark 2 - 256
size light 2 - 256
shape { 0=square | 1=diamond | 2=circle | 3=inv-square | 4=inv-diamond | 5=inv-circle }
smooth float 0 -32

-v -99 -fx_halftone 0,0,0,0,8,6,10,5,0.5,0
-v -99 -fx_halftone 0,0,0,0,5,8,8,5,0.1,0
"""
# create a list in memory of a directory
LST = []
PATH = "640x640/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    
    brit = randint(-50,50)
    cont = randint(-50,50)
    gama = randint(-50,100)*.1
    smoothness = randint(1,80)*.1
    
    #number = randint(2, 32)
    number = randint(2, 10) 
    #sizedark = randint(2, 256)
    #sizelight = randint(2, 256)
    sizedark = randint(2, 15)
    sizelight = randint(2, 15)    
    shape = randint(0,5)
    smooth = randint(1, 20)*.1    
 
    brit = str(brit)
    cont = str(cont)
    gama = str(gama)
    smoothness = str(smoothness)
    number = str(number)
    sizedark =str(sizedark)
    sizelight = str(sizelight)
    shape = str(shape)
    smooth = str(smooth)
    
    filename = time.strftime("halftone/RANDOM-brit"+brit+"-cont"+cont+"-gama"+gama+"-smoothness"+smoothness+"-number"+number+"-sizedark"+sizedark+"-sizelight"+sizelight+"-shape"+shape+"-smooth"+smooth+"_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -fx_halftone "+brit+","+cont+","+gama+","+smoothness+","+number+","+sizedark+","+sizelight+","+shape+","+smooth+" -normalize[-0] 0,255 -output "+filename, shell=True)
    # -v -99 -fx_halftone 0,0,0,0,8,6,10,5,0.5,0
    sleep(5)
    print filename

!mkdir posterize

#VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print (count,line)
    sm =randint(0,5)
    sh =randint(50,250)
    thres = randint(5,50)
    thk = randint(1,5)*.1
    col = (randint(1,10)*1.1)-1
    quant = randint(3,10)
    sm = str(sm)
    quant = str(quant)
    col = str(col)
    thres = str(thres)
    thk = str(thk)
    sh = str(sh)
    filename = time.strftime("cartoon/RANDOM-sm"+sm+"-sh"+sh+"-thres"+thres+"-thk"+thk+"-col"+col+"-quant"+quant+"%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,"+sh+","+thres+","+thk+","+col+","+quant+",0 \
    -normalize[-0] 60,255 -output "+filename, shell=True)
    sleep(1)



count = 0
while True:
    filein = LST[count]
    print count,filein
    count = count +1
    if count==114:break

import os
import random
path0 = r"640x640/"
random_filename0 = random.choice([
y for y in os.listdir(path0)
if os.path.isfile(os.path.join(path0, y)) ])
RandIm = path0+random_filename0
!gmic -i 640x640/P_20180411_062100.jpg \
-v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
-o cartoon0022A.jpg
!showme cartoon0022A.jpg


import os
import random
path0 = r"640x640/"
random_filename0 = random.choice([
y for y in os.listdir(path0)
if os.path.isfile(os.path.join(path0, y)) ])
RandIm = path0+random_filename0
!gmic -i 640x640/P_20180411_062100.jpg \
-v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
-o cartoon0022A.jpg
!showme cartoon0022A.jpg


f = open("640x640.list").readlines()
LST = []
for lines in f:
    line = lines.replace("\n","")
    PATH = "640x640/"+line
    LST.append(PATH)

!ls 640x640/P_20180416_164243.jpg

!ls cartoon

# WORKS GOOD cartoon
# 114 images in 640x640.list
import subprocess
count = 0
filein = LST[0]
filein = filein.replace("\n","")
count = count +1
print count,line
filename = time.strftime("cartoon/%Y%m%d%H%M%S.jpg")
com ="gmic -input "+filein+ "-resize2dx[-1] 1024 lh='{h}' --blur[-1] 0.35% \
-quantize[-1] 10  -output "+filename+", shell=True"
subprocess.call(com)

import subprocess
import os
filein = LST[0]
filein = filein.replace("\n","")
count = count +1
print count,line
filename = time.strftime("cartoon/%Y%m%d%H%M%S.jpg")

com ="gmic -input "+filein+ " -resize2dx[-1] 1024 lh='{h}' --blur[-1] 0.35% \
-quantize[-1] 10  -output "+filename+", shell=True"
subprocess.call(com)

!ls 640x640/P_20180416_164243.jpg



import subprocess
import os
import time
filein = LST[0]
filein = filein.replace("\n","")
count = count +1
print count,line
filename = time.strftime("cartoon/%Y%m%d%H%M%S.jpg")

com =["gmic -input 640x640/P_20180416_164243.jpg -resize2dx[-1] 1024 lh='{h}' --blur[-1] 0.35% \
-quantize[-1] 10  -output TESTING.jpg"]
subprocess.call(com)

# cartoon Images
!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/P_20180416_163956_BF.jpg \
-v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
-normalize[-0] 60,255 \
-o cartoon0022A.jpg
!showme cartoon0022A.jpg

# cartoon Images
!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/P_20180416_163956_BF.jpg \
-v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
-normalize[-0] 60,255 \
-o cartoon0022A.jpg
!showme cartoon0022A.jpg

!gmic -i 640x640/P_20180416_164243.jpg \
-normalize[-0] 60,255 \
-o junk/LIGHTER_P_20180416_164243.jpg
!showme junk/LIGHTER_P_20180416_164243.jpg


# 114 images in 640x640.list
import subprocess
count = 35
filein = LST[count]
count = count +1
print count,line
filename = time.strftime("junk/cartoon_%Y%m%d%H%M%S.jpg")
subprocess.call("gmic -input "+line+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0  -normalize[-0] 60,255 -output "+filename, shell=True) 




!gmic -v 99 -i 640x640/181.jpg -hotchocolate.gmic -o chocolate-test.jpg


# 114 images in 640x640.list
import subprocess
count = 0
filein = LST[count]
count = count +1
print count,line
filename = time.strftime("junk/%Y%m%d%H%M%S.jpg")
subprocess.call("gmic -input "+line+" -resize2dx[-1] 1024 lh='{h}' --blur[-1] 0.35% \
-quantize[-1] 8  -output "+filename, shell=True) 


!ls junk

!gmic v + sp tiger v

!ls /home/jack/.config/gmic/

!showme /home/jack/.config/gmic/sample_tiger.png

# %load /home/jack/.config/gmic/hotchocolate.gmic
#@gimp <span color="red">&#x2764; <b>One-click chocolate !</b></span> : gimp_hotchocolate, gimp_hotchocolate_preview
#@gimp : note = note{"Want to send a <b>free hot chocolate</b> to the <b>hard-working</b> developers who provide G'MIC <b>for free</b> ?\n
#@gimp : Just follow the link below (or copy/paste into your browser) and click <b>on the sponsored link</b> that is shown. It's as simple as that and
#@gimp : we'll drink to you :)"}
#@gimp : link = link{"Send a free hot chocolate to the G'MIC developers","http://gmic.eu/freechocolate.shtml"}
#@gimp : link = link{"http://gmic.eu/freechocolate.shtml"}
#@gimp : sep = separator()
#@gimp : note = note{"If you'd like to send <b>more</b> than a single hot chocolate for our efforts, please visit the following page where you can contribute
#@gimp : extra to help keep us motivated (via <b>Paypal</b>):"}
#@gimp : link = link{"Offer even more hot chocolate to the G'MIC developers","http://gmic.eu/morechocolate.shtml"}
#@gimp : link = link{"http://gmic.eu/morechocolate.shtml"}
#@gimp : sep = separator()
#@gimp : note = note{"<small><b>Note:</b> This filter won't appear anymore after you re-run the plug-in. So, don't miss the occasion!</small>"}
#@gimp : sep = separator(), note = note("<small>Author: <i>David Tschumperl&#233;</i>.      Latest update: <i>11/30/2015</i>.</small>")
gimp_hotchocolate : (10) -o. raw:/home/jack/.config/gmic/hotchocolate.gmic,uchar -rm. 
gimp_hotchocolate_preview : -gimp_hotchocolate -gimp_friends

!gmic -i 640x640/171.jpg

!gmic -v 6 -i 640x640/171.jpg

f = open("GMIC-documents.txt", "r").readlines()
count = 0
start = raw_input("Start: ")
for line in f:
    line = line.replace("\n", "")
    count = count +1
    start = int(start)
    end = start +150
    if count>start:
        print line

text = "gmic -i 640x640/153.jpg blur 3,0 sharpen 10 resize 200%,200% -o junk/.jpg"
name = "".join(text.split())
print name

!gmic -i 640x640/153.jpg resize 75%,75% -o junk/blur-sharpen-resize.jpg
!showme junk/blur-sharpen-resize.jpg

from random import randint
sm =randint(0,5)
sh =randint(50,250)
thres = randint(5,50)
thk = randint(1,5)*.1
col = randint(1,4)*.1
quant = randint(3,10)
print sm, sh, thres, thk, col, quant

Apply cartoon effect on selected images.
Default values: 
smoothness=3 sharpening=150 threshold=20 thickness=0.25 color=1.5 quantization=8

import os
import sys
sys.path.insert(0, "GRAPHICS/gmic")
from SEARCHdocs import searchdocs
searchdocs("GRAPHICS/gmic/GMIC-documents.txt")

from SEARCHdocs import searchdocs
searchdocs("/home/jack/.config/gmic/update222.gmic")

!gmic -v 99 -i posterize0022B.jpg old_photo -display


!gmic -v 99 -i posterize0022B.jpg sepia -display


v - noise 20 bilateral 30,60 b 2 sharpen 100 frame_fuzzy 8%,8%,6,3 to_rgb shadow_patch 0.75 n 0,255 sepia v +

from SEARCHdocs import searchdocs
searchdocs("GMIC-documents.txt")

f = open("GMIC-documents.txt", "r").readlines()
count = 0
search = raw_input("Search: ")
for line in f:
    line = line.replace("\n", "")
    count = count +1
    start = int(start)
    end = start +150
    if count>start:
        print line

!gmic -i 640x640/171.jpg -status

# create a list in memory of a directory
from time import sleep
import os
LST = []
PATH = "640x640/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
    
Then it may be used with:
    
    
for line in LST:
    print line    

for line in LST:
    print line

import subprocess
import os
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    filename = time.strftime("cartoon/%Y%m%d%H%M%S.jpg")
    #com ="gmic -input "+filein+ " -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #-normalize[-0] 60,255 -output "+filename+", shell=True"
    #subprocess.call(com)
    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    -normalize[-0] 60,255 -output "+filename, shell=True) 


import subprocess
import os
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    filename = time.strftime("cartoon/RANDOM_%Y%m%d%H%M%S.jpg")

    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    -normalize[-0] 60,255 -output "+filename, shell=True) 


print (randint(1,4)*1.1)-1



import subprocess
import os
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    filename = time.strftime("cartoon/RANDOM_%Y%m%d%H%M%S.jpg")

    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    -normalize[-0] 60,255 -output "+filename, shell=True) 


!mkdir

import subprocess
import os
import time
directory = "cartoon"
if not os.path.exists(directory):
    os.makedirs(directory)
count = 0
while True:
    count = count +1
    if count==114:break
    filename = time.strftime(directory+"/TOON_%Y%m%d%H%M%S.jpg")
    filein = LST[count]
    
    
    print count,filein
    
    

#VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    sm =randint(0,5)
    sh =randint(50,250)
    thres = randint(5,50)
    thk = randint(1,5)*.1
    col = (randint(1,10)*1.1)-1
    quant = randint(3,10)
    sm = str(sm)
    quant = str(quant)
    col = str(col)
    thres = str(thres)
    thk = str(thk)
    sh = str(sh)
    filename = time.strftime("cartoon/RANDOM-sm"+sm+"-sh"+sh+"-thres"+thres+"-thk"+thk+"-col"+col+"-quant"+quant+"%Y%m%d%H%M%S.jpg")
-v -99 -fx_posterize 150,30,1,12,0,0,0,0
    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,"+sh+","+thres+","+thk+","+col+","+quant+",0 \
    -normalize[-0] 60,255 -output "+filename, shell=True)
    sleep(1)

import os
import random
path0 = r"640x640/"
random_filename0 = random.choice([
y for y in os.listdir(path0)
if os.path.isfile(os.path.join(path0, y)) ])
RandIm = path0+random_filename0
print RandIm

-v 0 -fx_halftone -15.3846,-35.5769,-26.9231,2.88462,12,11,57,5,2.76923,0

# 'density=50', 'thickness=10', 'max_angle=75', 'opacity=0.7' and 'smoothness=0'
!gmic -v 5 -i 640x640/101.jpg -cubism  50, 10, 75, 0.7,0 -display

# 'density=50', 'thickness=10', 'max_angle=75', 'opacity=0.7' and 'smoothness=0'
!gmic -i 640x640/P_20180415_164415.jpg \
-v 0 -cubism  50, 10, 75, 0.7,0 \
-o cubism22A.jpg
!showme cubism22A.jpg    

import os
import random
path0 = r"640x640/"
random_filename0 = random.choice([
y for y in os.listdir(path0)
if os.path.isfile(os.path.join(path0, y)) ])
RandIm = path0+random_filename0
#posterize0022A.jpg -v -99 -fx_posterize 150,30,1,12,0,0,0,0
#posterize0022c.jpg -v -99 -fx_posterize_preview 0,0,1.54472,12,8,17.0732,1,0
#posterize0022D.jpg -v -99 -fx_posterize 150,20,1.54472,12,8,15,1,0
#halftone0022E.jpg -v -99 -fx_halftone 0,0,0,0,8,6,10,5,0.5,0
#halftone0022f.jpg -v -99 -fx_halftone 0,0,0,0,5,8,8,5,0.1,0

!gmic -i 640x640/P_20180411_062100.jpg \
-v -99 -fx_halftone 0,0,0,0,5,8,8,5,0.1,0 \
-normalize[-0] 60,255 \
-o halftone0022f.jpg
!showme halftone0022f.jpg


!mkdir halftone

#Default values: 'strength=100', 'radius_min=70' and 'radius_max=90'.

!gmic -i 640x640/013.jpg \
-v -99 -fx_vignette 150.0,37.0,88.0,206,0,0,0  -display

# Good
!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/013.jpg -v -99 \
-fx_lightglow_preview 20.0,0.6,8,0.80,0,0 \
-v -99 -fx_vignette 150.0,37.0,88.0,206,0,0,0  -display

!gmic linear.png -input_gpl palette.gpl -x_colorize[0] 1,1024,1,[-1] -k[0] -s c,{3-s} -o[1] \
-display

!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/013.jpg -v -99 \
-to_rgba -replace_color 0,0,255,0,0,255,128,128,128,0 -display \
-o colorize.png


!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/013.jpg -v -99 \
-x_colorize 1,1024,1 -s c,{3-s} -o[-1] -display -o colorize.png

!showme colorize.png

!gmic -i /home/jack/Desktop/GRAPHICS/gmic/640x640/013.jpg -v -99 \
-fx_lightglow_preview 20.4819,0.610442,8,0.795181,0,0 -display

-v -99 -fx_vignette 43.4884,67.4419,88.3721,206,118,118,255

-v -99 -fx_lightglow_preview 20.4819,0.610442,8,0.795181,0,0

gmic lineart.png -x_colorize 1,1024,1 -s c,{3-s} -o[-1] colors.png
Here is another variant if you save also in this folder a palette.gpl file to get an additional palette dialog.  
gmic linear.png -input_gpl palette.gpl -x_colorize[0] 1,1024,1,[-1] -k[0] -s c,{3-s} -o[1] colors.png


# texturize_canvas
!gmic -input /home/jack/Desktop/GRAPHICS/gmic/640x640/P_20180412_173934.jpg \
 -v 99 old_photo \
-normalize[-1] 50,255 \
-output old-photo.jpg
!showme old-photo.jpg

randint(2000, 4000)*.01

!mkdir old_photo

#Thin Edges VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
import time
"""
old_photo
"""
# create a list in memory of a directory
LST = []
PATH = "MaskedResults/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count

    threshhold = randint(20, 60)
    threshhold = str(threshhold)
    thresh = randint(150, 255)
    thresh = str(thresh)

    
    filename = time.strftime("old_photo/old_photo_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+"  -v 99 old_photo -normalize[-1] "+threshhold+","+thresh+" -output "+filename, shell=True)
    #  -v 0 -texturize_canvas 32.3794,3,0.6 \
    sleep(5)
    print filename

!gmic -update

#Thin Edges VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
"""
-v 0 -texturize_canvas 27.65,5,0.6
Add canvas texture to image [0], with amplitude 27.65, \
fibrousness 5 and emboss level 0.6.

-v 0 -texturize_canvas 32.3794,3,0.6
-v 0 -texturize_canvas 32.3794,3,0.6
"""
# create a list in memory of a directory
LST = []
PATH = "640x640/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    #-v 0 -texturize_canvas 32.3794,3,0.6 \
    smoothness = randint(2000, 5000)*.01 
    threshhold = randint(2, 10)
    thresh = randint(1, 12)*.1
    smoothness = str(smoothness)
    thresh = str(thresh)
    threshhold = str(threshhold)
    
    filename = time.strftime("texture/RANDOM-smoothness"+smoothness+"-threshhold"+threshhold+"_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -texturize_canvas "+smoothness+","+threshhold+",,"+thresh+" -output "+filename, shell=True)
    #  -v 0 -texturize_canvas 32.3794,3,0.6 \
    sleep(5)
    print filename

#Thin Edges VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
"""
Thin Edges
smoothness 0 4 
threshhold .2 10


-v -99 -fx_thin_edges 0.64257,7.83133,0,0
-v -99 -fx_thin_edges 1.16466,6.62651,0,0
"""
# create a list in memory of a directory
LST = []
PATH = "640x640/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    
    smoothness = randint(1, 400)*.01 
    threshhold = randint(20, 600)*.01
    smoothness = str(smoothness)
    threshhold = str(threshhold)
    
    filename = time.strftime("thinedges/RANDOM-smoothness"+smoothness+"-threshhold"+threshhold+"_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -fx_thin_edges "+smoothness+","+threshhold+"0,0 -output "+filename, shell=True)
    # -v -99 -fx_thin_edges 1.16466,6.62651,0,0
    sleep(5)
    print filename

#Halftone VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
"""
Halftone Parameters
brightness float -100 - 100
contrast float t -100 - 100
gama float -100 - 100
smoothness float 1 - 10

number 2 - 32 
size dark 2 - 256
size light 2 - 256
shape { 0=square | 1=diamond | 2=circle | 3=inv-square | 4=inv-diamond | 5=inv-circle }
smooth float 0 -32

-v -99 -fx_halftone 0,0,0,0,8,6,10,5,0.5,0
-v -99 -fx_halftone 0,0,0,0,5,8,8,5,0.1,0
"""
# create a list in memory of a directory
LST = []
PATH = "640x640/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    
    brit = randint(-50,50)
    cont = randint(-50,50)
    gama = randint(-50,100)*.1
    smoothness = randint(1,80)*.1
    
    #number = randint(2, 32)
    number = randint(2, 10) 
    #sizedark = randint(2, 256)
    #sizelight = randint(2, 256)
    sizedark = randint(2, 15)
    sizelight = randint(2, 15)    
    shape = randint(0,5)
    smooth = randint(1, 20)*.1    
 
    brit = str(brit)
    cont = str(cont)
    gama = str(gama)
    smoothness = str(smoothness)
    number = str(number)
    sizedark =str(sizedark)
    sizelight = str(sizelight)
    shape = str(shape)
    smooth = str(smooth)
    
    filename = time.strftime("halftone/RANDOM-brit"+brit+"-cont"+cont+"-gama"+gama+"-smoothness"+smoothness+"-number"+number+"-sizedark"+sizedark+"-sizelight"+sizelight+"-shape"+shape+"-smooth"+smooth+"_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -fx_halftone "+brit+","+cont+","+gama+","+smoothness+","+number+","+sizedark+","+sizelight+","+shape+","+smooth+" -normalize[-0] 0,255 -output "+filename, shell=True)
    # -v -99 -fx_halftone 0,0,0,0,8,6,10,5,0.5,0
    sleep(5)
    print filename

#Posturize VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
"""
Posturize Parameters
smoothness 150 - ( float  0 - 800 )
edges 30       - ( float  0 - 100 )
paint 1        - ( float  0 -  10 )
minimal area 9 - ( int    0 -  64 )
outline 0      - ( int    0 - 100)

-v -99 -fx_posterize 150,30,1,12,0,0,0,0
-v -99 -fx_posterize_preview 0,0,1.54472,12,8,17.0732,1,0

"""
# create a list in memory of a directory
LST = []
PATH = "640x640/"
for files in sorted(os.listdir(PATH)):
    LST.append(PATH+files)
    
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    sm =randint(40,4000)*.1
    edge =randint(200,1000)*.1    
    paint = randint(10,100)*.1
    #paint = randint(2,10)
    #mini = randint(0,640)*.1
    mini = randint(0,96)
    minix = randint(0,100)
    outline = randint(0,20)
    linez = randint(0,80)
    sm = str(sm)
    edge = str(edge)
    paint = str(paint)
    mini = str(mini)
    minix = str(minix)
    outline =str(outline)
    linez = str(linez) 
    filename = time.strftime("posterize/RANDOM-sm"+sm+"-edge"+edge+"-paint"+paint+"-mini"+mini+"-minix"+minix+"-outline"+outline+"-linez"+linez+"_%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -fx_posterize "+sm+","+edge+","+paint+","+mini+","+minix+","+outline+","+linez+",0 \
    -normalize[-0] 0,255 -output "+filename, shell=True)
    #-v -99 -fx_posterize 150,20,1.54472,12,8,15,1,0
    sleep(5)
    print filename

#VERY GOOD 
import subprocess
import os
from random import randint
from time import sleep
count = 0
while True:
    count = count+1
    filein = LST[count]
    filein = filein.replace("\n","")
    count = count +1
    print count,line
    sm =randint(0,5)
    sh =randint(50,250)
    thres = randint(5,50)
    thk = randint(1,5)*.1
    col = (randint(1,10)*1.1)-1
    quant = randint(3,10)
    sm = str(sm)
    quant = str(quant)
    col = str(col)
    thres = str(thres)
    thk = str(thk)
    sh = str(sh)
    filename = time.strftime("cartoon/RANDOM-sm"+sm+"-sh"+sh+"-thres"+thres+"-thk"+thk+"-col"+col+"-quant"+quant+"%Y%m%d%H%M%S.jpg")
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,124.771,20,0.5,1.5,8,0 \
    #subprocess.call("gmic -input "+filein+" -v 0 -cartoon" +sm+" "+sh+" "+thres+" "+thk+" "+col+" "+quant+\
    subprocess.call("gmic -input "+filein+" -v 0 -cartoon 1,"+sh+","+thres+","+thk+","+col+","+quant+",0 \
    -normalize[-0] 60,255 -output "+filename, shell=True)
    sleep(1)

ffmpeg -hide_banner -i leo-livebak/00025.jpg -filter_complex "[0:v]zoompan=z='if(eq(on,0),1.5+0.1*t,1)':x='if(eq(on,0),100*t,100)':y='if(eq(on,0),50*t,50)':s=640x640,unsharp=5:5:1.5:5:5:0.0[outv]" -map "[outv]" -c:v libx264 -y output4333.mp4



Path=sin(2*PI*t

ffmpeg -hide_banner -i leo-livebak/00025.jpg -filter_complex "[0:v]zoompan=z='if(eq(on,0),1.5+0.1*.02),1':x='if(eq(on,0),100*t,100)':y='if(eq(on,0),50*t,50)':s=640x640,unsharp=5:5:1.5:5:5:0.0[outv]" -map "[outv]" -c:v libx264 -y output4333.mp4


ffmpeg -hide_banner -i leo-livebak/00025.jpg -filter_complex "[0:v]zoompan=z='if(eq(on,0),1.5+0.1*sin(2*PI*t),1)':x='if(eq(on,0),100*t,100)':y='if(eq(on,0),50*t,50)':s=640x640,unsharp=5:5:1.5:5:5:0.0[outv]" -map "[outv]" -c:v libx264 -y output4333.mp4


ffmpeg -i leo-livebak/00025.jpg -vf "zoompan=z='if(eq(on,0),1.5+0.1*sin(2*PI*t),1)':x='if(eq(on,0),100*t,100)':y='if(eq(on,0),50*t,50)':s=640x640,unsharp=5:5:1.5:5:5:0.0" -c:a copy -y output4333.mp4



INPUT="leo-livebak/00040.jpg"
ZOOM_SPEED=0.0015
MAX_ZOOM=2.5
DURATION=700
W=640
H=640
OUTPUT="variables.mp4"
FPS=24
XP=-1
YP=-5
ffmpeg -i "$INPUT" \
   -vf "scale=8000:-1,zoompan=z='min(zoom+${ZOOM_SPEED},${MAX_ZOOM})':x='iw/2-iw*(1/2-${XP}/100)*on/${DURATION}-iw/zoom/2':y='ih/2-ih*(1/2-${YP}/100)*on/${DURATION}-ih/zoom/2':d=${DURATION}:fps=${FPS}:s=${W}x${H},unsharp=5:5:1.5:5:5:0.0" \
   -c:v libx264 "$OUTPUT" -y
   
vlc variables.mp4   



vlc variables.mp4

FFMPEG -hide_banner -i leo-livebak/00017.jpg -vf " scale=8000:-1,zoompan=z='min(zoom+0.0015,2.5)':d=700:x='if(gte(zoom,1.5),x,x+1/a--5)':y='if(gte(zoom,2.5),y,y-15)':s=560x560" -y live_bak001a2.mp4
vlc live_bak001a2.mp4



INPUT="leo-livebak/00040.jpg"
ZOOM_SPEED=0.0015
MAX_ZOOM=2.5
DURATION=700
W=640
H=640
OUTPUT="variables.mp4"
FPS=24
XP=-1
YP=-5
ffmpeg -i "$INPUT" \
   -vf "scale=8000:-1,zoompan=z='min(zoom+${ZOOM_SPEED},${MAX_ZOOM})':x='iw/2-iw*(1/2-${XP}/100)*on/${DURATION}-iw/zoom/2':y='ih/2-ih*(1/2-${YP}/100)*on/${DURATION}-ih/zoom/2':d=${DURATION}:fps=${FPS}:s=${W}x${H},unsharp=5:5:1.5:5:5:0.0" \
   -c:v libx264 "$OUTPUT" -y
   
vlc variables.mp4   

vlc variables.mp4  

ffmpeg -hide_banner -i leo-livebak/00025.jpg -vf "scale=8000:-1,zoompan=z='min(zoom+0.0015,1.5)':d=125:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)':s=640x640,unsharp=5:5:1.5:5:5:0.0" -c:v libx264 -y live_bak004.mp4
vlc live_bak004.mp4


ffmpeg -hide_banner -i leo-livebak/00025.jpg -vf "crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2 +((in_h-out_h)/2)*sin(n/7)" -y live_bak004.mp4


ffmpeg -hide_banner -i leo-livebak/00025.jpg -vf crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2 +((in_h-out_h)/2)*sin(n/7) -y live_bak004.mp4
vlc live_bak004.mp4

Path="sin(2*PI*t)"
ffmpeg -hide_banner -i leo-livebak/00025.jpg -filter_complex "[0:v]zoompan=z='if(eq(on,0),1.5+0.1+${Path}):x='if(eq(on,0),100*t,100)':y='if(eq(on,0),50*t,50)':s=640x640,unsharp=5:5:1.5:5:5:0.0[outv]" -map "[outv]" -c:v libx264 -y output4333.mp4


Path=sin(2*PI*t)
FFMPEG -hide_banner -i leo-livebak/00025.jpg -filter_complex "[0:v]zoompan=z='if(eq(on,0),1.5+0.1+${Path})':x='if(eq(on,0),100*t,100)':y='if(eq(on,0),50*t,50)':s=640x640,unsharp=5:5:1.5:5:5:0.0[outv]" -map "[outv]" -c:v libx264 -y output4333.mp4

Path=sin(2*PI*t)

ffmpeg -hide_banner -i leo-livebak/00025.jpg -filter_complex "[0:v]zoompan=z='if(eq(on,0),1.5+0.1*.02),1':x='if(eq(on,0),100*t,100)':y='if(eq(on,0),50*t,50)':s=640x640,unsharp=5:5:1.5:5:5:0.0[outv]" -map "[outv]" -c:v libx264 -y output4333.mp4

z='(exp(sin(t)))'

FFMPEG -hide_banner -i leo-livebak/00017.jpg -vf "zoompan=z='exp(0.001*(t/10)*0.5+1.5)':x='100*t':y='50*t':s=640x480" -c:v libx264 -y output.mp4


PATH=exp(sin(t/0.1)*0.5+1.5)

FFMPEG -hide_banner -i leo-livebak/00017.jpg -vf " scale=8000:-1,zoompan=z='min(zoom+0.0015,2.5)':d=700:x='if(gte(zoom,1.5),x,x+1/a--5)':y='if(gte(zoom,2.5),y,y-15)':s=560x560,unsharp=5:5:1.5:5:5:0.0" -y live_bak001ah2.mp4
vlc live_bak001ah2.mp4

ffmpeg -hide_banner -i leo-livebak/00017.jpg -vf "zoompan=z='exp(sin(t/0.1)*0.5+1.5)':x='100*t':y='50*t':s=640x480" -c:v libx264 -y output.mp4


FFMPEG -hide_banner -i leo-livebak/00017.jpg -vf " scale=8000:-1,zoompan=z='min(zoom+0.0015,2.5)':d=700:x='if(gte(zoom,1.5),x,x+1/a--5)':y='if(gte(zoom,2.5),y,y-15)':s=560x560,unsharp=5:5:1.5:5:5:0.0" -y live_bak001ah2.mp4
vlc live_bak001ah2.mp4

FFMPEG -hide_banner -i leo-livebak/00017.jpg -vf " scale=8000:-1,zoompan=z='min(zoom+0.0015,2.5)':d=700:x='if(gte(zoom,1.5),x,x+1/a--5)':y='if(gte(zoom,2.5),y,y-15)':s=560x560,unsharp=5:5:1.5:5:5:0.0" -y live_bak001ah2.mp4
vlc live_bak001ah2.mp4

vlc live_bak001a.mp4

FFMPEG -hide_banner -i leo-livebak/00010.jpg -vf " scale=8000:-1,zoompan=z='min(zoom+0.0015,2.5)':d=700:x='if(gte(zoom,1.5),x,x+1/a--5)':y='if(gte(zoom,2.5),y,y-15)':s=560x560" -y live_bak001a.mp4
vlc live_bak001a.mp4



FFMPEG -hide_banner -i leo-livebak/00010.jpg -vf " crop=560:560,zoompan=z='min(zoom+0.0015,1.5)':d=700:x='if(gte(zoom,1.5),x,x+1/a)':y='if(gte(zoom,1.5),y,y+1)':s=560x560" -y live_bak001.mp4


#Zoom in up to 1.5x and pan at same time to some spot near center of picture:

    zoompan=z='min(zoom+0.0015,1.5)':d=700:x='if(gte(zoom,1.5),x,x+1/a)':y='if(gte(zoom,1.5),y,y+1)':s=640x360




ls leo-livebak 

FFMPEG -i Videos/0bf7b3cb-cd74-4f4f-aada-606e74d46088+.mp4 -vf "hwupload, convolution_opencl=0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0:0 -1 0 -1 5 -1 0 -1 0, hwdownload" -y OUTPUT.mp4


ls Videos

Apply Zoom & Pan effect.

This filter accepts the following options:

zoom, z

    Set the zoom expression. Range is 1-10. Default is 1.
x
y

    Set the x and y expression. Default is 0.
d

    Set the duration expression in number of frames. This sets for how many number of frames effect will last for single input image. Default is 90.
s

    Set the output image size, default is ’hd720’.
fps

    Set the output frame rate, default is ’25’. 

Each expression can contain the following constants:

in_w, iw

    Input width.
in_h, ih

    Input height.
out_w, ow

    Output width.
out_h, oh

    Output height.
in

    Input frame count.
on

    Output frame count.
in_time, it

    The input timestamp expressed in seconds. It’s NAN if the input timestamp is unknown.
out_time, time, ot

    The output timestamp expressed in seconds.
x
y

    Last calculated ’x’ and ’y’ position from ’x’ and ’y’ expression for current input frame.
px
py

    ’x’ and ’y’ of last output frame of previous input frame or 0 when there was not yet such frame (first input frame).
zoom

    Last calculated zoom from ’z’ expression for current input frame.
pzoom

    Last calculated zoom of last output frame of previous input frame.
duration

    Number of output frames for current input frame. Calculated from ’d’ expression for each input frame.
pduration

    number of output frames created for previous input frame
a

    Rational number: input width / input height
sar

    sample aspect ratio
dar

    display aspect ratio

11.297.1 Examples

    Zoom in up to 1.5x and pan at same time to some spot near center of picture:

    zoompan=z='min(zoom+0.0015,1.5)':d=700:x='if(gte(zoom,1.5),x,x+1/a)':y='if(gte(zoom,1.5),y,y+1)':s=640x360

    Zoom in up to 1.5x and pan always at center of picture:
11.50.1 Examples

    Crop area with size 100x100 at position (12,34).

    crop=100:100:12:34

    Using named options, the example above becomes:

    crop=w=100:h=100:x=12:y=34

    Crop the central input area with size 100x100:

    crop=100:100

    Crop the central input area with size 2/3 of the input video:

    crop=2/3*in_w:2/3*in_h

    Crop the input video central square:

    crop=out_w=in_h
    crop=in_h

    Delimit the rectangle with the top-left corner placed at position 100:100 and the right-bottom corner corresponding to the right-bottom corner of the input image.

    crop=in_w-100:in_h-100:100:100

    Crop 10 pixels from the left and right borders, and 20 pixels from the top and bottom borders

    crop=in_w-2*10:in_h-2*20

    Keep only the bottom right quarter of the input image:

    crop=in_w/2:in_h/2:in_w/2:in_h/2

    Crop height for getting Greek harmony:

    crop=in_w:1/PHI*in_w

    Apply trembling effect:

    crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(n/10):(in_h-out_h)/2 +((in_h-out_h)/2)*sin(n/7)

    Apply erratic camera effect depending on timestamp:

    crop=in_w/2:in_h/2:(in_w-out_w)/2+((in_w-out_w)/2)*sin(t*10):(in_h-out_h)/2 +((in_h-out_h)/2)*sin(t*13)

    Set x depending on the value of y:

    crop=in_w/2:in_h/2:y:10+10*sin(n/10)


    zoompan=z='min(zoom+0.0015,1.5)':d=700:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)'

    Same as above but without pausing:

    zoompan=z='min(max(zoom,pzoom)+0.0015,1.5)':d=1:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)'

    Zoom in 2x into center of picture only for the first second of the input video:

    zoompan=z='if(between(in_time,0,1),2,1)':d=1:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)'



ffmpeg -i /home/jack/Desktop/EXP_notebooks/Videos/1c967f85-7d43-4b94-b2f8-0d592122f946++.mp4 -vf " scale=8000:-1,     crop=512:512,zoompan=z='min(max(zoom,pzoom)+0.0015,1.5)':d=1:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)',scale=512x512,unsharp=5:5:1.5:5:5:0.0" -aspect 1:1 -y  tytghyf.mp4

ffmpeg -i /home/jack/Desktop/EXP_notebooks/Videos/1c967f85-7d43-4b94-b2f8-0d592122f946++.mp4 -vf " crop=in_w/2:in_h/2:y:10+10*sin(n/10),zoompan=z='min(max(zoom,pzoom)+0.0015,1.5)':d=1:x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)'" -y ghyf.mp4



%%writefile MPEG
#!/usr/bin/python3
import sys
import sqlite3
conn = sqlite3.connect("/home/jack/Desktop/pas.bak/mpeg.db")
conn.text_factory = str
c = conn.cursor()
if len(sys.argv) < 3:
     print ("\n******* NOTE - Notes Editor **************")
     print ("Not enough options were passed.")     
     print ("NOTE requires 2 arguments. the first -H , -R , -I , -D or -S .\nThe second can be a period.")
     print ("If printing the database -T also add a filename of your choice ( no quotes required ):")
     print (" Example: NOTE -T Data2Text.txt")   
     print ("If wanting to read all entries use -R . (use the period)") 
     print ("even use the period with help.  -H .   must be entered.")
     print ("******************************************\n")
     sys.exit()
mod = sys.argv[1]
def create():

    import sqlite3
    conn = sqlite3.connect("/home/jack/Desktop/pas.bak/mpeg.db")
    conn.text_factory = str
    c = conn.cursor()
    c.execute("CREATE VIRTUAL TABLE PROJECT using FTS4 (input)")
    conn.commit()
    text = "Database Created"
    return text

def insert(data,conn=conn, c=c):
    c.execute("INSERT into PROJECT values (?)", (data,))
    for row in c.execute("SELECT ROWID,* FROM PROJECT ORDER BY ROWID DESC LIMIT 1"):
        print ("\nPOST VERIFIED:\n",row[0],row[1])
    conn.commit()
    conn.close()
    return data

def search(data,conn=conn, c=c):
    #for row in c.execute("SELECT ROWID,* FROM PROJECT WHERE input MATCH ?",(data,)):
    #    print ("\nINFO Found Here:",row[0],row[1])
    for row in c.execute("SELECT ROWID,* FROM PROJECT"):
        if data in row[1]:    
            print ("\nINFO Found Here:\n",row[0],row[1])
    #conn.commit()
    #conn.close()
def delete(rowid,conn=conn, c=c):
    c.execute("DELETE FROM PROJECT WHERE rowid = ?", (rowid,))
    conn.commit()
    conn.close()
    text = "ROWID "+rowid+" Deleted"
    return text

def main():
    conn = sqlite3.connect("/home/jack/Desktop/pas.bak/mpeg.db")
    conn.text_factory = str
    c = conn.cursor()
    for row in c.execute("SELECT rowid, * FROM PROJECT"):
        print (row[0],": ",row[1])

def distinct(data):
    cnt =0
    conn = sqlite3.connect("/home/jack/Desktop/pas.bak/mpeg.db")
    conn.text_factory = str
    c = conn.cursor()
    for row in c.execute("SELECT DISTINCT input FROM PROJECT order by input"):
        cnt=cnt+1
        if data in row[0]:
              print (str(cnt)+": ",row[0])
        

def prtmain(filename):
    fn = open(filename, "w")
    conn = sqlite3.connect("/home/jack/Desktop/mpeg.db")
    conn.text_factory = str
    c = conn.cursor()
    for row in c.execute("SELECT rowid, * FROM PROJECT"):
        TEXT = "id:"+str(row[0])+"\n"+str(row[1])
        TEXT = str(TEXT)
        TEXT = TEXT.replace('\\n','\n')
        TEXT = "".join(TEXT)
        fn.write(TEXT+'\n----\n')

def HELP():
    TXT = """
    USE: NOTE argv[1] argv[2]
    argv[1] sets the mod:
    -I insert / -D delete / -R read / -H help
    examples:
    Notice the entry is in parenthese.
    -I  to insert "STUFF to be inserted"
    NOTE -I "STUFF to be inserted"
    -D to delete where rowid is 3
    NOTE -D 3
    Notice the period after -R . 
    -R . read all
    To search for the term "current project"
    NOTE -S 3
    -S "current project"
    NOTE -R .
    -H help on options
    NOTE -H .
    """
    print (TXT)

if mod == "-H" or mod == "h":
    HELP()        
if mod == "-R" or mod == "-r":
    main()
if mod == "-I" or mod == "-i":
    data = sys.argv[2]
    insert(data)
if mod == "-DS" or mod == "-ds":
    data = sys.argv[2]
    distinct(data)    
if mod == "-D" or mod == "-d":
    rowid = sys.argv[2]
    delete(rowid) 
if mod == "-S" or mod == "-s":
    data = sys.argv[2]
    search(data)       
if mod == "-T":
    filename = sys.argv[2]
    prtmain(filename)
if mod == "-C" or mod == "-c":
    create()
    print (create)
else:
    print ("_________________\n")
    print (sys.argv[2],"Command Completed")
    


import sys
import sqlite3

def distinct(data):
    cnt =0
    conn = sqlite3.connect("/home/jack/Desktop/pas.bak/mpeg.db")
    conn.text_factory = str
    c = conn.cursor()
    for row in c.execute("SELECT DISTINCT input FROM PROJECT order by input"):
        cnt=cnt+1
        if data in row[0]:
              print (str(cnt)+": ",row[0])
            
            
data = "11"        
distinct(data)        



import (
    "fmt"
    "os"
    "os/user"
    "runtime"
)

{
    user, _ := user.Current()
    fmt.Printf("Go: %s (%s_%s)\n", runtime.Version(), runtime.GOOS, runtime.GOARCH)
    fmt.Printf("User: %s\n", user.Username)
    wd, _ := os.Getwd()
    fmt.Printf("Working dir: %s\n", wd)
    fmt.Printf("NumCPU: %d\n", runtime.NumCPU())
}

// naiveFib calculates the n-th fibonacci number
func naiveFib(n int) int {
    if n > 1 {
        return naiveFib(n - 1) + naiveFib(n - 2)
    }
    return 1
}

naiveFib(20)

import "fmt"

n := 10

if n > 0 {
    fmt.Println("n is positive:", n)
} else {
    fmt.Println("n is not positive:", n)
}

sum := 0
for i := 1; i <= n; i++ {
    sum += i
}
sum

switch sum {
case 55:
    fmt.Println("OK")
default:
    fmt.Println("Fail")
}

import (
    "fmt"
    "math"
)

fmt.Printf("sin(pi/3) == %f\n", math.Sin(math.Pi/3))
fmt.Printf("cos(pi/3) == %f\n", math.Cos(math.Pi/3))
fmt.Printf("sqrt(3)/2 == %f\n", math.Sqrt(3)/2)
fmt.Printf("log(e^2) == %f\n", math.Log(math.E * math.E))

import (
    "math/rand"
    "time"
)

rand.Seed(time.Now().UnixNano())
r := rand.Int()
r

r % 10000

start := time.Now()
start

end := time.Now()
end

fmt.Printf("end - start = %v", end.Sub(start))

type person struct {
    name string
    age int
}

func (p *person) Hello() string {
    return fmt.Sprintf("Hello! Name: %s, Age: %d", p.name, p.age)
}

p := person{"Alice", 12}
fmt.Printf("p.name = %q\n", p.name)
fmt.Printf("p.Hello() == %q\n", p.Hello())

type hello interface {
    Hello() string
}

func printHello(h hello) {
    if _, ok := h.(*person); ok {
        fmt.Println("h is *person")
    }
    fmt.Printf("h.Hello() == %q\n", h.Hello())
}

p := person{"Alice", 12}
printHello(&p)

// You can pass a type defined in lgo as an interface defined in Go.

import (
    "bytes"
    "fmt"
    "io"
)

type myReader struct {
    content string
    idx int
}

func (r *myReader) Read(p []byte) (n int, err error) {
    if len(p) == 0 {
        return 0, nil
    }
    if r.idx >= len(r.content) {
        return 0, io.EOF
    }
    p[0] = r.content[r.idx]
    fmt.Printf("Read %q\n", r.content[r.idx])
    r.idx++
    return 1, nil
}

{
    r := myReader{content: "Hello!"}
    var buf bytes.Buffer
    io.Copy(&buf, &r)
    fmt.Printf("buf == %q\n", buf.String())
}

// You can pass a struct defined in Go as an interface defined in lgo too.

import (
    "bytes"
    "fmt"
)

type withLen interface {
    Len() int
}

func printLen(l withLen) {
    fmt.Printf("Len(%v) == %d\n", l, l.Len())
}

{
    var buf bytes.Buffer
    buf.WriteString("01234")
    printLen(&buf)
    buf.WriteString("56789")
    printLen(&buf)
}

// return
if true {
    fmt.Println("return!")
    return
}
fmt.Println("continue!")

fmt.Println("start")
defer fmt.Println("defer (1)")
defer fmt.Println("defer (2)")
fmt.Println("end")

import "fmt"

{
    done := make(chan struct{})
    ch := make(chan int)
    // producer
    go func(){
        for i := 0; i < 10; i++ {
            ch <- i * i
        }
        close(ch)
    }()
    // consumer
    go func() {
        for i := range ch {
            fmt.Printf("i == %d\n", i)
        }
        close(done)
    }()
    <-done
}

panic("failed!")

go func() {
    panic("goroutine failed")
}()

import (
    "reflect"
)

type person struct {
    Name string
    Age int
    secret string
}

func (p *person) GetSecret() string {
    return p.secret
}

p := &person{Name:"Alice", Age: 12, secret: "1234"}

{
    t := reflect.TypeOf(p)
    fmt.Println("--- fields ---")
    for i := 0; i < t.Elem().NumField(); i++ {
        fmt.Printf("field[%d] = %s\n", i, t.Elem().Field(i).Name)
    }
    
    fmt.Println("--- methods ---")
    for i := 0; i < t.NumMethod(); i++ {
        fmt.Printf("method[%d] = %s\n", i, t.Method(i).Name)
    }

    // Set "Age" via reflect.
    v := reflect.ValueOf(p)
    v.Elem().Field(1).Set(reflect.ValueOf(34))
    
    fmt.Println("------------")
    fmt.Printf("p == %#v\n", p)
}

// Display HTML
_ctx.Display.HTML(
    `Hello <b>lgo</b>: <a target="_blank" href="https://github.com/yunabe/lgo" >GitHub lgo</a>
<div style="width:50px;height:50px;background-color:red"></div>`,
    nil)

import (
    "fmt"
    "io/ioutil"
    "net/http"    
)

var gopherPNG []byte
{
    res, err := http.Get("https://golang.org/doc/gopher/frontpage.png")
    if err != nil {
        fmt.Printf("Failed to get: %v\n", err)
        return
    }
    defer res.Body.Close()
    gopherPNG, err = ioutil.ReadAll(res.Body)
    if err != nil {
        fmt.Printf("Failed to read: %v\n", err)
        return
    }
    _ctx.Display.Text("PNG Gopher", nil)
    _ctx.Display.PNG(gopherPNG, nil)
}

import (
    "bytes"
    "image"
    jpeg "image/jpeg"
    _ "image/png"
    "os"
    
    "github.com/nfnt/resize"
)

{
    img, _, err := image.Decode(bytes.NewBuffer(gopherPNG))
    if err != nil {
        fmt.Fprintf(os.Stderr, "Failed to decode: %v", err)
        return
    }
    img = resize.Resize(100, 0, img, resize.Lanczos3)
    var buf bytes.Buffer
    jpeg.Encode(&buf, img, &jpeg.Options{Quality: 1})
    _ctx.Display.Text("Resized and highly compressed JPEG", nil)
    _ctx.Display.JPEG(buf.Bytes(), nil)
}

import (
    "bytes"
    "fmt"
    "image"
    png "image/png"
    jpeg "image/jpeg"
    "os"
    "time"
    
    "github.com/nfnt/resize"
)

{
    img, err := png.Decode(bytes.NewBuffer(gopherPNG))
    if err != nil {
        fmt.Fprintf(os.Stderr, "Failed to decode:", err)
        return
    }
    img = resize.Resize(100, 0, img, resize.Lanczos3)
    var labelID, imgID string
    for quality := 25; quality > 0; quality -= 1 {
        var buf bytes.Buffer
        jpeg.Encode(&buf, img, &jpeg.Options{Quality: quality})
        size := float32(len(buf.Bytes()))/1000
        _ctx.Display.Text(fmt.Sprintf("Quality: %d\nSize: %.2fkB", quality, size), &labelID)
        _ctx.Display.JPEG(buf.Bytes(), &imgID)
        time.Sleep(200*time.Millisecond)
    }
}

{
    x := 10 + 3.4 +
}
{
    for i := 0 {}
}

{  // L.1
    a := undefined
    
    x := 10
    y := 3.4  // L.5
    z := x + y

    unused := 10
    
    for i := 0; i; i++ {}  // L.10
    
    _, _ = a, z
}

import (
    "fmt"
    "os"
    "os/user"
    "runtime"
)

{
    user, _ := user.Current()
    fmt.Printf("Go: %s (%s_%s)\n", runtime.Version(), runtime.GOOS, runtime.GOARCH)
    fmt.Printf("User: %s\n", user.Username)
    wd, _ := os.Getwd()
    fmt.Printf("Working dir: %s\n", wd)
    fmt.Printf("NumCPU: %d\n", runtime.NumCPU())
}

// naiveFib calculates the n-th fibonacci number
func naiveFib(n int) int {
    if n > 1 {
        return naiveFib(n - 1) + naiveFib(n - 2)
    }
    return 1
}

naiveFib(20)

import "fmt"

n := 10

if n > 0 {
    fmt.Println("n is positive:", n)
} else {
    fmt.Println("n is not positive:", n)
}

sum := 0
for i := 1; i <= n; i++ {
    sum += i
}
sum

switch sum {
case 55:
    fmt.Println("OK")
default:
    fmt.Println("Fail")
}

import (
    "fmt"
    "math"
)

fmt.Printf("sin(pi/3) == %f\n", math.Sin(math.Pi/3))
fmt.Printf("cos(pi/3) == %f\n", math.Cos(math.Pi/3))
fmt.Printf("sqrt(3)/2 == %f\n", math.Sqrt(3)/2)
fmt.Printf("log(e^2) == %f\n", math.Log(math.E * math.E))

import (
    "math/rand"
    "time"
)

rand.Seed(time.Now().UnixNano())
r := rand.Int()
r

r % 10000

start := time.Now()
start

end := time.Now()
end

fmt.Printf("end - start = %v", end.Sub(start))

type person struct {
    name string
    age int
}

func (p *person) Hello() string {
    return fmt.Sprintf("Hello! Name: %s, Age: %d", p.name, p.age)
}

p := person{"Alice", 12}
fmt.Printf("p.name = %q\n", p.name)
fmt.Printf("p.Hello() == %q\n", p.Hello())

type hello interface {
    Hello() string
}

func printHello(h hello) {
    if _, ok := h.(*person); ok {
        fmt.Println("h is *person")
    }
    fmt.Printf("h.Hello() == %q\n", h.Hello())
}

p := person{"Alice", 12}
printHello(&p)

// You can pass a type defined in lgo as an interface defined in Go.

import (
    "bytes"
    "fmt"
    "io"
)

type myReader struct {
    content string
    idx int
}

func (r *myReader) Read(p []byte) (n int, err error) {
    if len(p) == 0 {
        return 0, nil
    }
    if r.idx >= len(r.content) {
        return 0, io.EOF
    }
    p[0] = r.content[r.idx]
    fmt.Printf("Read %q\n", r.content[r.idx])
    r.idx++
    return 1, nil
}

{
    r := myReader{content: "Hello!"}
    var buf bytes.Buffer
    io.Copy(&buf, &r)
    fmt.Printf("buf == %q\n", buf.String())
}

// You can pass a struct defined in Go as an interface defined in lgo too.

import (
    "bytes"
    "fmt"
)

type withLen interface {
    Len() int
}

func printLen(l withLen) {
    fmt.Printf("Len(%v) == %d\n", l, l.Len())
}

{
    var buf bytes.Buffer
    buf.WriteString("01234")
    printLen(&buf)
    buf.WriteString("56789")
    printLen(&buf)
}

// return
if true {
    fmt.Println("return!")
    return
}
fmt.Println("continue!")

fmt.Println("start")
defer fmt.Println("defer (1)")
defer fmt.Println("defer (2)")
fmt.Println("end")

import "fmt"

{
    done := make(chan struct{})
    ch := make(chan int)
    // producer
    go func(){
        for i := 0; i < 10; i++ {
            ch <- i * i
        }
        close(ch)
    }()
    // consumer
    go func() {
        for i := range ch {
            fmt.Printf("i == %d\n", i)
        }
        close(done)
    }()
    <-done
}

panic("failed!")

go func() {
    panic("goroutine failed")
}()

import (
    "reflect"
)

type person struct {
    Name string
    Age int
    secret string
}

func (p *person) GetSecret() string {
    return p.secret
}

p := &person{Name:"Alice", Age: 12, secret: "1234"}

{
    t := reflect.TypeOf(p)
    fmt.Println("--- fields ---")
    for i := 0; i < t.Elem().NumField(); i++ {
        fmt.Printf("field[%d] = %s\n", i, t.Elem().Field(i).Name)
    }
    
    fmt.Println("--- methods ---")
    for i := 0; i < t.NumMethod(); i++ {
        fmt.Printf("method[%d] = %s\n", i, t.Method(i).Name)
    }

    // Set "Age" via reflect.
    v := reflect.ValueOf(p)
    v.Elem().Field(1).Set(reflect.ValueOf(34))
    
    fmt.Println("------------")
    fmt.Printf("p == %#v\n", p)
}

// Display HTML
_ctx.Display.HTML(
    `Hello <b>lgo</b>: <a target="_blank" href="https://github.com/yunabe/lgo" >GitHub lgo</a>
<div style="width:50px;height:50px;background-color:red"></div>`,
    nil)

import (
    "fmt"
    "io/ioutil"
    "net/http"    
)

var gopherPNG []byte
{
    res, err := http.Get("https://golang.org/doc/gopher/frontpage.png")
    if err != nil {
        fmt.Printf("Failed to get: %v\n", err)
        return
    }
    defer res.Body.Close()
    gopherPNG, err = ioutil.ReadAll(res.Body)
    if err != nil {
        fmt.Printf("Failed to read: %v\n", err)
        return
    }
    _ctx.Display.Text("PNG Gopher", nil)
    _ctx.Display.PNG(gopherPNG, nil)
}

import (
    "bytes"
    "image"
    jpeg "image/jpeg"
    _ "image/png"
    "os"
    
    "github.com/nfnt/resize"
)

{
    img, _, err := image.Decode(bytes.NewBuffer(gopherPNG))
    if err != nil {
        fmt.Fprintf(os.Stderr, "Failed to decode: %v", err)
        return
    }
    img = resize.Resize(100, 0, img, resize.Lanczos3)
    var buf bytes.Buffer
    jpeg.Encode(&buf, img, &jpeg.Options{Quality: 1})
    _ctx.Display.Text("Resized and highly compressed JPEG", nil)
    _ctx.Display.JPEG(buf.Bytes(), nil)
}

import (
    "bytes"
    "fmt"
    "image"
    png "image/png"
    jpeg "image/jpeg"
    "os"
    "time"
    
    "github.com/nfnt/resize"
)

{
    img, err := png.Decode(bytes.NewBuffer(gopherPNG))
    if err != nil {
        fmt.Fprintf(os.Stderr, "Failed to decode:", err)
        return
    }
    img = resize.Resize(100, 0, img, resize.Lanczos3)
    var labelID, imgID string
    for quality := 25; quality > 0; quality -= 1 {
        var buf bytes.Buffer
        jpeg.Encode(&buf, img, &jpeg.Options{Quality: quality})
        size := float32(len(buf.Bytes()))/1000
        _ctx.Display.Text(fmt.Sprintf("Quality: %d\nSize: %.2fkB", quality, size), &labelID)
        _ctx.Display.JPEG(buf.Bytes(), &imgID)
        time.Sleep(200*time.Millisecond)
    }
}

{
    x := 10 + 3.4 +
}
{
    for i := 0 {}
}

{  // L.1
    a := undefined
    
    x := 10
    y := 3.4  // L.5
    z := x + y

    unused := 10
    
    for i := 0; i; i++ {}  // L.10
    
    _, _ = a, z
}





        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

from moviepy.editor import VideoFileClip, concatenate_videoclips
import os

def join_mp4_files(directory, output_file):
    video_clips = []
    
    # Iterate through all files in the directory
    for filename in os.listdir(directory):
        if filename.endswith(".mp4"):
            filepath = os.path.join(directory, filename)
            video_clips.append(VideoFileClip(filepath))
    
    # Concatenate all video clips
    final_clip = concatenate_videoclips(video_clips)
    
    # Write the final concatenated clip to the output file
    final_clip.write_videofile(output_file)
    
    # Close the clips to release resources
    for clip in video_clips:
        clip.close()

# Directory containing *.mp4 files
input_directory = "Videos"

# Output file name
output_file = "ALL_videos.mp4"

# Call the function to join the *.mp4 files
join_mp4_files(input_directory, output_file)


!ffmpeg -i ALL_videos.mp4 -vf "fps=60,scale=8000:-1,zoompan=z='pzoom+0.0001':x=iw/2-(iw/zoom/2):y=ih/2-(ih/zoom/2):d=100:s=512x768:fps=60" -c:v libx264 -pix_fmt yuv420p outputALL_videos2.mp4

import subprocess
import numpy as np
import logging
import glob
import random
# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Build the updated ffmpeg command with zoom pan effect
        ffmpeg_cmd = [
            'ffmpeg',
            '-i', input_path,
            '-vf', "scale=24000:-1,zoompan=z='if(lte(zoom,1.0),1.5,max(1.001,zoom-0.0003))':x=iw/2-(iw/zoom/2):y=ih/2-(ih/zoom/2):d=25*60:s=512x768:fps=60",
            '-c:a', 'aac',
            '-c:v', 'libx264',
            '-y',  # Overwrite output file if it already exists
            output_path
        ]

        # Run the ffmpeg command using subprocess
        subprocess.run(ffmpeg_cmd, check=True)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except subprocess.CalledProcessError as e:
        logging.error(f"An error occurred while running ffmpeg: {e}")
    except Exception as e:
        logging.error(f"An unexpected error occurred: {str(e)}")



# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = str(uuid.uuid4()) + ".mp4"


    zoom_pan_nonlinear(input_image_path, output_video_path)