-
!ffmpeg -loop 1 -framerate 60 -i image.jpg -vf "scale=24000:-1,zoompan=z='if(lte(zoom,1.0),1.5,max(1.001,zoom-0.0003))':x=iw/2-(iw/zoom/2):y=ih/2-(ih/zoom/2):d=25*60:s=512x768:fps=60" -t 25 -c:v libx264 -pix_fmt yuv420p -y outputZZ.mp4
!vlc  outputZZ.mp4  

!ffmpeg -loop 1 -framerate 60 -i image.jpg -vf "scale=24000:-1,zoompan=z='if(lte(zoom,1.0),1.5,max(1.001,zoom-0.0003))':x=iw/2-(iw/zoom/2):y=ih/2-(ih/zoom/2):d=25*60:s=512x768:fps=60" -t 25 -c:v libx264 -pix_fmt yuv420p -y outputZZ.mp4
!vlc  outputZZ.mp4  

!add_frame outputZZ.mp4  

!vlc outputZZ.mp4 





!ffmpeg -loop 1 -framerate 60 -i yodayofeb6/00047.jpg -vf "scale=8000:-1,zoompan=z='zoom+0.001':x=iw/2-(iw/zoom/2):y=ih/2-(ih/zoom/2):d=35*60:s=512x768:fps=60" -t 35 -c:v libx264 -pix_fmt yuv420p -y output3.mp4
    
!vlc  output3.mp4  





!ffmpeg -loop 1 -framerate 60 -i image.jpg -vf "scale=8000:-1,zoompan=z='zoom+0.001':x=iw/2-(iw/zoom/2):y=ih/2-(ih/zoom/2):d=15*60:s=512x768:fps=60" -t 15 -c:v libx264 -pix_fmt yuv420p -y output1.mp4
    
!vlc  output1.mp4  



!ffmpeg -loop 1 -framerate 60 -i image.jpg -vf "scale=8000:-1,zoompan=z='zoom+0.001':x=iw/2-(iw/zoom/2):y=ih/2-(ih/zoom/2):d=5*60:s=512x768:fps=60" -t 5 -c:v libx264 -pix_fmt yuv420p -y output.mp4

import subprocess
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Build the updated ffmpeg command with zoom pan effect
        ffmpeg_cmd = [
            'ffmpeg',
            '-i', input_path,
            '-vf', f'zoompan=z=\'if(eq(on,0),1.5+0.1*sin(2*PI*t),1)\':x=\'if(eq(on,0),100*t,100)\':y=\'if(eq(on,0),50*t,50)\':fps=24',
            '-c:a', 'aac',
            '-c:v', 'libx264',
            '-y',  # Overwrite output file if it already exists
            output_path
        ]

        # Run the ffmpeg command using subprocess
        subprocess.run(ffmpeg_cmd, check=True)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except subprocess.CalledProcessError as e:
        logging.error(f"An error occurred while running ffmpeg: {e}")
    except Exception as e:
        logging.error(f"An unexpected error occurred: {str(e)}")



# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)


!vlc output.mp4





import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = (clip.fx(mp.vfx.mirror_x)
                         .fx(mp.vfx.freeze, 2)
                         .fx(mp.vfx.speedx, 0.5)
                         .resize(0.8)
                         .set_position(('center', 'center'))
                         .fl(lambda gf, t: gf(t).set_position(path(t))))

        # Set the frames per second (fps) for the final video
        fps = 24

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip.set_duration(5)], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path with the specified fps
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac', fps=fps)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)




import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = (clip.fx(mp.vfx.mirror_x)
                         .fx(mp.vfx.freeze, 2)
                         .fx(mp.vfx.speedx, 0.5)
                         .resize(0.8)
                         .set_position(('center', 'center'))
                         .set_position(lambda t: path(t)))

        # Set the frames per second (fps) for the final video
        fps = 24

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip.set_duration(5)], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path with the specified fps
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac', fps=fps)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)


import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = (clip.fx(mp.vfx.mirror_x)
                         .fx(mp.vfx.freeze, 2)
                         .fx(mp.vfx.speedx, 0.5)
                         .set_position(lambda t: ('center', 'center'))
                         .resize(0.8)
                         .set_position(lambda t: path(t)))

        # Set the frames per second (fps) for the final video
        fps = 24

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip.set_duration(5)], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path with the specified fps
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac', fps=fps)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)




import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.fx(mp.vfx.mirror_x)
        zoom_pan_clip = zoom_pan_clip.fx(mp.vfx.freeze, 2)
        zoom_pan_clip = zoom_pan_clip.fx(mp.vfx.speedx, 0.5)
        zoom_pan_clip = zoom_pan_clip.set_position(('center', 'center')).resize(0.8)

        # Apply the non-linear path to the position
        zoom_pan_clip = zoom_pan_clip.set_position(lambda t: ('center', 'center')).set_position(path)

        # Set the frames per second (fps) for the final video
        fps = 24

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip.set_duration(5)], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path with the specified fps
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac', fps=fps)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)


import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.fx(mp.vfx.mirror_x)
        zoom_pan_clip = zoom_pan_clip.fx(mp.vfx.freeze, 2)
        zoom_pan_clip = zoom_pan_clip.fx(mp.vfx.speedx, 0.5)
        zoom_pan_clip = zoom_pan_clip.set_position(('center', 'center')).resize(0.8)

        # Apply the non-linear path to the position
        zoom_pan_clip = zoom_pan_clip.fl(lambda gf, t: gf(t).set_position(('center', 'center')).set_position(('center', 'center')).set_position(('center', 'center')).set_position(path(t)))

        # Set the frames per second (fps) for the final video
        fps = 24

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip.set_duration(5)], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path with the specified fps
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac', fps=fps)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)




import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.fx(mp.vfx.mirror_x)
        zoom_pan_clip = zoom_pan_clip.fx(mp.vfx.freeze, 2)
        zoom_pan_clip = zoom_pan_clip.fx(mp.vfx.speedx, 0.5)
        zoom_pan_clip = zoom_pan_clip.set_position(('center', 'center')).resize(0.8)

        # Set the frames per second (fps) for the final video
        fps = 24

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip.set_duration(5)], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path with the specified fps
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac', fps=fps)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)




import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = (clip.fx(mp.vfx.zoom_in, 1.5)
                         .fx(mp.vfx.zoom_out, 1.5)
                         .fl(lambda gf, t: gf(t)[:, int(path(t)[1]):int(path(t)[1]) + clip.size[1]]))

        # Set the frames per second (fps) for the final video
        fps = 24

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip.set_duration(5)], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path with the specified fps
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac', fps=fps)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)


import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.resize(1.5).zoom(1.5).fl(lambda gf, t: gf(t)[:, int(path(t)[1]):int(path(t)[1])+clip.size[1]])

        # Set the frames per second (fps) for the final video
        fps = 24

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip.set_duration(5)], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path with the specified fps
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac', fps=fps)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)




import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.resize(1.5).fl(lambda gf, t: gf(t)[:, int(path(t)[1]):int(path(t)[1])+clip.size[1]])

        # Set the frames per second (fps) for the final video
        fps = 24

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path with the specified fps
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac', fps=fps)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":  
    
    input_image_path = "yodayofeb6/9b9c9202-a5d1-45ba-b262-2f5d93731a61_width=512&height=768.jpg"
    output_video_path = "video.mp4"
    
    zoom_pan_nonlinear(input_image_path, output_video_path)


!vlc video.mp4

import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.resize(1.5).fl(lambda gf, t: gf(t)[:, int(path(t)[1]):int(path(t)[1])+clip.size[1]])

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac')

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "yodayofeb6/9b9c9202-a5d1-45ba-b262-2f5d93731a61_width=512&height=768.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)


import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.resize(1.5).fx(mp.vfx.pan, path)

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac')

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "yodayofeb6/9b9c9202-a5d1-45ba-b262-2f5d93731a61_width=512&height=768.jpg"
    output_video_path = "video.mp4"
    zoom_pan_nonlinear(input_image_path, output_video_path)


import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.fx(mp.fx.resize, 1.5).fx(mp.pan, path)

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac')

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "/home/jack/Desktop/EXP_notebooks/yodayofeb6/9b9c9202-a5d1-45ba-b262-2f5d93731a61_width=512&height=768.jpg"
    output_video_path = "video.mp4"
    zoom_pan_nonlinear(input_image_path, output_video_path)


import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.fx(mp.resize, 1.5).fx(mp.pan, path)

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac')

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "/home/jack/Desktop/EXP_notebooks/yodayofeb6/9b9c9202-a5d1-45ba-b262-2f5d93731a61_width=512&height=768.jpg"
    output_video_path = "video.mp4"
    zoom_pan_nonlinear(input_image_path, output_video_path)


import moviepy.editor as mp
import numpy as np
import logging

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_path):
    try:
        # Load the image
        clip = mp.ImageClip(input_path, duration=5)

        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Apply the zoom pan effect with the non-linear path
        zoom_pan_clip = clip.fx(mp.zoom.in_scale, 1.5).fx(mp.pan, path)

        # Set up the final video clip
        final_clip = mp.CompositeVideoClip([zoom_pan_clip], size=(clip.size[0], clip.size[1]))

        # Write the final video to the specified output path
        final_clip.write_videofile(output_path, codec='libx264', audio_codec='aac')

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "/home/jack/Desktop/EXP_notebooks/yodayofeb6/9b9c9202-a5d1-45ba-b262-2f5d93731a61_width=512&height=768.jpg"
    output_video_path = "video.mp4"

    zoom_pan_nonlinear(input_image_path, output_video_path)


import glob
import random
from PIL import Image
DIR= random.choice(glob.glob("/home/jack/Desktop/collections_mount/images/*"))+"/"
print(DIR)
imaGE = random.choice(glob.glob(DIR+"*.jpg"))
print (imaGE)
im =Image.open(imaGE)
im

import glob
import random
from PIL import Image
DIR= random.choice(glob.glob("/home/jack/Desktop/collections_mount/images/*"))+"/"
print(DIR)
imaGE = random.choice(glob.glob(DIR+"*.jpg"))
print (imaGE)
im =Image.open(imaGE)
im

import subprocess
import numpy as np
import logging
import uuid
import os
# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_dir):
    try:
        # Define a non-linear path (in this case, a bezier curve)
        path = lambda t: (100 * np.sin(2 * np.pi * t), 50 * np.cos(2 * np.pi * t))

        # Generate a unique filename for the output video
        output_filename = str(uuid.uuid4()) + ".mp4"
        output_path = os.path.join(output_dir, output_filename)

        # Build the updated ffmpeg command with zoom pan effect
        ffmpeg_cmd = [
            'ffmpeg',
            '-i', input_path,
            '-vf', f'zoompan=z=\'if(eq(on,0),1.5+0.1*sin(2*PI*t),1)\':x=\'if(eq(on,0),100*t,100)\':y=\'if(eq(on,0),50*t,50)\':fps=24',
            '-c:a', 'aac',
            '-c:v', 'libx264',
            '-y',  # Overwrite output file if it already exists
            output_path
        ]

        # Run the ffmpeg command using subprocess
        subprocess.run(ffmpeg_cmd, check=True)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except subprocess.CalledProcessError as e:
        logging.error(f"An error occurred while running ffmpeg: {e}")
    except Exception as e:
        logging.error(f"An unexpected error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_directory = "Videos"

    zoom_pan_nonlinear(input_image_path, output_directory)


!mkdir Videos

import subprocess
import numpy as np
import logging
import uuid

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_dir):
    try:
        # Generate a unique filename for the output video
        output_filename = str(uuid.uuid4()) + ".mp4"
        output_path = os.path.join(output_dir, output_filename)

        # Build the updated ffmpeg command with zoom pan effect
        ffmpeg_cmd = [
            'ffmpeg',
            '-i', input_path,
            '-vf', f'zoompan=z=\'if(eq(on,0),1.5+0.1*sin(2*PI*t),1)\':x=\'if(eq(on,0),100*t,100)\':y=\'if(eq(on,0),50*t,50)\':fps=24',
            '-c:a', 'aac',
            '-c:v', 'libx264',
            '-y',  # Overwrite output file if it already exists
            output_path
        ]

        # Run the ffmpeg command using subprocess
        subprocess.run(ffmpeg_cmd, check=True)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except subprocess.CalledProcessError as e:
        logging.error(f"An error occurred while running ffmpeg: {e}")
    except Exception as e:
        logging.error(f"An unexpected error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_directory = "Videos"

    zoom_pan_nonlinear(input_image_path, output_directory)


import subprocess
import numpy as np
import logging
import os
import uuid

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')

def zoom_pan_nonlinear(input_path, output_dir):
    try:
        # Generate a unique filename for the output video
        output_filename = str(uuid.uuid4()) + ".mp4"
        output_path = os.path.join(output_dir, output_filename)

        # Build the updated ffmpeg command with zoom pan effect
        ffmpeg_cmd = [
            'ffmpeg','-hide_banner',
            '-i', input_path,
            '-vf', f'zoompan=d=5:fps=24:z=\'if(eq(on,0),1.5+0.1*sin(2*PI*t),1)\':x=\'if(eq(on,0),100*t,100)\':y=\'if(eq(on,0),50*t,50)\':s=WxH',
            '-c:a', 'aac',
            '-c:v', 'libx264',
            '-y',  # Overwrite output file if it already exists
            output_path
        ]

        # Run the ffmpeg command using subprocess
        subprocess.run(ffmpeg_cmd, check=True)

        logging.info(f"Zoom pan effect with a non-linear path applied. Output saved to {output_path}")

    except subprocess.CalledProcessError as e:
        logging.error(f"An error occurred while running ffmpeg: {e}")
    except Exception as e:
        logging.error(f"An unexpected error occurred: {str(e)}")

# Example usage
if __name__ == "__main__":
    input_image_path = "image.jpg"
    output_directory = "Videos"

    zoom_pan_nonlinear(input_image_path, output_directory)


!ffmpeg -hide_banner -i image.jpg -vf \ "zoompan=d=5:fps=24:z='if(eq(on,0),1.5+0.1*sin(2*PI*t),1)':x='if(eq(on,0),100*t,100)':y='if(eq(on,0),50*t,50)':s=512x768" \
-c:a aac -c:v libx264 -y outputss.mp4


!ffmpeg -hide_banner -i image.jpg -vf \ "zoompan=d=5:fps=24:z='if(eq(on,0),1.5+0.1*sin(2*PI*t),1)':x='if(eq(on,0),100*t,100)':y='if(eq(on,0),50*t,50)':s=512x768" \
-c:a aac -c:v libx264 -y outputss.mp4


!ffmpeg -f lavfi -i haldclutsrc=8 -vf "hue=H=2*PI*t:s=sin(2*PI*t)+1, curves=cross_process" -t 10 -c:v ffv1 clut.nut

!ffmpeg -f lavfi -i mandelbrot -i clut.nut -filter_complex '[0][1] haldclut' -t 20 mandelclut.mkv

!ffmpeg -f lavfi -i haldclutsrc=8 -vf "hue=H=2*PI*t:s=sin(2*PI*t)+.001, curves=cross_process" -t 120 -c:v ffv1 -y clut1.nut

!ffmpeg -f lavfi -i mandelbrot -i clut1.nut -filter_complex '[0][1] haldclut' -t 160 -y mandelclut40.mkv

!vlc mandelclut40.mkv

ffmpeg -i input.mp4 -ignore_loop 0 -i input.gif -filter_complex overlay=shortest=1 out.mkv



# Pedro Alcocer
# http://art.pedroalcocer.com

import numpy as np

import vsketch


def bug(x, y):
    ts = [682, 268, 624, 98]
    xy_max = 143.25

    for _ in range(0, 150, 12):
        random = vsk.random(1)
        ts = [t * random + 0.24 for t in ts]

        x1 = np.interp(vsk.noise(ts[0]), [-1, 1], [0, xy_max])
        y1 = np.interp(vsk.noise(ts[1]), [-1, 1], [0, xy_max])
        x2 = np.interp(vsk.noise(ts[2]), [-1, 1], [0, xy_max])
        y2 = np.interp(vsk.noise(ts[3]), [-1, 1], [0, xy_max])
        x3 = np.interp(vsk.noise(ts[3]), [-1, 1], [0, xy_max])
        y3 = np.interp(vsk.noise(ts[2]), [-1, 1], [0, xy_max])
        x4 = np.interp(vsk.noise(ts[1]), [-1, 1], [0, xy_max])
        y4 = np.interp(vsk.noise(ts[0]), [-1, 1], [0, xy_max])

        with vsk.pushMatrix():
            vsk.translate(x, y)
            vsk.rotate(45, degrees=True)
            vsk.bezier(x1, y1, x2, y2, x3, y3, x4, y4)


vsk = vsketch.Vsketch()
vsk.size("10in", "10in")

for row in range(7):
    for col in range(7):
        x = col * 100.5
        y = row * 100.5
        bug(x, y)

vsk.display(fig_size=(12, 12))
vsk.save("bezier_bugs3.svg")#, color_mode="none")



# Pedro Alcocer
# http://art.pedroalcocer.com

import numpy as np

import vsketch


def bug(x, y):
    ts = [682, 268, 624, 98]
    xy_max = 143.25

    for _ in range(0, 150, 12):
        random = vsk.random(1)
        ts = [t * random + 0.24 for t in ts]

        x1 = np.interp(vsk.noise(ts[0]), [-1, 1], [0, xy_max])
        y1 = np.interp(vsk.noise(ts[1]), [-1, 1], [0, xy_max])
        x2 = np.interp(vsk.noise(ts[2]), [-1, 1], [0, xy_max])
        y2 = np.interp(vsk.noise(ts[3]), [-1, 1], [0, xy_max])
        x3 = np.interp(vsk.noise(ts[3]), [-1, 1], [0, xy_max])
        y3 = np.interp(vsk.noise(ts[2]), [-1, 1], [0, xy_max])
        x4 = np.interp(vsk.noise(ts[1]), [-1, 1], [0, xy_max])
        y4 = np.interp(vsk.noise(ts[0]), [-1, 1], [0, xy_max])

        with vsk.pushMatrix():
            vsk.translate(x, y)
            vsk.rotate(45, degrees=True)
            vsk.bezier(x1, y1, x2, y2, x3, y3, x4, y4)


vsk = vsketch.Vsketch()
vsk.size("10in", "10in")

for row in range(7):
    for col in range(7):
        x = col * 100.5
        y = row * 100.5
        bug(x, y)

vsk.display(mode="matplotlib", fig_size=(12, 12))
vsk.save("bezier_bugs.svg", color_mode="none")

import sqlite3
conn = sqlite3.connect('data/biblenum.db')
c = conn.cursor()
c.execute("""
CREATE VIRTUAL TABLE verse 
USING FTS3(scripture);
""")
conn.commit()
conn.close()

def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
    return i + 1
fname="bible2.txt"
file_len(fname)

import time
from itertools import islice

with open("bible2.txt") as biblelines:
    heads = list(islice(biblelines, 31102))
    for head in heads:
        print head


select rowid,* from verse

import sqlite3
import sys
conn = sqlite3.connect('data/biblenum.db')
c = conn.cursor()# Never 
count=0
req=4
def remove_cruft(s):
    return s[5:-4]
for row in c.execute('SELECT rowid,* FROM verse WHERE scripture MATCH "beginning"'):
    count=count+1
    print(row)
    if count > req:
        conn.close()
        sys.exit()

import sqlite3
import sys
#conn = sqlite3.connect('data/bible.db')
conn = sqlite3.connect('data/biblenum.db')
c = conn.cursor()
count=0
req=100
for row in c.execute('SELECT rowid,* FROM verse WHERE scripture MATCH "youngest"'):
    count=count+1
    print count,"Occurances : ","Verse Numbers :",(row)[0],"\n",(row)[1]
    if count > req:
        conn.close()
        sys.exit()

import re
import textwrap
import time
import sqlite3
import sys
import base64
import time
from itertools import islice
#conn = sqlite3.connect('hurricane.db')
#c = conn.cursor()
# Create table
#c.execute('''CREATE TABLE hurricane
#             (hurricane text, keywords text)''')
count=0#lines = 400
def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
    return i + 1
fname="bible2.txt"
num = file_len(fname)
with open(fname) as myfile:
    heads = list(islice(myfile,31102))
    for head in heads:
        #head = list(islice(heads, 1))
        #time.sleep(.5)
        conn = sqlite3.connect('data/bible.db')
        c = conn.cursor()
        #c.execute("INSERT INTO verse VALUES (?)", (head)) 
        conn.commit()
        conn.close()        
        #time.sleep(.5)
        print head
        count=count+1
        print count
        #if count>lines:




import re
import textwrap
import time
import sqlite3
import sys
import base64
import time
from itertools import islice
count=1
def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
    return i + 1
fname="bible2.txt"
num = file_len(fname)
with open(fname) as myfile:
    heads = list(islice(myfile,31102))
    for head in heads:
        textin = head
        conn = sqlite3.connect('data/biblenum.db')
        c = conn.cursor()
        c.execute("INSERT INTO verse VALUES (?)", (textin,)) 
        conn.commit()
        conn.close()        
        #time.sleep(.5)
        print textin
        count=count+1
        print count
        #if count>lines:


import re
import textwrap
import time
import sqlite3
import sys
import base64
import time
from itertools import islice
#conn = sqlite3.connect('hurricane.db')
#c = conn.cursor()
# Create table
#c.execute('''CREATE TABLE hurricane
#             (hurricane text, keywords text)''')
count=1
#lines = 400
def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
    return i + 1
fname="bible2.txt"
num = file_len(fname)
with open(fname) as myfile:
    heads = list(islice(myfile,31102))
    for head in heads:
        #head = list(islice(heads, 1))
        #time.sleep(.5)
        
        textin = count,",",head
        conn = sqlite3.connect('data/biblenum.db')
        c = conn.cursor()
        c.execute("INSERT INTO verse VALUES (?)", (textin,)) 
        conn.commit()
        conn.close()        
        #time.sleep(.5)
        print textin
        count=count+1
        print count
        #if count>lines:


import re
import textwrap
import time
import sqlite3
import sys
import base64
import time
from itertools import islice
#conn = sqlite3.connect('hurricane.db')
#c = conn.cursor()
# Create table
#c.execute('''CREATE TABLE hurricane
#             (hurricane text, keywords text)''')
count=0#lines = 400
def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
    return i + 1
fname="bible2.txt"
num = file_len(fname)
with open(fname) as myfile:
    heads = list(islice(myfile,31102))
    for head in heads:
        #head = list(islice(heads, 1))
        #time.sleep(.5)
        conn = sqlite3.connect('data/bible.db')
        c = conn.cursor()
        #c.execute("INSERT INTO verse VALUES (?)", (head)) 
        conn.commit()
        conn.close()        
        #time.sleep(.5)
        print head
        count=count+1
        print count
        #if count>lines:


import re
import textwrap
import time
import sqlite3
import sys
import base64
import time
#conn = sqlite3.connect('hurricane.db')
#c = conn.cursor()
# Create table
#c.execute('''CREATE TABLE hurricane
#             (hurricane text, keywords text)''')
count=0
#lines = 400

with open("bible2.txt") as myfile:
    for head in heads:
        head = [next(myfile) for x in xrange(1)]
        time.sleep(1)
        conn = sqlite3.connect('data/bible.db')
        c = conn.cursor()
        c.execute("INSERT INTO verse VALUES (?)", (head)) 
        conn.commit()
        conn.close()        
        time.sleep(1)
        print head
        count=count+1
        print count
        #if count>lines:
            
#commits and closes database if there are less then 400 lines of text
conn.commit()
conn.close() 
sys.exit()

import re
import textwrap
import time
import sqlite3
import sys
import base64
import time
from itertools import islice
#conn = sqlite3.connect('hurricane.db')
#c = conn.cursor()
# Create table
#c.execute('''CREATE TABLE hurricane
#             (hurricane text, keywords text)''')
count=0
#lines = 400
def file_len(fname):
    with open(fname) as f:
        for i, l in enumerate(f):
            pass
    return i + 1


fname="bible2.txt"
num =file_len(fname)




with open("bible2.txt") as myfile:
    heads = list(islice(myfile,1000))
    for head in heads:
        head = list(islice(myfile, 1))
        time.sleep(1)
        conn = sqlite3.connect('data/bible.db')
        c = conn.cursor()
        c.execute("INSERT INTO verse VALUES (?)", (head)) 
        conn.commit()
        conn.close()        
        time.sleep(1)
        print head
        count=count+1
        print count
        #if count>lines:


---------------------------------------------------

---------------------------------------------------

---------------------------------------------------

import sqlite3
def insert_info(tweet):
    with sqlite3.connect("data/twitter.db") as db:
        cursor = db.cursor()
        sql = "insert into twitter (twittername,twitterid,keywords) values (?, ?, ?)"
        cursor.execute(sql, tweet)
        db.commit()

#if __name__ == "__main__":
print "You will be promted to enter TwitterName, TwitterID Number, and Keywords  "  
twittername = raw_input("Enter Twitter Name: >>")
twitterid = raw_input("Enter Twitter Number: >>")
keywords = raw_input("Enter Keywords: >>")
tweet = (twittername,twitterid,keywords)
insert_info(tweet)

import sqlite3
conn = sqlite3.connect('data/twitter.db')
c = conn.cursor()# Never do this -- insecure!

#t = ('Hurricane',)
#c.execute('SELECT * FROM twitter ORDER BY keywords')
#print(c.fetchall())
#conn.close()

for row in c.execute('SELECT * FROM twitter ORDER BY contact_id'):
        #print(row),"\n-----\n","\n"
        
        print row[0],"  ",row[1],"  ",row[2],"  ",row[3],"\n-----\n",

conn.close()


import sqlite3
conn = sqlite3.connect('data/bible3.db')
c = conn.cursor()
c.execute("""
CREATE VIRTUAL TABLE verse 
USING FTS3(text);
""")
conn.commit()
conn.close()

import time
with open("bible2.txt") as myfile:
    for head in heads:
        head = [next(myfile) for x in xrange(1)]
        time.sleep(1)
        print head

import sqlite3
import sys
conn = sqlite3.connect('data/bible3.db')
c = conn.cursor()# Never 
count=0
req=100
for row in c.execute('SELECT * FROM verse'):
    count=count+1
    print(row),"\n-----\n"
    if count > req:
        conn.close()
        sys.exit()
        

import re
import textwrap
import time
import sqlite3
import sys
import base64
import time
#conn = sqlite3.connect('hurricane.db')
#c = conn.cursor()
# Create table
#c.execute('''CREATE TABLE hurricane
#             (hurricane text, keywords text)''')
count=0
#lines = 400

with open("bible2.txt") as myfile:
    for head in heads:
        head = [next(myfile) for x in xrange(1)]
        time.sleep(1)
 
        conn = sqlite3.connect('data/bible3.db')
        c = conn.cursor()
        time.sleep(1)
        #encodedlistvalue=base64.b64encode(file[2:-2])
        #c.execute("INSERT INTO hurricane VALUES (?,?)", (encodedlistvalue, b)) 
        c.execute("INSERT INTO verse VALUES (?)", (head)) 
        conn.commit()
        conn.close()        
        time.sleep(1)
        print head
        count=count+1
        print count
        #if count>lines:
            
#commits and closes database if there are less then 400 lines of text
conn.commit()
conn.close() 
sys.exit()

%%writefile record.py
#!/usr/bin/python2.7
#########################################################
#### PyRecordDesktop 0.1
#### By Bogdan Milanovic
####
#### In the absence of a decent linux application that
#### records a desktop into a video (and no, the
#### recordMyDesktop does not qualify as one), I have 
#### decided to write my own.
####
#### PyRecordDesktop uses ffmpeg (which most distros come
#### installed with) to capture the video and encode it
#### on the fly. It also uses ALSA to capture the sound
#### from any input devices (such as a microphone). 
#### A Qt powered GUI is planned.
#########################################################

import subprocess
import sys
import argparse
import shlex
import os

#First we define the default values of the main parameters
DEFAULT_RESOLUTION = "1280x720"
DEFAULT_CODEC = "h264"
DEFAULT_OUTPUTFILE = "output.avi"

#Then we define tuples (immutable) of the supported formats and resolutions.
#Hopefully we'll be able to grab these values automatically in the future
RESOLUTION_LIST = ("1920x1080", "1366x768", "1280x720")
CODEC_LIST = ("mpeg4", "flv", "h264")

#Parsing the arguments given in the command line
#These arguments include: output file, desired recording resolution, and the video encoding codec
parser = argparse.ArgumentParser()
parser.add_argument("outputfile", help="The output filename")
parser.add_argument("--res", help="Recording resolution: 1920x1080, 1366x768, or 1280x720")
parser.add_argument("--codec", help="Video encoding codec: libx264, mpeg4, flv, h264")
args = parser.parse_args()

#We check to make sure that the arguments have been passed 
#Otherwise we use the default values  as defined above
resolution = args.res if args.res else DEFAULT_RESOLUTION
codec = args.codec if args.codec else DEFAULT_CODEC
outputfile = args.outputfile if args.outputfile else DEFAULT_OUTPUTFILE

#A couple of checks to make sure the resolution and the codec are valid
if resolution not in RESOLUTION_LIST:
	print "Invalid resolution. Run {0} -h for details".format(__file__)
	sys.exit(1)

if codec not in CODEC_LIST:
	print "Invalid codec. Run {0} -h for details".format(__file__)
	sys.exit(1)

#The command string that we'll execute. LOTS of manipulation here available!
command = """ffmpeg -f x11grab -y -r 30 -s {0} -i :0.0 -vcodec {1} -qscale 0 -f alsa -i default -ar 44100 -acodec libmp3lame -ac 2 {2}""".format(resolution, codec, args.outputfile)

#print command

arguments = shlex.split(command)

#Finally, we call the command and start recording (naturally within try/except clause)
try:
	process = subprocess.Popen(arguments)
	process.communicate()[0]
except KeyboardInterrupt:
	process.kill()
	print "\r\n"
	print "The file has been saved to {0}".format(os.path.abspath(args.outputfile))
	print "Goodbye!"	
	sys.exit(0)
except Exception, e:
	print "Something went wrong when we tried to start the recording!"
	print "The error is {0}".format(str(e))
	sys.exit(2)



!python record.py output.avi --res 1280x720 --codec h264

--res 1920x1080 - the resolution to record in
 --codec h264 - the codec to encode in
 
 Run the --help argument for more info.

http://www.karinkuhlmann.com/fractals-2-digital-art/fractals-2-digital-art.html

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os
count = 0
while count<235: 
    
    path = r"/home/jack/Desktop/deep-dream-generator/notebooks/context-free/output/"
    base_image = random.choice([
        x for x in os.listdir(path)
        if os.path.isfile(os.path.join(path, x))
        ])
    filename0=(path+base_image)

    path0 = r"/home/jack/Desktop/deep-dream-generator/notebooks/context-free/output/"
    #path0 = r"testmasks/"
    base_image0 = random.choice([
        x0 for x0 in os.listdir(path0)
        if os.path.isfile(os.path.join(path0, x0))
        ])
    filename00=(path0+base_image0)

    path1 = r"newmask/"
    base_image1 = random.choice([
        x1 for x1 in os.listdir(path1)
        if os.path.isfile(os.path.join(path1, x1))
        ])
    mask0=(path1+base_image1)

    #im = Image.open('%s' % os.path.join(os.getcwd(), s + '.png')).convert("RGB")
      
    
    im1a = Image.open(filename0).convert("RGB")
    im1a.save("tmp/01aa.jpg")
    im1b = Image.open("tmp/01aa.jpg")
    im1c = im1b.resize((640,640), Image.NEAREST)
    im1c.save("tmp/01ab.jpg")
    jpg_im1 = Image.open("tmp/01ab.jpg") 

    im02a = Image.open(filename00).convert("RGB")
    im02 = im02a.resize((640,640), Image.NEAREST)
    im02.save("tmp/01aaa.jpg")
    im02b = Image.open("tmp/01aaa.jpg").convert("RGB")
    im02b.save("tmp/01aab.jpg")
    jpg_im2 = Image.open("tmp/01aab.jpg") 
    
    im03 = Image.open(mask0)
    im03.save("tmp/01aaaa.jpg")
    jpg_im3 = Image.open("tmp/01aaaa.jpg")
    mask = jpg_im3.resize((640,640), Image.NEAREST)
    time.sleep(3)
    result1 = ImageChops.blend(jpg_im1, jpg_im2, .5)
    
    #result1 = ImageChops.composite(jpg_im1, jpg_im2, mask)
    filename = time.strftime("/home/jack/Desktop/deep-dream-generator/notebooks/context-free/output/blended%Y%m%d%H%M%S.jpg")
    result1.save(filename)
    count=count+1
   

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os
count = 0
while count<35: 
    
    path = r"/home/jack/Desktop/deep-dream-generator/notebooks/context-free/output/"
    base_image = random.choice([
        x for x in os.listdir(path)
        if os.path.isfile(os.path.join(path, x))
        ])
    filename0=(path+base_image)

    path0 = r"/home/jack/Desktop/deep-dream-generator/notebooks/context-free/output/"
    #path0 = r"testmasks/"
    base_image0 = random.choice([
        x0 for x0 in os.listdir(path0)
        if os.path.isfile(os.path.join(path0, x0))
        ])
    filename00=(path0+base_image0)

    path1 = r"newmask/"
    base_image1 = random.choice([
        x1 for x1 in os.listdir(path1)
        if os.path.isfile(os.path.join(path1, x1))
        ])
    mask0=(path1+base_image1)

    #im = Image.open('%s' % os.path.join(os.getcwd(), s + '.png')).convert("RGB")
      
    
    im1a = Image.open(filename0).convert("RGB")
    im1a.save("tmp/01aa.jpg")
    im1 = Image.open("tmp/01aa.jpg").convert("RGB")
    imi = im1.resize((640,640), Image.NEAREST)
    im1.save("tmp/01aa2.jpg")
    jpg_im1 = Image.open("tmp/01aa2.jpg") 

    im02a = Image.open(filename00).convert("RGB")
    im02a.save("tmp/01aaa.jpg")
    im02 = Image.open("tmp/01aaa.jpg").convert("RGB")
    im02 = im02.resize((640,640), Image.NEAREST)
    im02.save("tmp/01aaa2.jpg")
    jpg_im2 = Image.open("tmp/01aaa2.jpg") 

    im03 = Image.open(mask0)
    im03.save("tmp/01aaaa.jpg")
    jpg_im3 = Image.open("tmp/01aaaa.jpg")
    mask = jpg_im3.resize((640,640), Image.NEAREST)
    time.sleep(3)
    result1 = ImageChops.blend(jpg_im1, jpg_im2, .5)
    
    #result1 = ImageChops.composite(jpg_im1, jpg_im2, mask)
    filename = time.strftime("/home/jack/Desktop/deep-dream-generator/notebooks/context-free/output/blended%Y%m%d%H%M%S.jpg")
    result1.save(filename)
    count=count+1
   

import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import random
from random import randint
from PIL import Image
from PIL import ImageChops


square_size = 10
offset_factor = 20
darken_factor = 0.1
path = r"crawler4/"
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))
    ])
filename0=(path+base_image)

image = Image.open(filename0)
size = image.size

# Create image np array
im = np.array(image, dtype=np.uint8)

# Create figure and axes
fig,ax = plt.subplots(1)

# Display the image
ax.imshow(im)

# Add random offset to tuple based on offset_factor
def add_offet(t):
    t[0] = random.randint(t[0], (t[0] + offset_factor))
    t[1] = random.randint(t[1], (t[1] + offset_factor))

    return t


# Create a Rectangle patch
for w in xrange(0, size[0], square_size):
    for h in xrange(0, size[1], square_size):
        #print str(w) + ':' + str(h)
        square_size = randint(10,30)
        offset_factor = randint(10,30)
    
        # Get the average color of the section
        rect = im[h:h+square_size, w:w+square_size]
        mean = rect.mean(axis=(0,1))

        # Convert to hex value
        face_color = '#%02x%02x%02x' % (int(mean[0]), int(mean[1]), int(mean[2]))
        edge_color = '#%02x%02x%02x' % (int(mean[0] - (mean[0] * darken_factor)), int(mean[1]  - (mean[1] * darken_factor)), int(mean[2] - (mean[2] * darken_factor)))

        # Dont draw outline with the dominant color
        z_order = 2
        if '#e' in face_color or '#f' in face_color:
            line_width = 0.0
        else:
            line_width = 0.1
            z_order = 3

        points = [add_offet([w, h]), add_offet([w + square_size, h]), add_offet([w, h + square_size])]
        triangle1 = patches.Polygon(points, edgecolor=edge_color, linewidth=line_width, facecolor=face_color, zorder=z_order)

        # Second triangle
        points2 = [add_offet([w, h + square_size]), add_offet([w + square_size, h + square_size]), add_offet([w + square_size, h])]
        triangle2 = patches.Polygon(points2, edgecolor=edge_color, linewidth=line_width, facecolor=face_color, zorder=z_order)

        # Square in background
        rec = patches.Rectangle((w,h),square_size,square_size,linewidth=0.0, edgecolor=edge_color, facecolor=face_color, zorder=1)

        # Add the patch to the Axes
        ax.add_patch(triangle1)
        ax.add_patch(triangle2)
        ax.add_patch(rec)

plt.axis('off')
plt.savefig("images/Sranger-Tri-001a.jpg", bbox_inches='tight', dpi=200)
img = Image.open("images/Sranger-Tri-001a.jpg")
nonwhite_positions = [(x,y) for x in range(img.size[0]) for y in range(img.size[1]) if img.getdata()[x+y*img.size[0]] != (255,255,255)]
rect = (min([x for x,y in nonwhite_positions]), min([y for x,y in nonwhite_positions]), max([x for x,y in nonwhite_positions]), max([y for x,y in nonwhite_positions]))
img.crop(rect).save('images/Sranger-Tri-001-crop2a.jpg')
#Create a second image
square_size = 10
offset_factor = 20
darken_factor = 0.1
#image = Image.open("images/Sranger002.jpg")

size = image.size

# Create image np array
im = np.array(image, dtype=np.uint8)

# Create figure and axes
fig,ax = plt.subplots(1)

# Display the image
ax.imshow(im)

# Add random offset to tuple based on offset_factor
def add_offet(t):
    t[0] = random.randint(t[0], (t[0] + offset_factor))
    t[1] = random.randint(t[1], (t[1] + offset_factor))

    return t


# Create a Rectangle patch
for w in xrange(0, size[0], square_size):
    for h in xrange(0, size[1], square_size):
        #print str(w) + ':' + str(h)
        square_size = randint(15,30)
        offset_factor = randint(15,30)
    
        # Get the average color of the section
        rect = im[h:h+square_size, w:w+square_size]
        mean = rect.mean(axis=(0,1))

        # Convert to hex value
        face_color = '#%02x%02x%02x' % (int(mean[0]), int(mean[1]), int(mean[2]))
        edge_color = '#%02x%02x%02x' % (int(mean[0] - (mean[0] * darken_factor)), int(mean[1]  - (mean[1] * darken_factor)), int(mean[2] - (mean[2] * darken_factor)))

        # Dont draw outline with the dominant color
        z_order = 2
        if '#e' in face_color or '#f' in face_color:
            line_width = 0.0
        else:
            #line_width = 0.1
            z_order = 3

        points = [add_offet([w, h]), add_offet([w + square_size, h]), add_offet([w, h + square_size])]
        triangle1 = patches.Polygon(points, edgecolor=edge_color, linewidth=line_width, facecolor=face_color, zorder=z_order)

        # Second triangle
        points2 = [add_offet([w, h + square_size]), add_offet([w + square_size, h + square_size]), add_offet([w + square_size, h])]
        triangle2 = patches.Polygon(points2, edgecolor=edge_color, linewidth=line_width, facecolor=face_color, zorder=z_order)

        # Square in background
        rec = patches.Rectangle((w,h),square_size,square_size,linewidth=0.0, edgecolor=edge_color, facecolor=face_color, zorder=1)

        # Add the patch to the Axes
        ax.add_patch(triangle1)
        ax.add_patch(triangle2)
        ax.add_patch(rec)

plt.axis('off')
plt.savefig("images/Sranger-Tri-001a.jpg", bbox_inches='tight', dpi=200)
img = Image.open("images/Sranger-Tri-001a.jpg")
nonwhite_positions = [(x,y) for x in range(img.size[0]) for y in range(img.size[1]) if img.getdata()[x+y*img.size[0]] != (255,255,255)]
rect = (min([x for x,y in nonwhite_positions]), min([y for x,y in nonwhite_positions]), max([x for x,y in nonwhite_positions]), max([y for x,y in nonwhite_positions]))
img.crop(rect).save('images/Sranger-Tri-001-crop2b.jpg')


img0 = Image.open("images/Sranger-Tri-001-crop2a.jpg")
img1 = Image.open("images/Sranger-Tri-001-crop2b.jpg")
blen = ImageChops.blend(img0, img1, .5)
blen.save('images/Sranger-Tri-001-crop2b.jpg')
blen

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os
count = 0
while count<550: 
    #path = r"build/"
    path = r"crawler/"
    base_image = random.choice([
        x for x in os.listdir(path)
        if os.path.isfile(os.path.join(path, x))
        ])
    filename0=(path+base_image)

    path0 = r"crawler1/"
    #path0 = r"testmasks/"
    base_image0 = random.choice([
        x0 for x0 in os.listdir(path0)
        if os.path.isfile(os.path.join(path0, x0))
        ])
    filename00=(path0+base_image0)

    path1 = r"newmask/"
    base_image1 = random.choice([
        x1 for x1 in os.listdir(path1)
        if os.path.isfile(os.path.join(path1, x1))
        ])
    mask0=(path1+base_image1)

    im1 = Image.open(filename0).convert('RGB')
    im1 = im1.resize((640,640), Image.NEAREST)
    im1.save("tmp/01aa.jpg")
    jpg_im1 = Image.open("tmp/01aa.jpg") 

    im02 = Image.open(filename00).convert('RGB')
    im2 = im02.resize((640,640), Image.NEAREST)
    im2.save("tmp/01aaa.jpg")
    jpg_im2 = Image.open("tmp/01aaa.jpg") 

    im03 = Image.open(mask0)
    im03.save("tmp/01aaaa.jpg")
    jpg_im3 = Image.open("tmp/01aaaa.jpg") 
    im03 = jpg_im3.resize((640,640), Image.NEAREST)
    time.sleep(3)
    result1 = ImageChops.blend(jpg_im1, jpg_im2, .5)
    
    #result1 = ImageChops.composite(jpg_im1, jpg_im2, im03)
    filename = time.strftime("aug25/%Y%m%d%H%M%S.jpg")
    result1.save(filename)
    count=count+1
   

!mkdir aug25

result1.save(filename)

jpg_im1

jpg_im2

im03

from PIL import Image, ImageChops
jpg_im3 = Image.open("junk/03.jpg") 
jpg_im3

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os
path = r"build/"
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))
    ])
filename0=(path+base_image)

#path0 = r"blend/"
path0 = r"testmasks/"
base_image0 = random.choice([
    x0 for x0 in os.listdir(path0)
    if os.path.isfile(os.path.join(path0, x0))
    ])
filename00=(path0+base_image0)

path1 = r"testmasks/"
base_image1 = random.choice([
    x1 for x1 in os.listdir(path1)
    if os.path.isfile(os.path.join(path1, x1))
    ])
mask0=(path1+base_image1)

im1 = Image.open(filename0)
im1 = im1.resize((640,640), Image.NEAREST)
im1.save("junk/01.jpg")
jpg_im1 = Image.open("junk/01.jpg") 

im02 = Image.open(filename00)
im2 = im02.resize((640,640), Image.NEAREST)
im1.save("junk/02.jpg")
jpg_im2 = Image.open("junk/02.jpg") 

im03 = Image.open(mask0)
im03.save("junk/03.jpg")
jpg_im3 = Image.open("junk/03.jpg") 
im03 = jpg_im3.resize((640,640), Image.NEAREST)
  
result1 = ImageChops.composite(jpg_im1, jpg_im2, im03)
filename = time.strftime("junk/%Y%m%d%H%M%S.jpg")
#result1.save(filename)
result1

!ls ../deep-dream-generator/notebooks/STUFF/experiment

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os

count=count+1
while count<300:
    path = r"/home/jack/Desktop/deep-dream-generator/notebooks/new/1/"
    #path = r"build/"
    base_image = random.choice([
        x for x in os.listdir(path)
        if os.path.isfile(os.path.join(path, x))
        ])
    filename0=(path+base_image)

    #path0 = r"blend/"
    path0 = r"output/"
    base_image0 = random.choice([
        x0 for x0 in os.listdir(path0)
        if os.path.isfile(os.path.join(path0, x0))
        ])
    filename00=(path0+base_image0)

    path1 = r"newmask/"
    base_image1 = random.choice([
        x1 for x1 in os.listdir(path1)
        if os.path.isfile(os.path.join(path1, x1))
        ])
    mask0=(path1+base_image1)

    im1 = Image.open(filename0)
    im1 = im1.resize((640,640), Image.NEAREST)
    im1.save("junk/01.jpg")
    jpg_im1 = Image.open("junk/01.jpg") 

    im02 = Image.open(filename00)
    im2 = im02.resize((640,640), Image.NEAREST)
    im1.save("junk/02.jpg")
    jpg_im2 = Image.open("junk/02.jpg") 

    im03 = Image.open(mask0)
    im03.save("junk/03.jpg")
    jpg_im3 = Image.open("junk/03.jpg") 
    im03 = jpg_im3.resize((640,640), Image.NEAREST)
    time.sleep(3)
    result1 = ImageChops.blend(jpg_im1, jpg_im2, .03)
    filename = time.strftime("greedy/%Y%m%d%H%M%S.jpg")
    #result1.save(filename)
    result1
    count=count+1

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os
count=0
while count <400:
    path = r"crawler4/"
    #path = r"build/"
    base_image = random.choice([
        x for x in os.listdir(path)
        if os.path.isfile(os.path.join(path, x))
        ])
    filename0=(path+base_image)
    random.seed(5)
    time.sleep(5)
    #path0 = r"blend/"
    path0 = r"crawler4/"
    base_image0 = random.choice([
        x0 for x0 in os.listdir(path0)
        if os.path.isfile(os.path.join(path0, x0))
        ])
    filename00=(path0+base_image0)

    path1 = r"newmask/"
    base_image1 = random.choice([
        x1 for x1 in os.listdir(path1)
        if os.path.isfile(os.path.join(path1, x1))
        ])
    mask0=(path1+base_image1)

    im1 = Image.open(filename0)
    im1 = im1.resize((640,640), Image.NEAREST)
    im1.save("junk/01.png")
    jpg_im1 = Image.open("junk/01.png") 

    im02 = Image.open(filename00)
    im2 = im02.resize((640,640), Image.NEAREST)
    im1.save("junk/02.png")
    jpg_im2 = Image.open("junk/02.png") 

    im03 = Image.open(mask0)
    im03.save("junk/03.png")
    jpg_im3 = Image.open("junk/03.png") 
    im03 = jpg_im3.resize((640,640), Image.NEAREST)
  
    result1 = ImageChops.blend(jpg_im1, jpg_im2, .5)
    filename = time.strftime("crawler4/%Y%m%d%H%M%S.png")
    result1.save(filename)
    count=count+1

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os
  

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os
path = r"/home/jack/Desktop/deep-dream-generator/notebooks/new/1/"
#path = r"build/"
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))
    ])
filename0=(path+base_image)

#path0 = r"blend/"
path0 = r"crawler4/"
base_image0 = random.choice([
    x0 for x0 in os.listdir(path0)
    if os.path.isfile(os.path.join(path0, x0))
    ])
filename00=(path0+base_image0)

path1 = r"newmask/"
base_image1 = random.choice([
    x1 for x1 in os.listdir(path1)
    if os.path.isfile(os.path.join(path1, x1))
    ])
mask0=(path1+base_image1)

im1 = Image.open(filename0)
im1 = im1.resize((640,640), Image.NEAREST)
im1.save("junk/01.png")
jpg_im1 = Image.open("junk/01.png") 

im02 = Image.open(filename00)
im2 = im02.resize((640,640), Image.NEAREST)
im1.save("junk/02.png")
jpg_im2 = Image.open("junk/02.png") 

im03 = Image.open(mask0)
im03.save("junk/03.png")
jpg_im3 = Image.open("junk/03.png") 
im03 = jpg_im3.resize((640,640), Image.NEAREST)
  
result1 = ImageChops.blend(jpg_im1, jpg_im2, .5)
filename = time.strftime("output/%Y%m%d%H%M%S.png")
result1.save(filename)
result1

result1.save(filename)

from PIL import Image, ImageChops
help(ImageChops)

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os

path = r"build/"
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))])
filename=(path+base_image)
im1 = Image.open(filename)
im1 = im1.resize((640,640), Image.NEAREST)
im1.save("tmp/01.jpg")
jpg_im1 = Image.open("tmp/01.jpg") 




path0 = r"blend/"
#path0 = r"basic/"
base_image0 = random.choice([
    x0 for x0 in os.listdir(path0)
    if os.path.isfile(os.path.join(path0, x0))])
filename00=(path0+base_image0)
im02 = Image.open(filename00)
im2 = im02.resize((640,640), Image.NEAREST)
im1.save("tmp/02.jpg")
jpg_im2 = Image.open("tmp/02.jpg")


pathm = r"mask/"
#path0 = r"basic/"
mask01 = random.choice([
    x0 for x0 in os.listdir(pathm)
    if os.path.isfile(os.path.join(pathm, x0))])
filenameM=(pathm+mask01)
imM = Image.open(filenameM)
imMm = imM.resize((640,640), Image.NEAREST)
imMm.save("tmp/03.png")
jpg_M = Image.open("tmp/03.png") 



pathm = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(pathm)
    if os.path.isfile(os.path.join(pathm, x0))])
filename001=(pathm+base_image01)
im03 = Image.open(filename001)
im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")
jpg_im3 = Image.open("tmp/03.jpg") 




result1 = ImageChops.lighter(jpg_im1, jpg_im2)  
result2 = ImageChops.blend(jpg_im1, result1, 0.5)
result4 = ImageChops.composite(jpg_im1, result2, jpg_M)
result3 = ImageChops.blend(jpg_im2, result2, 0.5)
#filename = time.strftime("darkimages/%Y%m%d%H%M%S.jpg")
#result1.save(filename)
result4

#Very Good COMPOSITE ___ _ do not change
from PIL import Image, ImageChops
import time
import random
import os

path = r"build/"
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))])
filename=(path+base_image)
im1 = Image.open(filename)
im1 = im1.resize((640,640), Image.NEAREST)
im1.save("tmp/01.jpg")
jpg_im1 = Image.open("tmp/01.jpg") 




path0 = r"blend/"
#path0 = r"basic/"
base_image0 = random.choice([
    x0 for x0 in os.listdir(path0)
    if os.path.isfile(os.path.join(path0, x0))])
filename00=(path0+base_image0)
im02 = Image.open(filename00)
im2 = im02.resize((640,640), Image.NEAREST)
im1.save("tmp/02.jpg")
jpg_im2 = Image.open("tmp/02.jpg")


pathm = r"testmasks/"
#path0 = r"basic/"
mask01 = random.choice([
    x0 for x0 in os.listdir(pathm)
    if os.path.isfile(os.path.join(pathm, x0))])
filenameM=(pathm+mask01)
imM = Image.open(filenameM)
imMm = imM.resize((640,640), Image.NEAREST)
imMm.save("tmp/03.png")
jpg_M = Image.open("tmp/03.png") 



pathm = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
filename001=(path01+base_image01)
im03 = Image.open(filename001)
im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")
jpg_im3 = Image.open("tmp/03.jpg") 




result1 = ImageChops.lighter(jpg_im1, jpg_im2)  
result2 = ImageChops.blend(jpg_im1, result1, 0.5)
result4 = ImageChops.composite(jpg_im1, result2, jpg_im3)
result3 = ImageChops.blend(jpg_im2, result2, 0.5)
result5 = ImageChops.screen(result2, result3)
result6 = ImageChops.darker(result5, result5)
#filename = time.strftime("darkimages/%Y%m%d%H%M%S.jpg")
#result1.save(filename)
result6

filename = time.strftime("tmp/%Y%m%d%H%M%S.jpg")
result5.save(filename)

inv=ImageChops.invert(result5)
inv

xoffset = 5
newim= ImageChops.offset(inv, xoffset, yoffset=None)
newim

resultXX = ImageChops.blend(newim, result5, 0.5)

filename = time.strftime("tmp/%Y%m%d%H%M%S.jpg")
resultXX.save(filename)
resultXX

filename = time.strftime("tmp/%Y%m%d%H%M%S.jpg")
resultXX.save(filename)

from PIL import Image, ImageChops
import time
import random
import os
path01 = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
print base_image01

from PIL import Image, ImageChops
import time
import random
import os
path01 = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
filename001=(path01+base_image01)
im03 = Image.open(filename001)
im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")
jpg_im3 = Image.open("tmp/03.jpg") 
#filename = time.strftime("tmp/%Y%m%d%H%M%S.jpg")
#result5.save(filename)
inv=ImageChops.invert(jpg_im3)

xoffset = 5
newim= ImageChops.offset(inv, xoffset, yoffset=None)
newim

from PIL import Image, ImageChops
import time
import random
import os
path01 = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
filename001=(path01+base_image01)

im03 = Image.open(filename001)
im03 = im03.convert('L') 



im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")
jpg_im3 = Image.open("tmp/03.jpg") 
#filename = time.strftime("tmp/%Y%m%d%H%M%S.jpg")
#result5.save(filename)
inv=ImageChops.invert(jpg_im3)
xoffset = 5
newim= ImageChops.offset(inv, xoffset, yoffset=None)

resultXX = ImageChops.blend(newim, inv, 0.5)
#filename = time.strftime("tmp/03.jp")

#resultXX.save(filename)

#jpg_new = resultXX.resize((640,640), Image.NEAREST)

#jpg_new
resultXX


# Working Fine 
from PIL import Image, ImageChops
import time
import random
import os
pathm = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
filename001=(path01+base_image01)

im03 = Image.open(filename001)
im03 = im03.convert('L') 
im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")


jpg_im3 = Image.open("tmp/03.jpg") 
jpg_new = jpg_im3.resize((640,640), Image.NEAREST)

inv=ImageChops.invert(jpg_new)
xoffset = 5
newim= ImageChops.offset(inv, xoffset, yoffset=None)
result5 = newim.resize((640,640), Image.NEAREST)


resultXX = ImageChops.blend(newim, im03, 0.5)

resultXX 


# Gray scale Embossing --- Working Fine 
from PIL import Image, ImageChops
import time
import random
import os
import cv2
pathm = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
filename001=(path01+base_image01)

im03 = Image.open(filename001)
im03 = im03.convert('L') 

im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")
im03 = cv2.imread("tmp/03.jpg")
blur = cv2.blur(im03,(2,2))
cv2.imwrite("tmp/03.jpg", blur)


jpg_im3 = Image.open("tmp/03.jpg") 
jpg_new = jpg_im3.resize((640,640), Image.NEAREST)

inv=ImageChops.invert(jpg_new)
xoffset = 5
newim= ImageChops.offset(inv, xoffset, yoffset=None)
result5 = newim.resize((640,640), Image.NEAREST)


resultXX = ImageChops.blend(newim, jpg_im3, 0.5)

resultXX 


from PIL import Image, ImageChops
import time
import random
import os
pathm = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
filename001=(path01+base_image01)

im03 = Image.open(filename001)
im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")

jpg_im3 = Image.open("tmp/03.jpg") 
jpg_new = jpg_im3.resize((640,640), Image.NEAREST)


inv=ImageChops.invert(jpg_im3)
xoffset = 5
newim= ImageChops.offset(inv, xoffset, yoffset=None)

result5 = newim.resize((640,640), Image.NEAREST)

resultXX = ImageChops.blend(newim, result5, 0.5)

resultXX 


import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import random
from random import randint
from PIL import Image
from PIL import ImageChops
import os

square_size = 10
offset_factor = 20
darken_factor = 0.1
path = r"basic/"
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))
    ])
filename0=(path+base_image)

image = Image.open(filename0)
size = image.size

# Create image np array
im = np.array(image, dtype=np.uint8)

# Create figure and axes
fig,ax = plt.subplots(1)

# Display the image
ax.imshow(im)

# Add random offset to tuple based on offset_factor
def add_offet(t):
    t[0] = random.randint(t[0], (t[0] + offset_factor))
    t[1] = random.randint(t[1], (t[1] + offset_factor))

    return t


# Create a Rectangle patch
for w in xrange(0, size[0], square_size):
    for h in xrange(0, size[1], square_size):
        #print str(w) + ':' + str(h)
        square_size = randint(10,30)
        offset_factor = randint(10,30)
    
        # Get the average color of the section
        rect = im[h:h+square_size, w:w+square_size]
        mean = rect.mean(axis=(0,1))

        # Convert to hex value
        face_color = '#%02x%02x%02x' % (int(mean[0]), int(mean[1]), int(mean[2]))
        edge_color = '#%02x%02x%02x' % (int(mean[0] - (mean[0] * darken_factor)), int(mean[1]  - (mean[1] * darken_factor)), int(mean[2] - (mean[2] * darken_factor)))

        # Dont draw outline with the dominant color
        z_order = 2
        if '#e' in face_color or '#f' in face_color:
            line_width = 0.0
        else:
            line_width = 0.1
            z_order = 3

        points = [add_offet([w, h]), add_offet([w + square_size, h]), add_offet([w, h + square_size])]
        triangle1 = patches.Polygon(points, edgecolor=edge_color, linewidth=line_width, facecolor=face_color, zorder=z_order)

        # Second triangle
        points2 = [add_offet([w, h + square_size]), add_offet([w + square_size, h + square_size]), add_offet([w + square_size, h])]
        triangle2 = patches.Polygon(points2, edgecolor=edge_color, linewidth=line_width, facecolor=face_color, zorder=z_order)

        # Square in background
        rec = patches.Rectangle((w,h),square_size,square_size,linewidth=0.0, edgecolor=edge_color, facecolor=face_color, zorder=1)

        # Add the patch to the Axes
        ax.add_patch(triangle1)
        ax.add_patch(triangle2)
        ax.add_patch(rec)

plt.axis('off')
plt.savefig("images/Sranger-Tri-001a.jpg", bbox_inches='tight', dpi=200)

path = r"basic/"
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))
    ])
filename0=(path+base_image)


img = Image.open("images/Sranger-Tri-001a.jpg")
nonwhite_positions = [(x,y) for x in range(img.size[0]) for y in range(img.size[1]) if img.getdata()[x+y*img.size[0]] != (255,255,255)]
rect = (min([x for x,y in nonwhite_positions]), min([y for x,y in nonwhite_positions]), max([x for x,y in nonwhite_positions]), max([y for x,y in nonwhite_positions]))
img.crop(rect).save('images/Sranger-Tri-001-crop2a.jpg')
#Create a second image
square_size = 10
offset_factor = 20
darken_factor = 0.1
#image = Image.open("images/Sranger002.jpg")

size = image.size

# Create image np array
im = np.array(image, dtype=np.uint8)

# Create figure and axes
fig,ax = plt.subplots(1)

# Display the image
ax.imshow(im)

# Add random offset to tuple based on offset_factor
def add_offet(t):
    t[0] = random.randint(t[0], (t[0] + offset_factor))
    t[1] = random.randint(t[1], (t[1] + offset_factor))

    return t


 

img = Image.open("images/Sranger-Tri-001a.jpg")
nonwhite_positions = [(x,y) for x in range(img.size[0]) for y in range(img.size[1]) if img.getdata()[x+y*img.size[0]] != (255,255,255)]
rect = (min([x for x,y in nonwhite_positions]), min([y for x,y in nonwhite_positions]), max([x for x,y in nonwhite_positions]), max([y for x,y in nonwhite_positions]))
img.crop(rect).save('images/Sranger-Tri-001-crop2b.jpg')

path = r"basic/"
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))
    ])
filename0=(path+base_image)





im0 = Image.open("images/Sranger-Tri-001-crop2b.jpg")
img0 = im0.resize((640,640,3), Image.NEAREST)

im1 = Image.open(filename0)
img1 = im1.resize((640,640,3), Image.NEAREST)



blen = ImageChops.blend(img0, img1, .5)
blen.save('junk/Sranger-Tri-001-crop2b.jpg')
blen

#So I managed to do it, using "palette" image type, but the resulting file is not as small as I expected... 
#Here's my code in case its useful for someone else, or if someone can improve on it.

from PIL import Image

im = Image.open("tmp/03b.png")
imP = im.convert('RGB').convert('P', palette=Image.ADAPTIVE, colors=5)
imP.putpalette([
    0, 0, 0, # index 0 is black background
    0, 0, 255, # index 1 is blue
    255, 0, 0, # index 2 is red 
    ])

im2 = Image.open("tmp/03b.png")
imP2L = im2.convert('L') # need a greyscale image to create a mask
mask = Image.eval(imP2L, lambda a: 255 if a == 0 else 0)
imP.paste(2, mask) # Paste the color of index 2 using image2 as a mask
imP.save('tmp/wow-out3a.png', transparency = 0, optimize = 1) # Save and set index 0 as transparent



-

!showme tmp/wow-out3a.png

im = Image.open('tmp/wow-out3a.png')
rgb_im = im.convert('RGB')
r, g, b = rgb_im.getpixel((1, 1))

print(r, g, b)


max_width = max(image.size[0] for image in images)
max_height = max(image.size[1] for image in images)

image_sheet = Image.new("RGBA", (max_width * len(images), max_height))

for (i, image) in enumerate(images):
    image_sheet.paste(image, (
        max_width * i + (max_width - image.size[0]) / 2,
        max_height * 0 + (max_height - image.size[1]) / 2
    ))

image_sheet.save("whatever.png")
image_sheet

from PIL import Image
img = Image.new('RGB', (240,240), (255, 255, 255))
img.save("tmp/image.png", "PNG")

from math import sin

#creates a grayscale 
from PIL import Image
from math import sin, cos
img = Image.new('RGB', (256,256), (255, 255, 255))
img.save("tmp/image.png", "PNG")
image = Image.open('tmp/image.png') #open image
image = image.convert("RGBA")  #convert to RGBA
h,w = image.size
hh=0
ww=0
hl = h-h/2
wl = w-w/2
zl = (hl+5)+(wl-5)
aa = 255
i=2
while hh < h:
    ww=0
    while ww < w:
        r,g,b,a = image.getpixel((hh, ww)) #Get the rgba value at coordinates x,y
        #sin(x*y)+sin(y*z)+sin(z*x)==0
        x=ww-126
        y=hh-126
        z=ww-130
        if int(abs((cos(x**2-cos(y)-x+y**2)))*200)>60:
            co = int(abs((cos(x**2-cos(y)-x+y**2)))*200)
            image.putpixel((hh, ww), (co,0,0,aa)) #put back the modified reba values at same pixel coordinates
        else:
            image.putpixel((hh, ww), (255,255,255,aa))
        image.save("tmp/image2.png", "PNG")   
        ww = ww + 1
    hh=hh+1


image




import Image, ImageDraw

im = Image.open("lena.pgm")

draw = ImageDraw.Draw(im)

# Fill=128 creates a grey line
draw.line((0, 0) + im.size, fill=128)   
draw.line((0, im.size[1], im.size[0], 0), fill=128)
del draw

# write to stdout
im.save(sys.stdout, "PNG")

from PIL import Image
image = Image.open('tmp/wow-out3a.png') #open image
image = image.convert("RGBA")  #convert to RGBA
r,g,b,a = image.getpixel((x, y)) #Get the rgba value at coordinates x,y
A = a/100
#r,g,b,a = int(r,g,b,(a / 2)) #or you could do rgb[3] = 50 maybe? #set alpha to half somehow
image.putpixel((x,y), (r,g,b,A)) #put back the modified reba values at same pixel coordinates
image




i = "i.png"
o = "o.png"

key = (0, 0, 0, 255)

from PIL import Image as I

_i = I.open(i)
_ii = _i.load()

_o = I.new("RGBA", _i.size)
_oo = _o.load()

for x in range(0, _i.size[0]): 
    for y in range(0, _i.size[1]): 
        col = list(_ii[x, y])
        if col[0:3] == my_key_color[0:3]:
            _oo[x,y] = col[0:3]+(0,) # keep RGB, set A to 0
        else:
            _oo[x,y] = col

_o.save(o)



from skimage import io
import numpy as np

image = io.imread('http://i.stack.imgur.com/Y8UeF.jpg')

print(np.mean(image))

You might want to convert all images to float to get a value betwenn 0 and 1:

from skimage import io, img_as_float
import numpy as np

image = io.imread('http://i.stack.imgur.com/Y8UeF.jpg')
image = img_as_float(image)
print(np.mean(image))

from PIL import Image

img = Image.open('tmp/03b.png')
img = img.convert("RGBA")
datas = img.getdata()

newData = []
for item in datas:
    if item[0] == 255 and item[1] == 255 and item[2] == 255:
        newData.append((255, 255, 255, 0))
    else:
        newData.append(item)

img.putdata(newData)
img.save("tmp/img2.png", "PNG")
img

from PIL import Image, ImageChops

image_two = Image.open ("tmp/03b.png")
image_two = image_two.convert ("RGBA")

pixels = image_two.load()

for y in xrange (image_two.size[1]):
    for x in xrange (image_two.size[0]):
        if pixels[x, y][3] == 255:
            pixels[x, y] = (255, 0, 0, 255)
        else:
            pixels[x, y] = (255, 255, 255, 255)

image_two.save("tmp/image_two2.png")

from PIL import Image, ImageChops
import time
def remove_transparency(im, bg_colour=(255, 255, 255)):

    # Only process if image has transparency (http://stackoverflow.com/a/1963146)
    if im.mode in ('RGBA', 'LA') or (im.mode == 'P' and 'transparency' in im.info):

        # Need to convert to RGBA if LA format due to a bug in PIL (http://stackoverflow.com/a/1963146)
        alpha = im.convert('RGBA').split()[-1]

        # Create a new background image of our matt color.
        # Must be RGBA because paste requires both images have the same format
        # (http://stackoverflow.com/a/8720632  and  http://stackoverflow.com/a/9459208)
        bg = Image.new("RGBA", im.size, bg_colour + (255,))
        bg.paste(im, mask=alpha)
        return bg

    else:
        return im
    
im3 = Image.open('tmp/03a.png')     
nim =remove_transparency(im3, bg_colour=(255, 255, 255))

nim.save('tmp/03b.png')
nim

# Gray scale Embossing --- Working Fine 
from PIL import Image, ImageChops
import time
import random
import os
import cv2
import numpy as np
pathm = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
filename001=(path01+base_image01)

im03 = Image.open(filename001)
im03 = im03.convert('L') 

im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")
im03 = cv2.imread("tmp/03.jpg")
blur = cv2.blur(im03,(2,2))
cv2.imwrite("tmp/03.jpg", blur)


jpg_im3 = Image.open("tmp/03.jpg") 
jpg_new = jpg_im3.resize((640,640), Image.NEAREST)

inv=ImageChops.invert(jpg_new)
xoffset = 5
newim= ImageChops.offset(inv, xoffset, yoffset=None)
result5 = newim.resize((640,640), Image.NEAREST)


resultXX = ImageChops.blend(newim, jpg_im3, 0.5)

pix = np.array(resultXX)
blurfin = cv2.blur(pix,(4,4))
cv2.imwrite("tmp/05a.jpg", blurfin)




!showme tmp/05a.jpg

# Gray scale Embossing --- Working Fine 
from PIL import Image, ImageChops
import time
import random
import os
import cv2
pathm = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
filename001=(path01+base_image01)

im03 = Image.open(filename001)
im03 = im03.convert('L') 

im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")
im03 = cv2.imread("tmp/03.jpg")
blur = cv2.blur(im03,(2,2))
cv2.imwrite("tmp/03.jpg", blur)


jpg_im3 = Image.open("tmp/03.jpg") 
jpg_new = jpg_im3.resize((640,640), Image.NEAREST)

inv=ImageChops.invert(jpg_new)
xoffset = 5
newim= ImageChops.offset(inv, xoffset, yoffset=None)
result5 = newim.resize((640,640), Image.NEAREST)


resultXX = ImageChops.blend(newim, jpg_im3, 0.5)

resultXX 


# Working Fine 
from PIL import Image, ImageChops
import time
import random
import os
pathm = r"experiment/"
#path0 = r"basic/"
base_image01 = random.choice([
    x0 for x0 in os.listdir(path01)
    if os.path.isfile(os.path.join(path01, x0))])
filename001=(path01+base_image01)

im03 = Image.open(filename001)
im03 = im03.convert('L') 
im3 = im03.resize((640,640), Image.NEAREST)
im3.save("tmp/03.jpg")


jpg_im3 = Image.open("tmp/03.jpg") 
jpg_new = jpg_im3.resize((640,640), Image.NEAREST)

inv=ImageChops.invert(jpg_new)
xoffset = 5
newim= ImageChops.offset(inv, xoffset, yoffset=None)
result5 = newim.resize((640,640), Image.NEAREST)


resultXX = ImageChops.blend(newim, im03, 0.5)

resultXX 


from PIL import Image, ImageFont, ImageDraw, ImageEnhance

source_img = Image.open("tmp/tmp.jpg").convert("RGBA")


font = ImageFont.truetype("/home/jack/.fonts/Exo-Black.ttf", 15)
text = "TwitterBot Project"
# get text size
text_size = font.getsize(text)
# set button size + 10px margins
button_size = (text_size[0]+8, text_size[1]+8)
# create image with correct size and black background
button_img = Image.new('RGBA', button_size, "black")
# put text on button with 10px margins
button_draw = ImageDraw.Draw(button_img)
button_draw.text((4, 4), text, font=font)




# put button on source image in position (0, 0)
source_img.paste(button_img, (15,15))
# save in new file
source_img.save("junk/output.jpg", "JPEG")
source_img

image=Image.open("star_blue.png")
opacity=0.5
bands=list(self.image.split())
if len(bands)==4:
    bands[3]=bands[3].point(lambda x:x*opacity)
    new_image=Image.merge(image.mode,bands)


from PIL import Image, ImageFont, ImageDraw, ImageEnhance

source_img = Image.open("tmp/tmp.jpg").convert("RGBA")


font2 = ImageFont.truetype("/home/jack/.fonts/Exo-Black.ttf", 15)
text = "TwitterBot Project"
# get text size
text_size = font.getsize(text)
# set button size + 10px margins
button_size = (text_size[0]+8, text_size[1]+8)
# create image with correct size and black background
button_img = Image.new('RGBA', button_size, "black")
# put text on button with 10px margins
button_draw = ImageDraw.Draw(button_img)
button_draw.text((4, 4), text, font=font2)
opacity=0.5
bands=list(button_img.split())
if len(bands)==4:
    bands[3]=bands[3].point(lambda x:x*opacity)
    new_image=Image.merge(button_img.mode,bands)
# put button on source image in position (0, 0)
source_img.paste(new_image, (15,15))
# save in new file
source_img.save("junk/output.jpg", "JPEG")
source_img





import PIL
from PIL import ImageFont
from PIL import Image
from PIL import ImageDraw

width = 854
height = 480
black = (0,0,0)
text = "copyright"
white = (255,255,255)
font = ImageFont.truetype("/home/jack/.fonts/Exo-Black.ttf", 35)
img = Image.new("RGBA", (width,height),white)
draw = ImageDraw.Draw(img)
w, h = draw.textsize(text, font)
draw.text(((width-w)/2,(height-h)/2),text,black,font=font)
draw = ImageDraw.Draw(img)
#img.putalpha
img.save("junk/result2.png")
img

!showme junk/output.jpg

from PIL import Image
bg = Image.open("1.jpg")
fg = Image.open("2.jpg")
# set alpha to .7
Image.blend(bg, fg, .7).save("out.png")



image=Image.open("star_blue.png")
opacity=0.5
bands=list(self.image.split())
if len(bands)==4:
    bands[3]=bands[3].point(lambda x:x*opacity)
    new_image=Image.merge(image.mode,bands)

!ls tmpseg

from PIL import Image
import time
# Function to change the image size
def changeImageSize(maxWidth, 
                    maxHeight, 
                    image):
    
    widthRatio  = maxWidth/image.size[0]
    heightRatio = maxHeight/image.size[1]

    newWidth    = int(widthRatio*image.size[0])
    newHeight   = int(heightRatio*image.size[1])

    newImage    = image.resize((newWidth, newHeight))
    return newImage
    
# Take two images for blending them together   
image1 = Image.open("tmpseg/20220921-072955__10.png")
image2 = Image.open("tmpseg/20220921-072811__10.png")

# Make the images of uniform size
image3 = changeImageSize(720, 480, image1)
image4 = changeImageSize(720, 480, image2)

# Make sure images got an alpha channel
image5 = image3.convert("RGBA")
image6 = image4.convert("RGBA")

# Display the original images
#image5.show()
#image6.show()

# alpha-blend the images with varying values of alpha
alphaBlended1 = Image.blend(image5, image6, alpha=.2)
alphaBlended2 = Image.blend(image5, image6, alpha=.4)

# Display the alpha-blended images
#alphaBlended1.show()
timestr = time.strftime("%Y%m%d-%H%M%S")
filename = "segmented/"+timestr+"_.png"
im = alphaBlended1.save(filename)
img = Image.open(filename)
img
#alphaBlended2.show()

!mkdir segmented

!ls -d */

#%%writefile Blender.py
from PIL import Image
import time
import random
import os
# Function to change the image size
def changeImageSize(maxWidth, 
                    maxHeight, 
                    image):
    
    widthRatio  = maxWidth/image.size[0]
    heightRatio = maxHeight/image.size[1]

    newWidth    = int(widthRatio*image.size[0])
    newHeight   = int(heightRatio*image.size[1])

    newImage    = image.resize((newWidth, newHeight))
    return newImage

path = r"Australian%20Lizards/"
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))
])
filename0=(path+base_image)



patho = r"black%20and%20white%20art%20nouveau%20drawings/"
base_image = random.choice([
    x for x in os.listdir(patho)
    if os.path.isfile(os.path.join(patho, x))
])
filename00=(patho+base_image)





# Take two images for blending them together   
image1 = Image.open(filename0)
image2 = Image.open(filename00)
def Blendem(image1, image2,  Image1Alpha =.2, Image2Alpha =.4 ):
    # Make the images of uniform size
    image3 = changeImageSize(720, 480, image1)
    image4 = changeImageSize(720, 480, image2)

    # Make sure images got an alpha channel
    image5 = image3.convert("RGBA")
    image6 = image4.convert("RGBA")
    # alpha-blend the images with varying values of alpha
    Image1Alpha =.2
    Image2Alpha =.4
    alphaBlended1 = Image.blend(image5, image6, alpha=Image1Alpha)
    alphaBlended2 = Image.blend(image5, image6, alpha=Image2Alpha)

    # Display the alpha-blended images
    #alphaBlended1.show()
    timestr = time.strftime("%Y%m%d-%H%M%S")
    filename = "segmented/"+timestr+"XX.png"
    im = alphaBlended1.save(filename)
    #img = Image.open(filename)
    #img
    #alphaBlended2.show()
    return im

Blendem(image1, image2,  Image1Alpha =.1, Image2Alpha =.9 )

image1 = Image.open("tmpseg/20220921-072955__10.png")
image2 = Image.open("tmpseg/20220921-072811__10.png")
Blendem(image1, image2)

!ls segmented

im



!mkdir base

from PIL import ImageFont, ImageDraw, Image
import time
import os
import random
from random import randint
def pick(font_path):    
        
        font=random.choice([x for x in os.listdir(font_path) if os.path.isfile(os.path.join(font_path, x))])
        return font_path+font
def mkimage(path1):
    
    img = random.choice(os.listdir(path1))
    file_path =path1+img 
    return file_path

def mkbatch(mkimage,pick):
    image = Image.open(mkimage)
    image = image.resize((1280,720), Image.NEAREST)
    W,H = image.size
    draw = ImageDraw.Draw(image)
    txt = "Python Generated /Processed Images"
    fontsize = 6 # starting font size

    W, H = image.size

    # portion of image width you want text width to be
    blank = Image.new('RGB',(W, H))

    FONT = pick
    font = ImageFont.truetype(FONT, fontsize)
    #print image.size

    W,H = blank.size
    blank = blank.resize((W-100, H-30,), Image.NEAREST)
    #print blank.size
    while (font.getsize(txt)[0] < blank.size[0]) and (font.getsize(txt)[1] < blank.size[1]):
        # iterate until the text size is just larger than the criteria
        fontsize += 1
        font = ImageFont.truetype(FONT, fontsize)

    # optionally de-increment to be sure it is less than criteria
    fontsize -= 1
    font = ImageFont.truetype(FONT, fontsize)

    w, h = draw.textsize(txt, font=font)

    #print 'final font size',fontsize, FONT
    draw.text((15,625), txt, font=font, fill="black") # put the text on the image
    draw.text((20,620), txt, font=font, fill="white") # put the text on the image
    DT = time.strftime("base/%Y-%m-%d-%H-%M-%S.png")
    image.save(DT) # save it
    #image
for i in range(1,500):
    path1 = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/All-images/'
    font_path = '/home/jack/fonts/'
    mkbatch(mkimage(path1),pick(font_path))
    time.sleep(3)
    print ".",

from PIL import ImageFont, ImageDraw, Image
def pick():    
        font_path = '/home/jack/fonts/'
        font=random.choice([x for x in os.listdir(font_path) if os.path.isfile(os.path.join(font_path, x))])
        return font_path+font
def mkimage():
    path = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/All-images/'
    img = random.choice(os.listdir(path))
    file_path =path+img 
    return file_path
image = Image.open(mkimage())
image = image.resize((1280,720), Image.NEAREST)
W,H = image.size
draw = ImageDraw.Draw(image)
txt = "Python Generated /Processed Images"
fontsize = 6 # starting font size

W, H = image.size

# portion of image width you want text width to be
blank = Image.new('RGB',(W, H))

FONT = pick()
font = ImageFont.truetype(FONT, fontsize)
print image.size

W,H = blank.size
blank = blank.resize((W-100, H-30,), Image.NEAREST)
print blank.size
while (font.getsize(txt)[0] < blank.size[0]) and (font.getsize(txt)[1] < blank.size[1]):
    # iterate until the text size is just larger than the criteria
    fontsize += 1
    font = ImageFont.truetype(FONT, fontsize)

# optionally de-increment to be sure it is less than criteria
fontsize -= 1
font = ImageFont.truetype(FONT, fontsize)

w, h = draw.textsize(txt, font=font)

print 'final font size',fontsize, FONT
draw.text((15,625), txt, font=font, fill="black") # put the text on the image
draw.text((20,620), txt, font=font, fill="white") # put the text on the image
DT = time.strftime("base/%Y-%m-%d-%H-%M-%S.png")
image.save(DT) # save it
image

/home/jack/fonts/Quatl.ttf
/home/jack/fonts/Exo-Black.ttf
/home/jack/fonts/Rafika.ttf
/home/jack/fonts/georgiab.ttf
/home/jack/fonts/Biryani-Light.ttf
/home/jack/fonts/Regulators.ttf
/home/jack/fonts/Quatl.ttf
/home/jack/fonts/DancingScript-VariableFont_wght.ttf
/home/jack/fonts/Tafelschrift.ttf     (nice script)
/home/jack/fonts/VeraSe.ttf

IMG=Image.open("sample-out.png")
IMG



from PIL import ImageFilter, ImageDraw, ImageFont
import time
import shutil
import os
import random
from PIL import Image
from random import randint
def pick():    
        font_path = '/home/jack/fonts/'
        font=random.choice([x for x in os.listdir(font_path) if os.path.isfile(os.path.join(font_path, x))])
        return font_path+font
def mkimage():
    path = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/All-images/'
    img = random.choice(os.listdir(path))
    file_path =path+img 
    path0 = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/All-images/'
    img0 = random.choice(os.listdir(path0))
    file_path0 =path0+img0
    IMG = Image.open(file_path)
    IMG0 = Image.open(file_path0)
    IMG0 =IMG0.resize((640,640), Image.NEAREST)
    w,h = IMG0.size
    IMG1 = IMG0.convert('RGBA')
    im =IMG.resize((1280,720), Image.NEAREST)
    foreground = Image.new('RGBA', (w+5,h+5), (0, 0, 0, 150))
    im.paste(foreground, (580, 60), foreground)
    im1 = im.filter(ImageFilter.MinFilter(7))
    background = im1.filter(ImageFilter.BLUR)
    foreground1 = Image.new('RGBA', (1280,720), (255, 255, 255, 100))
    background.paste(foreground1, (0, 0), foreground1)
    background.paste(IMG1, (600, 50), IMG1)
    background
    text0 = "CREATED by"
    text1 = "LBRY-Toolbox"
    text2 = "ImageBot"
    x= randint(1,4)
    r=randint(125,200)
    g=randint(125,200)
    b=randint(125,200)
    colour = (r, g, b)
    colours = (0,0,0)
    font_file = pick()
    #font_file = random.choice([x for x in os.listdir(font_path) if os.path.isfile(os.path.join(font_path, x))])
    #if x==1:font_file = '/usr/share/fonts/truetype/freefont/FreeSansBold.ttf'
    #if x==2:font_file ="/home/jack/fonts/Biryani-Black.ttf"
    #if x==3:font_file ="/home/jack/fonts/ChangaOne-Regular.ttf"
    #if x==4:font_file ="/home/jack/fonts/Exo-Black.ttf"
    font_size = 70
    font = ImageFont.truetype(font_file, font_size)
    w, h = font.getsize(text)
    draw = ImageDraw.Draw(background)
    H=x*8
    draw.text((30+H, 170+H),text0, colours, font=font)
    draw.text((30+H, 270+H),text1, colours, font=font)
    draw.text((30+H, 370+H),text2, colours, font=font)
    draw.text((30+H-5, 170+H+5),text0, colour, font=font)
    draw.text((30+H-5, 270+H+5),text1, colour, font=font)
    draw.text((30+H-5, 370+H+5),text2, colour, font=font)
    DT = time.strftime("manybot/%Y-%m-%d-%H-%M-%S.png")
    background.save(DT)

for i in range(1,500):
    time.sleep(3)
    print ".",
    mkimage()

from PIL import ImageFilter, ImageDraw, ImageFont
import time
import shutil
import os
import random
from PIL import Image
from random import randint
path = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/All-images/'
img = random.choice(os.listdir(path))
path0 = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/All-images/'
img0 = random.choice(os.listdir(path0))
file_path =path+img
file_path0 =path0+img0
IMG = Image.open(file_path)
IMG0 = Image.open(file_path0)
IMG0 =IMG0.resize((640,640), Image.NEAREST)
w,h = IMG0.size
IMG1 = IMG0.convert('RGBA')
im =IMG.resize((1280,720), Image.NEAREST)
foreground = Image.new('RGBA', (w+5,h+5), (0, 0, 0, 150))
im.paste(foreground, (580, 60), foreground)
im1 = im.filter(ImageFilter.MinFilter(7))
background = im1.filter(ImageFilter.BLUR)
foreground1 = Image.new('RGBA', (1280,720), (255, 255, 255, 100))
background.paste(foreground1, (0, 0), foreground1)
background.paste(IMG1, (600, 50), IMG1)
background
text0 = "CREATED by"
text1 = "LBRY-Toolbox"
text2 = "ImageBot"
x= randint(1,4)
r=randint(125,200)
g=randint(125,200)
b=randint(125,200)
colour = (r, g, b)
colours = (0,0,0)

if x==1:font_file = '/usr/share/fonts/truetype/freefont/FreeSansBold.ttf'
if x==2:font_file ="/home/jack/fonts/Biryani-Black.ttf"
if x==3:font_file ="/home/jack/fonts/ChangaOne-Regular.ttf"
if x==4:font_file ="/home/jack/fonts/Exo-Black.ttf"
font_size = 70
font = ImageFont.truetype(font_file, font_size)
w, h = font.getsize(text)
draw = ImageDraw.Draw(background)
H=x*8
draw.text((30+H, 170+H),text0, colours, font=font)
draw.text((30+H, 270+H),text1, colours, font=font)
draw.text((30+H, 370+H),text2, colours, font=font)
draw.text((30+H-5, 170+H+5),text0, colour, font=font)
draw.text((30+H-5, 270+H+5),text1, colour, font=font)
draw.text((30+H-5, 370+H+5),text2, colour, font=font)
DT = time.strftime("images/%Y-%m-%d-%H-%M.png")
background.save(DT)

from PIL import Image
file_path = DT
IMG = Image.open(file_path)
IMG

from PIL import ImageFilter, ImageDraw, ImageFont
import time
import shutil
import os
import random
from PIL import Image
from random import randint
path = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/GOOD-Blends/'
img = random.choice(os.listdir(path))
path0 = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/GOOD-Blends/'
img0 = random.choice(os.listdir(path0))
file_path =path+img
file_path0 =path0+img0
IMG = Image.open(file_path)
IMG0 = Image.open(file_path0)
IMG0 =IMG0.resize((640,640), Image.NEAREST)
w,h = IMG0.size
IMG1 = IMG0.convert('RGBA')
im =IMG.resize((1280,720), Image.NEAREST)
foreground = Image.new('RGBA', (w+5,h+5), (0, 0, 0, 150))
im.paste(foreground, (580, 60), foreground)
im1 = im.filter(ImageFilter.MinFilter(7))
background = im1.filter(ImageFilter.BLUR)
foreground1 = Image.new('RGBA', (1280,720), (255, 255, 255, 100))
background.paste(foreground1, (0, 0), foreground1)
background.paste(IMG1, (600, 50), IMG1)
background
text0 = "CREATED by"
text1 = "LBRY-Toolbox"
text2 = "ImageBot"
x= randint(1,4)
r=randint(125,200)
g=randint(125,200)
b=randint(125,200)
colour = (r, g, b)
colours = (0,0,0)

if x==1:font_file = '/usr/share/fonts/truetype/freefont/FreeSansBold.ttf'
if x==2:font_file ="/home/jack/fonts/Biryani-Black.ttf"
if x==3:font_file ="/home/jack/fonts/ChangaOne-Regular.ttf"
if x==4:font_file ="/home/jack/fonts/Exo-Black.ttf"
font_size = 70
font = ImageFont.truetype(font_file, font_size)
w, h = font.getsize(text)
draw = ImageDraw.Draw(background)
H=x*8
draw.text((30+H, 170+H),text0, colours, font=font)
draw.text((30+H, 270+H),text1, colours, font=font)
draw.text((30+H, 370+H),text2, colours, font=font)
draw.text((30+H-5, 170+H+5),text0, colour, font=font)
draw.text((30+H-5, 270+H+5),text1, colour, font=font)
draw.text((30+H-5, 370+H+5),text2, colour, font=font)
DT = time.strftime("images/%Y-%m-%d-%H-%M.png")
background.save(DT)

from PIL import Image
file_path = DT
IMG = Image.open(file_path)
IMG

for x in range(1,40):
    y= randint(1,4)
    print y,

from PIL import ImageFilter, ImageDraw, ImageFont
import time
import shutil
import os
import random
from PIL import Image
from random import randint
path = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/forvids/images/'
img = random.choice(os.listdir(path))
file_path =path+img
file_path0 =path+img
IMG = Image.open(file_path)
IMG0 = Image.open(file_path0)
IMG0 =IMG0.resize((640,640), Image.NEAREST)
w,h = IMG0.size
IMG1 = IMG0.convert('RGBA')
im =IMG.resize((1280,720), Image.NEAREST)
foreground = Image.new('RGBA', (w+5,h+5), (0, 0, 0, 150))
im.paste(foreground, (580, 60), foreground)
im1 = im.filter(ImageFilter.MinFilter(7))
background = im1.filter(ImageFilter.BLUR)
foreground1 = Image.new('RGBA', (1280,720), (255, 255, 255, 100))
background.paste(foreground1, (0, 0), foreground1)
background.paste(IMG1, (600, 50), IMG1)
background
text0 = "CREATED by"
text1 = "LBRY-Toolbox"
text2 = "ImageBot"
x= randint(1,4)
r=randint(125,200)
g=randint(125,200)
b=randint(125,200)
colour = (r, g, b)
colours = (0,0,0)

if x==1:font_file = '/usr/share/fonts/truetype/freefont/FreeSansBold.ttf'
if x==2:font_file ="/home/jack/fonts/Biryani-Black.ttf"
if x==3:font_file ="/home/jack/fonts/ChangaOne-Regular.ttf"
if x==4:font_file ="/home/jack/fonts/Exo-Black.ttf"
font_size = 70
font = ImageFont.truetype(font_file, font_size)
w, h = font.getsize(text)
draw = ImageDraw.Draw(background)
H=x*8
draw.text((30+H, 170+H),text0, colours, font=font)
draw.text((30+H, 270+H),text1, colours, font=font)
draw.text((30+H, 370+H),text2, colours, font=font)
draw.text((30+H-5, 170+H+5),text0, colour, font=font)
draw.text((30+H-5, 270+H+5),text1, colour, font=font)
draw.text((30+H-5, 370+H+5),text2, colour, font=font)
DT = time.strftime("images/%Y-%m-%d-%H-%M.png")
background.save(DT)

from PIL import Image
file_path = DT
IMG = Image.open(file_path)
IMG


#image = Image.open(path+img)
print path+img
#shutil.copy(image,"images/image1.jpg")
#shutil.copy(image,"images/image2.jpg")

import shutil
import os
import random
from PIL import Image
path = '/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/forvids/images/'
img = random.choice(os.listdir(path))
img = Image.open(path+img)
def getAverageRGB(img):
  """
  Given PIL Image, return average value of color as (r, g, b)
  """
  # no. of pixels in image
  npixels = image.size[0]*image.size[1]
  # get colors as [(cnt1, (r1, g1, b1)), ...]
  cols = image.getcolors(npixels)
  # get [(c1*r1, c1*g1, c1*g2),...]
  sumRGB = [(x[0]*x[1][0], x[0]*x[1][1], x[0]*x[1][2]) for x in cols] 
  # calculate (sum(ci*ri)/np, sum(ci*gi)/np, sum(ci*bi)/np)
  # the zip gives us [(c1*r1, c2*r2, ..), (c1*g1, c1*g2,...)...]
  avg = tuple([sum(x)/npixels for x in zip(*sumRGB)])
  return avg
print getAverageRGB(img)



from PIL import Image
file_path = DT
IMG = Image.open(file_path)
IMG

path = '/home/jack/Desktop/JupyterNotebooks-languages/manybot/'
img = random.choice(os.listdir(path))
file_Path =path+img

IM=Imageopen(file_Path)
IM

#!/usr/bin/python2
import time
import urllib
import simplejson as json
import requests
name = "Bot-Created-Images" #no Spaces or Special Characters
title = "Image Created with Python Bot"



thumbnail = "https://lbry-toolbox.com/images/BGI-056.jpg"
Text="""
I had a lot of fun with Bots Posting to Twitter. It taught be a lot about image generation. his could be fun.
"""
data = requests.post("http://localhost:5279", json={"method": "publish", "params": {"name": name, "bid": "0.01", "title": title, "file_path": file_Path, "tags": "Python","description":Text, "thumbnail_url": thumbnail, "channel_name": "@LBRY_vps" }}).json()
LINES = (json.dumps(data, indent=2 * ' '))
Lin =str(LINES)
L = Lin.split("\n")
for lines in L:
        print lines


!pwd

scp /home/jack/Desktop/JupyterNotebooks-languages/images/BGI-056.jpg jack@192.243.108.78:/var/www/lbry-toolbox.com/public/images

!ls /home/jack/Desktop/JupyterNotebooks-languages/images/BGI-056.jpg

/mnt/40ec525c-34bc-44ef-99c8-53f5524ad88b/Images/data/ancient art

https://lbry-toolbox.com/images/BGI-056.jpg

#!/usr/bin/python2
import os
from random import randint
from time import sleep
import time
import urllib
import simplejson as json
import requests
import sys
import subprocess
from Completedpy2 import track_download
import sqlite3
import watchVID
DT = time.strftime("%Y-%m-%d-%H:%M")
name = "Plot-Created-by-LBRYCron-Bot" #no Spaces or Special Characters
title = "LBRY LBC Wallet Balance Plot Generated by a Linux Cron Job"
file_path ="/home/jack/Desktop/JupyterNotebooks-languages/test1280.png"
data = requests.post("http://localhost:5279", json={"method": "publish", "params": {"name": name, "bid": "0.01", "title": title, "file_path": file_path, "tags": "python plot","description":"Wallet balance plot generated by a Linux cron job" , "channel_name": "@MyLinuxToyBox" }}).json()
LINES = (json.dumps(data, indent=2 * ' '))
Lin =str(LINES)
L = Lin.split("\n")
for lines in L:
        print lines


from PIL import Image
file_path ="/home/jack/Desktop/JupyterNotebooks-languages/test-full.png"
IMG = Image.open(file_path)
IM =IMG.resize((1280,720), Image.NEAREST)
im = IM.size
IM.save("/home/jack/Desktop/JupyterNotebooks-languages/test1280.png")
IM

!lbrynet address list --address=bDyZqrP3KoUVjotbdiRsPgkXpqHvASLPrT --page_size=50 --page=1

!lbrynet address list 


!ls test.jpg



publish

Create or replace a stream claim at a given name (use 'stream create/update' for more control).
Arguments

name    str    name of the content (can only consist of a-z A-Z 0-9 and -(dash))
bid    optionaldecimal    amount to back the claim
file_path    optionalstr    path to file to be associated with name.
fee_currency    optionalstring    specify fee currency
fee_amount    optionaldecimal    content download fee
fee_address   optionalstr    address where to send fee payments, gefaut value from --claim_address if not provided
title    optionalstr    title of the publication
description    optionalstr    description of the publication
author    optionalstr    author of the publication. The usage for this field is not the same as for channels. The author field is used to credit an author who is not the publisher and is not represented by the channel. For example, a pdf file of 'The Odyssey' has an author of 'Homer' but may by published to a channel such as '@classics', or to no channel at all
tags    optionallist    add content tags
languages    optionallist    languages used by the channel, using RFC 5646 format, eg: for English `--languages=en` for Spanish (Spain) `--languages=es-ES` for Spanish (Mexican) `--languages=es-MX` for Chinese (Simplified) `--languages=zh-Hans` for Chinese (Traditional) `--languages=zh-Hant`
locations    optionallist    locations relevant to the stream, consisting of 2 letter `country` code and a `state`, `city` and a postal `code` along with a `latitude` and `longitude`. for JSON RPC: pass a dictionary with aforementioned attributes as keys, eg: ... "locations": [{'country': 'US', 'state': 'NH'}] ... for command line: pass a colon delimited list with values in the following order: "COUNTRY:STATE:CITY:CODE:LATITUDE:LONGITUDE" making sure to include colon for blank values, for example to provide only the city: ... --locations="::Manchester" with all values set: ... --locations="US:NH:Manchester:03101:42.990605:-71.460989" optionally, you can just pass the "LATITUDE:LONGITUDE": ... --locations="42.990605:-71.460989" finally, you can also pass JSON string of dictionary on the command line as you would via JSON RPC ... --locations="{'country': 'US', 'state': 'NH'}"
    license
    optionalstr
    publication license
    license_url
    optionalstr
    publication license url
    thumbnail_url
    optionalstr
    thumbnail url
    release_time
    optionalint
    original public release of content, seconds since UNIX epoch
    width
    optionalint
    image/video width, automatically calculated from media file
    height
    optionalint
    image/video height, automatically calculated from media file
    duration
    optionalint
    audio/video duration in seconds, automatically calculated
    channel_id
    optionalstr
    claim id of the publisher channel
    channel_name
    optionalstr
    name of publisher channel
    channel_account_id
    optionalstr
    one or more account ids for accounts to look in for channel certificates, defaults to all accounts.
    account_id
    optionalstr
    account to use for holding the transaction
    wallet_id
    optionalstr
    restrict operation to specific wallet
    funding_account_ids
    optionallist
    ids of accounts to fund this transaction
    claim_address
    optionalstr
    address where the claim is sent to, if not specified it will be determined automatically from the account
    preview
    optionalbool
    do not broadcast the transaction
    blocking
    optionalbool
    wait until transaction is in mempool


!locate *.ttf

def pick():    
        font_path = '/home/jack/fonts/'
        font=random.choice([x for x in os.listdir(font_path) if os.path.isfile(os.path.join(font_path, x))])
        return font_path+font
for i in range(1,100):
    print pick()    



!ls /home/jack/fonts

def getAverageRGB(img):
  """
  Given PIL Image, return average value of color as (r, g, b)
  """
  # no. of pixels in image
  npixels = image.size[0]*image.size[1]
  # get colors as [(cnt1, (r1, g1, b1)), ...]
  cols = image.getcolors(npixels)
  # get [(c1*r1, c1*g1, c1*g2),...]
  sumRGB = [(x[0]*x[1][0], x[0]*x[1][1], x[0]*x[1][2]) for x in cols] 
  # calculate (sum(ci*ri)/np, sum(ci*gi)/np, sum(ci*bi)/np)
  # the zip gives us [(c1*r1, c2*r2, ..), (c1*g1, c1*g2,...)...]
  avg = tuple([sum(x)/npixels for x in zip(*sumRGB)])
  return avg
print getAverageRGB(img)

#https://stackoverflow.com/questions/24021579/how-to-set-appropriate-line-width-for-drawing-text-in-python-pil
from PIL import Image
from PIL import ImageFont
from PIL import ImageDraw 
import textwrap
def pick():    
        font_path = '/home/jack/fonts/'
        font=random.choice([x for x in os.listdir(font_path) if os.path.isfile(os.path.join(font_path, x))])
        return font_path+font
    
size_x = 600 #This value can arbitrarily change
size_y = 700 #This value can arbitrarily change
font_size = 18 #This value can be adjusted to fit parameters of image if necessary

my_text = ['Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam scelerisque sapien convallis nisl facilisis, sed facilisis odio accumsan. Maecenas vel leo eu turpis porta dictum at vel neque. Donec sagittis felis non tellus lacinia facilisis. Vivamus vel nisi ullamcorper, feugiat lorem sagittis, pellentesque dolor. Curabitur est magna, feugiat ut nibh quis, blandit vestibulum nisl. Sed pulvinar condimentum purus et rutrum. Proin magna arcu, scelerisque at gravida ut, convallis quis orci. Mauris ipsum tortor, laoreet et leo ac, lacinia euismod tellus. Curabitur volutpat nisi a metus faucibus, vel iaculis nisl fermentum. Curabitur et orci id sapien porttitor dignissim at ac dolor. Donec nec mattis nisi. ']

tx = Image.new('RGB', (size_x, size_y),color=(255,255,255))
draw = ImageDraw.Draw(tx)
randomfont=pick()
my_font = ImageFont.truetype(randomfont,size=font_size)
lines = textwrap.wrap(my_text[0], width = 130) #This width value needs to be set automatically
y_text = 0
for line in lines:
    width, height = my_font.getsize(line)
    draw.text((0, y_text), line, font = my_font, fill = (0,0,0))
    y_text += height

tx.show()

from PIL import ImageFont, ImageDraw, Image
import time
import os
import random
from random import randint

!mkdir base
!mkdir images

!wget https://jacknorthrup.com/postoids/postoid%20%2810%29.jpg
!wget https://jacknorthrup.com/postoids/Philippine-Specialty-Paper.jpg

!mv Philippine-Specialty-Paper.jpg.1 images/background.jpg
!mv postoid\ \(10\).jpg.1 images/postoid.jpg

from PIL import Image
IM = Image.open('images/background.jpg')
IM

from PIL import Image
IM = Image.open('images/postoid.jpg')
IM

from PIL import ImageFont, ImageDraw, Image
import time
import os
import random
from random import randint
        
FONT='/usr/share/fonts/truetype/dejavu/DejaVuSerif-Bold.ttf'
IMAGE1 = 'images/background.jpg'
image = Image.open(IMAGE1)
image = image.resize((1280,720), Image.NEAREST)
W,H = image.size
draw = ImageDraw.Draw(image)
txt = "Python Generated From VPS"
fontsize = 6 # starting font size
W, H = image.size
# portion of image width you want text width to be
blank = Image.new('RGB',(W, H))

font = ImageFont.truetype(FONT, fontsize)
#print image.size

W,H = blank.size
blank = blank.resize((W-100, H-30,), Image.NEAREST)
#print blank.size
while (font.getsize(txt)[0] < blank.size[0]) and (font.getsize(txt)[1] < blank.size[1]):
    # iterate until the text size is just larger than the criteria
    fontsize += 1
    font = ImageFont.truetype(FONT, fontsize)

# optionally de-increment to be sure it is less than criteria
fontsize -= 1
font = ImageFont.truetype(FONT, fontsize)

w, h = draw.textsize(txt, font=font)
#print 'final font size',fontsize, FONT
draw.text((15,625), txt, font=font, fill="black") # put the text on the image
draw.text((20,620), txt, font=font, fill="white") # put the text on the image
DT = time.strftime("base/%Y-%m-%d-%H-%M-%S.png")
image.save(DT) # save it
print (DT)

from PIL import Image
IM = Image.open('base/2020-02-19-22-50-45.png')
IM

from PIL import ImageFilter, ImageDraw, ImageFont
import time
import shutil
import os
import random
from PIL import Image
from random import randint
font_file='/usr/share/fonts/truetype/dejavu/DejaVuSerif-Bold.ttf'
file_path ="base/2020-02-19-22-50-45.png"
IMG = Image.open(file_path)
file_path0='images/postoid.jpg'
IMG0 = Image.open(file_path0)
#IMG0 =IMG0.resize((640,640), Image.NEAREST)
w,h = IMG0.size
IMG1 = IMG0.convert('RGBA')
im =IMG.resize((1280,720), Image.NEAREST)
foreground = Image.new('RGBA', (w+5,h+5), (0, 0, 0, 200))
im.paste(foreground, (700, 160), foreground)
im1 = im.filter(ImageFilter.MinFilter(7))
background = im1.filter(ImageFilter.BLUR)
foreground1 = Image.new('RGBA', (1280,720), (255, 255, 255, 100))
background.paste(foreground1, (0, 0), foreground1)
background.paste(IMG1, (720, 150), IMG1)
background
text0 = "CREATED by"
text1 = "LBRY-Toolbox"
text2 = "ImageBot"
x= randint(1,4)
r=randint(125,200)
g=randint(125,200)
b=randint(125,200)
colour = (r, g, b)
colours = (0,0,0)
font_size = 70
font = ImageFont.truetype(font_file, font_size)
w, h = font.getsize(text1)
draw = ImageDraw.Draw(background)
H=x*8
draw.text((30+H, 170+H),text0, colours, font=font)
draw.text((30+H, 270+H),text1, colours, font=font)
draw.text((30+H, 370+H),text2, colours, font=font)
draw.text((30+H-5, 170+H+5),text0, colour, font=font)
draw.text((30+H-5, 270+H+5),text1, colour, font=font)
draw.text((30+H-5, 370+H+5),text2, colour, font=font)
DT = time.strftime("images/%Y-%m-%d-%H-%M.png")
background.save(DT)
print (DT)
from PIL import Image
file_path = DT
IMG = Image.open(file_path)
IMG

!ls images/*.jpg

TEXT ="""
The postoid below has a funny story. Notice it is the leaning tower of FRANCE   ????? 
I had some mail art rubbber art stamps made. The set was in fact the same as the white postoid / mail art paper in our mail art specialty paper set. As soon as they came in I started stamping and playing with ideas. I made postoids until about 2:30am. That is when I made this four corner stamp. It wasn't until I had finished I realized I put the leaning tower of Pisa in my france stamp.
My faux stamp misprint
"""    
    

requests.post("http://localhost:5279", json={"method": "channel_create", "params": {"name": "@LBRY-vps", "bid": "1.0", "tags": "vps"}}).json()

#!/usr/bin/python2
import time
import urllib
import simplejson as json
import requests
data = requests.post("http://localhost:5279", json={"method": "channel_create", "params": {"name": "@CHANNELNAME", "bid": "2.0", "tags": "vps"}}).json()
LINES = (json.dumps(data, indent=2 * ' '))
Lin =str(LINES)
L = Lin.split("\n")
for lines in L:
        print (lines)


#!/usr/bin/python2
import time
import urllib
import simplejson as json
import requests
name = "First-Post-From-VPS" #no Spaces or Special Characters
title = "Bot Generated Image"
file_Path = "/home/jack/Desktop/LBRY-toolbox/images/2020-02-19-23-02.png"
thumbnail = "/home/jack/Desktop/LBRY-toolbox/base/2020-02-19-22-50-45.png"
Text="""
The postoid below has a funny story. Notice it is the leaning tower of FRANCE   ????? 
I had some mail art rubbber art stamps made. The set was in fact the same as the white postoid 
mail art paper in our mail art specialty paper set. As soon as they came in I started stamping
and playing with ideas. I made postoids until about 2:30am. That is when I made this four corner
stamp. It wasn't until I had finished I realized I put the leaning tower of Pisa in my france stamp.
My faux stamp misprint
"""
data = requests.post("http://localhost:5279", json={"method": "publish", "params": {"name": name, "bid": "0.01", "title": title, "file_path": file_Path, "tags": "Python","description":Text, "thumbnail_url": thumbnail,"channel_id": "This is the string following the channel0name#"}}).json()
LINES = (json.dumps(data, indent=2 * ' '))
Lin =str(LINES)
L = Lin.split("\n")
for lines in L:
        print (lines)


#!/usr/bin/python2
import time
import urllib
import simplejson as json
import requests
name = "First-Post-of-Wallet-Plot" #no Spaces or Special Characters
title = "This will be fun to look back at"
image = "/home/jack/Desktop/VPS_resources/202002201016-final.png"
thumbnail = "/home/jack/Desktop/VPS_resources/202002201016-final.png"
Text="""
I got a plot of the first two tips. WOW !
"""
data = requests.post("http://localhost:5279", json={"method": "publish", "params": {"name": name, "bid": "0.01", "title": title, "file_path": image, "tags": "LBC Plot","description":Text, "thumbnail_url": image, "channel_id": "xxzxzxzxzxxxxxxxx" }}).json()
LINES = (json.dumps(data, indent=2 * ' '))
Lin =str(LINES)
L = Lin.split("\n")
for lines in L:
      print (lines)