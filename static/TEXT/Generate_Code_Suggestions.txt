Generate Code Suggestions
user
from flask import Flask, render_template, request

app = Flask(__name__)

# Read snippets from file into memory
with open('snippets.txt', 'r') as file:
    snippets = file.readlines()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/save', methods=['POST'])
def save():
    code = request.form['code']
    suggestions = generate_suggestions(code)
    return {'suggestions': suggestions}

def generate_suggestions(code):
    # Retrieve the last line from the code
    lines = code.split('\n')
    last_line = lines[-1]

    # Split the last line into words and get the last four words
    words = last_line.split()
    last_four_words = ' '.join(words[-4:])

    # Search for a matching snippet based on the last four words
    matching_snippets = [snippet.strip() for snippet in snippets if last_four_words in snippet]

    return matching_snippets

if __name__ == '__main__':
    app.run(debug=True)

ChatGPT
It seems like you're building a Flask application for generating code suggestions based on the last four words of a user's input. Here's the modified code with logging added for better understanding:

```python
import logging
from flask import Flask, render_template, request

app = Flask(__name__)

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Read snippets from file into memory
with open('snippets.txt', 'r') as file:
    snippets = file.readlines()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/save', methods=['POST'])
def save():
    code = request.form['code']
    logger.debug(f"Received code: {code}")
    suggestions = generate_suggestions(code)
    logger.debug(f"Generated suggestions: {suggestions}")
    return {'suggestions': suggestions}

def generate_suggestions(code):
    logger.debug("Generating suggestions...")
    # Retrieve the last line from the code
    lines = code.split('\n')
    last_line = lines[-1]

    # Split the last line into words and get the last four words
    words = last_line.split()
    last_four_words = ' '.join(words[-4:])
    logger.debug(f"Last four words: {last_four_words}")

    # Search for a matching snippet based on the last four words
    matching_snippets = [snippet.strip() for snippet in snippets if last_four_words in snippet]
    logger.debug(f"Matching snippets: {matching_snippets}")

    return matching_snippets

if __name__ == '__main__':
    app.run(debug=True)
```

This code includes logging statements to provide insights into the flow of the program and aid in debugging. Let me know if you need further assistance or if you'd like to enhance any part of this code.
user
index.html
ChatGPT
Here's a simple `index.html` template that you can use:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Suggestions</title>
</head>
<body>
    <h1>Code Suggestions</h1>
    <form action="/save" method="POST">
        <label for="code">Enter your code:</label><br>
        <textarea id="code" name="code" rows="5" cols="50"></textarea><br>
        <button type="submit">Generate Suggestions</button>
    </form>
    <div id="suggestions">
        <!-- Suggestions will be displayed here -->
    </div>
</body>
</html>
```

This HTML template provides a text area for users to input their code and a button to submit it. The suggestions generated by the Flask application will be displayed below the form. You can customize this template further according to your requirements. Let me know if you need any changes or additional features!
user
when i click enter it opens a new page
ChatGPT
To prevent the form from opening a new page when you press enter, you can use JavaScript to capture the form submission event and prevent the default behavior. Here's how you can modify the HTML to achieve this:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Suggestions</title>
</head>
<body>
    <h1>Code Suggestions</h1>
    <form id="codeForm">
        <label for="code">Enter your code:</label><br>
        <textarea id="code" name="code" rows="5" cols="50"></textarea><br>
        <button type="button" onclick="submitForm()">Generate Suggestions</button>
    </form>
    <div id="suggestions">
        <!-- Suggestions will be displayed here -->
    </div>

    <script>
        function submitForm() {
            var code = document.getElementById('code').value;
            fetch('/save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ code: code }),
            })
            .then(response => response.json())
            .then(data => {
                displaySuggestions(data.suggestions);
            })
            .catch((error) => {
                console.error('Error:', error);
            });
        }

        function displaySuggestions(suggestions) {
            var suggestionsDiv = document.getElementById('suggestions');
            suggestionsDiv.innerHTML = '<h2>Suggestions:</h2>';
            suggestions.forEach(function(suggestion) {
                suggestionsDiv.innerHTML += '<p>' + suggestion + '</p>';
            });
        }

        document.getElementById('codeForm').addEventListener('submit', function(event) {
            event.preventDefault(); // Prevent the default form submission
            submitForm(); // Manually submit the form using JavaScript
        });
    </script>
</body>
</html>
```

In this updated version, the form submission is intercepted by JavaScript. When the user clicks the "Generate Suggestions" button or presses enter in the text area, the `submitForm()` function is called, which sends the code to the server using a POST request and then displays the suggestions without reloading the page.
user
import os
from flask import Flask, render_template, request, Blueprint
import datetime
import glob
import shutil
test_py_bp = Blueprint('test_py', __name__)

# Configure logging
def logit(logdata):
    timestr = filename = datetime.datetime.now().strftime('%A_%b-%d-%Y')
    with open("testlog.txt", "a") as log_file:
        log_file.write(f"{timestr}: {logdata} <br/>")
    print("mylog.txt entry:", logdata)

logit("TEST: 12345")

@test_py_bp.route('/readlog')
def readlog():
    logdata = []
    with open("testlog.txt", "r") as log_file:
        logdata = log_file.readlines()
    return render_template('read_log.html', log_content=logdata)

# Read functions from app.py file into memory
def read_functions():
    with open('app_txt.py', 'r') as file:
        code = file.read()
        functions = code.split('\n\n')  # Assume functions are separated by empty lines
    return functions

functions = read_functions()

@test_py_bp.route('/index_y')
def index_y():
    return render_template('index_y.html')

@test_py_bp.route('/save', methods=['POST'])
def save():
    code = request.form['code']
    logit(f"Received code: {code}")
    suggestions = generate_suggestions(code)
    logit(f"Generated suggestions: {suggestions}")
    return {'suggestions': suggestions}

def generate_suggestions(code):
    logit("Generating suggestions...")
    # Retrieve the last line from the code
    lines = code.split('\n')
    last_line = lines[-1]

    # Split the last line into words and get the last four words
    words = last_line.split()
    last_four_words = ' '.join(words[-4:])
    logit(f"Last four words: {last_four_words}")

    # Search for a matching snippet based on the last four words
    matching_snippets = []
    for i, snippet in enumerate(functions, start=1):
        if last_four_words in snippet:
            # Format the snippet with line numbers and preserve whitespace
            formatted_snippet = f"<pre>{i}: {snippet.strip()}</pre>"
            matching_snippets.append(formatted_snippet)

    logit(f"Matching snippets: {matching_snippets}")

    return matching_snippets
@test_py_bp.route('/save_code', methods=['POST'])
def save_code():
    # Extract the code from the request body
    code = request.data.decode('utf-8')

    if code:
        # Append the code to the new_app.py file
        with open('new_app.py', 'a') as file:
            file.write(code + '\n')
        
        return 'Code saved successfully', 200
    else:
        return 'No code provided in the request', 400

my app will not import this
ChatGPT
It seems like you're trying to organize your Flask application using Blueprints, but you're encountering issues with importing the `test_py_bp` Blueprint into your main Flask application. Here's a complete script that combines your main Flask application with the Blueprint:

```python
import os
import datetime
from flask import Flask, render_template, request, Blueprint

app = Flask(__name__)

# Configure logging
def logit(logdata):
    timestr = datetime.datetime.now().strftime('%A_%b-%d-%Y')
    with open("testlog.txt", "a") as log_file:
        log_file.write(f"{timestr}: {logdata}\n")
    print("mylog.txt entry:", logdata)

logit("TEST: 12345")

# Define Blueprint
test_py_bp = Blueprint('test_py', __name__)

# Read functions from app.py file into memory
def read_functions():
    with open('app_txt.py', 'r') as file:
        code = file.read()
        functions = code.split('\n\n')  # Assume functions are separated by empty lines
    return functions

functions = read_functions()

@test_py_bp.route('/readlog')
def readlog():
    logdata = []
    with open("testlog.txt", "r") as log_file:
        logdata = log_file.readlines()
    return render_template('read_log.html', log_content=logdata)

@test_py_bp.route('/index_y')
def index_y():
    return render_template('index_y.html')

@test_py_bp.route('/save', methods=['POST'])
def save():
    code = request.form['code']
    logit(f"Received code: {code}")
    suggestions = generate_suggestions(code)
    logit(f"Generated suggestions: {suggestions}")
    return {'suggestions': suggestions}

def generate_suggestions(code):
    logit("Generating suggestions...")
    # Retrieve the last line from the code
    lines = code.split('\n')
    last_line = lines[-1]

    # Split the last line into words and get the last four words
    words = last_line.split()
    last_four_words = ' '.join(words[-4:])
    logit(f"Last four words: {last_four_words}")

    # Search for a matching snippet based on the last four words
    matching_snippets = []
    for i, snippet in enumerate(functions, start=1):
        if last_four_words in snippet:
            # Format the snippet with line numbers and preserve whitespace
            formatted_snippet = f"<pre>{i}: {snippet.strip()}</pre>"
            matching_snippets.append(formatted_snippet)

    logit(f"Matching snippets: {matching_snippets}")

    return matching_snippets

@test_py_bp.route('/save_code', methods=['POST'])
def save_code():
    # Extract the code from the request body
    code = request.data.decode('utf-8')

    if code:
        # Append the code to the new_app.py file
        with open('new_app.py', 'a') as file:
            file.write(code + '\n')
        
        return 'Code saved successfully', 200
    else:
        return 'No code provided in the request', 400

# Register Blueprint
app.register_blueprint(test_py_bp)

if __name__ == '__main__':
    app.run(debug=True)
```

Make sure the directory structure is set up correctly, with the `app_txt.py` file in the same directory as your main Flask script. Additionally, ensure that your templates (e.g., `index_y.html` and `read_log.html`) are properly located in a `templates` directory within your project directory. If you're still facing issues, please provide more details about the error you're encountering.
user
#!/home/jack/miniconda3/envs/cloned_base/bin/python
# app.py
from flask import Flask, render_template, request, redirect, url_for
from flask import send_from_directory, Response, flash, request, session, jsonify, abort
import random
import glob
from PIL import Image
import os 
import shutil
import sqlite3
import base64
import datetime
import time
from view_gallery import view_gallery_bp
from test_html_bp import test_html_bp_bp
from test_py import test_py_bp
app = Flask(__name__)
# create  logging funtction
app.register_blueprint(view_gallery_bp)
app.register_blueprint(test_html_bp_bp)
app.register_blueprint(test_py_bp)

def logit(logdata):
    timestr = filename = datetime.datetime.now().strftime('%A_%b-%d-%Y')
    Input=open("mylog.txt","a")
    Input.write(f"{timestr}:{logdata}")
    Input.close()
    return print("mylog.txt entry: ",logdata)

def logit2(logdata):
    Input=open("mylog2.txt","a")
    Input.write(logdata+"\n")
    Input.close()
    return print("mylog2.txt entry: ",logdata)

@app.route('/readlog')
def readlog():
    logdata=[]
    logdatas=open("mylog.txt","r").read()
    logdata= logdatas.split("\n")
    for log in logdata:
        log=log.replace("\n","")
        logdata.append(log)
        return render_template('read_log.html', log_content=logdata)

@app.route('/', methods=['GET', 'POST'])
def index():
    text_files = find_txt()
    logit(f"text_files: {text_files}")
    return render_template('index.html', text_files=text_files)

def find_txt():
    filenames =sorted(glob.glob('static/text/*.txt'))
    return filenames
 
def create_database(database_name):
    conn = sqlite3.connect(database_name)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS prompts
                 (id INTEGER PRIMARY KEY,
                 CURRENT_date, TEXT,   
                 url_name TEXT,    
                 url_link BLOB,
                 prompt TEXT,
                 image_name text,
                 image_data BLOB)''')
    conn.commit()
    conn.close()

# CURRENT_date,url_name,url_link,prompt,image_name,image_data)''')
def insertData(CURRENT_date,database_name,filename,content,contents):
    conn = sqlite3.connect(database_name)
    c = conn.cursor()
    #c.execute("INSERT INTO dialogue (user_ChatGPT_PAIR) VALUES (?)", (dialogue_data,))
    c.execute("INSERT INTO prompt (CURRENT_date,url_name,url_linkdecode('utf-8',prompt,image_name,image_data.decode('utf-8') VALUES (?,?,?,?,?,?)", (CURRENT_date,url_name,url_link,prompt,image_name,image_data),)
    conn.commit()
    conn.close()
    
@app.route('/read_image', methods=['POST','GET'])
def read_image(image_path):    
    contents=open(image_path,'rb').read()
    image_data=contents.decode('utf-8')
    filename=filename.replace('static/uploads/','')
    insertData(database_name,filename,content,contents)
    return

@app.route('/help')
def get_help():
    content =open('static/text/help.txt','rb').read()
    help_content=content.decode('utf-8')
    return render_template('help.html',help_content=help_content)#search_multiple_term flask,app,route,port >resource         

@app.route('/edit_text_page')
def edit_text_page():
    selected_filename = request.args.get('filename')
    original_content = load_original_text_file(selected_filename)
    text_files = find_txt()
    return render_template('edit_text_page.html', selected_filename=selected_filename, original_content=original_content,text_files=text_files)

#/edit_text_save
@app.route('/edit_text_save', methods=['POST','GET'])
def edit_text_save():
    if request.method == 'POST':
        content = request.form['edited_content']
        filename = request.form['filename']
        open('static/text/'+filename,'w').write(content)
        return render_template('edit_file.html', filenames=filenames, selected_filename=filename)

@app.route('/edit_file', methods=['GET', 'POST'])
def edit_file():
    if request.method == 'POST':
        filename = request.form.get('filename')
        text = request.form.get('text')

        # Save the changes to the file
        with open(f'static/text/{filename}', 'w') as file:
            file.write(text)
    
    text_files_dir = 'static/text/'
    text_files = []

    # Retrieve list of text files in the directory
    for filename in os.listdir(text_files_dir):
        if filename.endswith('.txt'):
            text_files.append(filename)
            logit(filename)

    return render_template('edit_file.html', filenames=text_files)

static_dir = 'static'
text_dir = os.path.join(static_dir, 'text')
original_text_dir = os.path.join(text_dir, 'original')
os.makedirs(original_text_dir, exist_ok=True)

def load_original_text_file(filename):
    original_file_path = filename
    with open(original_file_path, 'r') as file:
        return file.read()

def save_original_text_file(filename, content):
    now = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    new_filename = f"{filename}_{now}.txt"
    new_file_path = os.path.join(original_text_dir, new_filename)
    with open(new_file_path, 'w') as file:
        file.write(content)

@app.route('/edit_text')
def edit_text():
    filenames =sorted(glob.glob('static/text/*.txt'))
    return render_template('edit_text.html', filenames=filenames)

@app.route('/find_text')
def find_text():
    #create a list of sorted text files
    filenames = sorted(glob.glob('static/text/*.txt'))
    logit(filenames)
    return render_template('edit_text.html', filenames=filenames)

def split_text(file_path, parts=5):
    # Read the content of the text file
    with open(file_path, 'rb') as file:
        text = file.read().decode('utf-8')  # Assuming text encoding is UTF-8
    
    # Calculate the length of each part
    part_length = len(text) // parts
    
    # Split the text into equal parts
    parts_list = [text[i:i+part_length] for i in range(0, len(text), part_length)]
    
    return parts_list

@app.route('/split-text', methods=['GET', 'POST'])
def split_text_route():
    if request.method == 'GET':
        # Get the directory path of the text files
        directory = os.path.join(app.static_folder, 'text')
        
        # Get the list of available text files
        text_files = [f for f in os.listdir(directory) if f.endswith('.txt')]
        
        return render_template('file_selection.html', text_files=text_files)
    elif request.method == 'POST':
        # Get the selected file name from the form
        file_name = request.form.get('file_name')
        
        if not file_name:
            abort(400, 'File name not provided.')
        
        # Get the directory path of the text files
        directory = os.path.join(app.static_folder, 'text')
        
        # Check if the file exists
        file_path = os.path.join(directory, file_name)
        if not os.path.exists(file_path):
            abort(404, 'File not found.')
        
        # Split the specified text file into five equal parts and save them
        parts = split_text(file_path)
        base_name, ext = os.path.splitext(file_name)
        for i, part in enumerate(parts):
            part_file_path = os.path.join(directory, f'{base_name}_part_{i+1}{ext}')
            with open(part_file_path, 'wb') as part_file:
                part_file.write(part.encode('utf-8'))
        
        return f'Text file "{file_name}" split into 5 equal parts and saved with original format.'

@app.route('/get_gallery')
def get_gallery():
    image_dir = 'static/images/uploads'
    image_names = os.listdir(image_dir)
    return render_template('get_gallery.html', image_names=image_names)

if __name__=="__main__":
    database_name = 'PROMPTS.db'
    create_database(database_name)
    app.run(port=5100,debug=True)
         
 
 #!/home/jack/Desktop/FlaskAppArchitect_Flask_App_Creator/env/bin/python
from moviepy.editor import *
from flask import Flask, render_template, request, redirect, url_for, send_from_directory, Response, flash, request, session, jsonify
from flask import send_file, g
import os
import pygame
from gtts import gTTS
import cv2
import dlib
import numpy as np
from random import randint
from moviepy.editor import VideoFileClip, ImageClip, CompositeVideoClip
from moviepy.editor import concatenate_videoclips, AudioFileClip
import moviepy.editor as mp
import moviepy.editor
import subprocess
from pathlib import Path as change_ext
import re
from io import BytesIO
import io
import matplotlib.pyplot as plt
import sqlite3
import random
import glob
import signal
import base64
import tempfile
import datetime
import imageio
import time
from werkzeug.utils import secure_filename
import shutil
from search import search
from time import sleep
from pydub import AudioSegment
from PIL import Image, ImageDraw, ImageFont
import uuid
from clean_images import clean_images
from flask_cors import CORS
import json
import logging
from logging.handlers import RotatingFileHandler
from view_gallery import view_gallery_bp
from create_comic import create_comic_bp
from view_archive_videos import view_archive_videos_bp
from api_search.api_search import api_search_bp
from mp3_sound.mp3_sound import mp3_sound_bp
from zoomin import zoomin_bp
import sys
from selenium import webdriver
from icecream import ic 
# Initialize Flask app
app = Flask(__name__)
# Set the template folder for the main app
app.template_folder = 'templates'
# Register your Blueprint and specify its template folder
api_search_template_folder = 'api_search/templates'
app.register_blueprint(api_search_bp, url_prefix='/api_search', template_folder=api_search_template_folder)
# Register the Blueprint from view_gallery.py with the main app
app.register_blueprint(view_gallery_bp)
app.register_blueprint(create_comic_bp)
app.register_blueprint(zoomin_bp)
app.register_blueprint(view_archive_videos_bp)
app.register_blueprint(mp3_sound_bp)
app.static_folder = 'static'
# allow CORS
CORS(app)
app.secret_key = os.urandom(24)
# Create a logger object
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Create a formatter for the log messages
formatter = logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]')

# Create a file handler to write log messages to a file
file_handler = RotatingFileHandler(
    'Logs/app.log', maxBytes=10000, backupCount=1)
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(formatter)

# Add the file handler to the logger
logger.addHandler(file_handler)

SDIR = "static/"
# Define the file path to store the script content
script_file = os.path.join(os.getcwd(), SDIR, 'scripts', 'scripts.js')

# Route to the main app's template

def findvideos():
    videoroot_directory = "static"
    MP4 = []
    for dirpath, dirnames, filenames in os.walk(videoroot_directory):
        for filename in filenames:
            if filename.endswith(".mp4") and "Final" in filename:
                MP4.append(os.path.join(dirpath, filename))
    if MP4:
        last_video = session.get("last_video")
        new_video = random.choice([video for video in MP4 if video != last_video])
        session["last_video"] = new_video
        return new_video
    else:
        return None


@app.route('/')
def index():
    video = findvideos()
    return render_template('index.html', video=video)


@app.route('/hello_world')
def hello_world():
    TExt = "TEXT TEST 6789"
    logger.debug('This is a debug message: %s', TExt)

    TEXT = "TEXT TEST abcd"
    logger.debug('This is a debug message: %s', TEXT)

    return "Hello, World!"


directory_path = "static/current_project"
if not os.path.exists(directory_path):
    os.makedirs(directory_path)
app.config['UPLOAD_FOLDER'] = 'static/images/uploads'
app.config['RESULTS_FOLDER'] = 'static/videos/results'
app.config['THUMBNAILS_FOLDER'] = 'static/images/thumbnails'
app.config['CHECKPOINT_PATH'] = 'checkpoints/wav2lip_gan.pth'
app.config['AUDIO_PATH'] = 'sample_data/input_audio.wav'
app.config['video_PATH'] = 'sample_data/input_videio.mp4'
app.config['DATABASE'] = 'code.db'  # SQLite database file
app.secret_key = "your_secret_key"  # Add a secret key for session management


@app.route('/favicons.ico')
def favicons():
    return send_from_directory(os.path.join(app.root_path, 'static'), 'favicon.ico', mimetype='image/vnd.microsoft.icon')


@app.route('/favicon.ico')
def favicon():
    # Set the size of the favicon
    size = (16, 16)
    # Create a new image with a transparent background
    favicon = Image.new('RGBA', size, (0, 0, 0, 0))
    # Create a drawing object
    draw = ImageDraw.Draw(favicon)
    # Draw a yellow square
    square_color = (255, 0, 255)
    draw.rectangle([(0, 0), size], fill=square_color)
    # Draw a red circle
    circle_center = (size[0] // 2, size[1] // 2)
    circle_radius = size[0] // 3
    logger.info(f'circle_center, circle_radius:,{circle_center} {circle_radius}')
    circle_color = (255, 255, 0)
    draw.ellipse(
        [(circle_center[0] - circle_radius, circle_center[1] - circle_radius),
         (circle_center[0] + circle_radius, circle_center[1] + circle_radius)],
        fill=circle_color
    )
    # Save the image to a memory buffer
    image_buffer = io.BytesIO()
    favicon.save(image_buffer, format='ICO')
    image_buffer.seek(0)
    return Response(image_buffer.getvalue(), content_type='image/x-icon')


# use the search function as a route
app.add_url_rule('/search', 'search', search)


def zip_lists(list1, list2):
    return zip(list1, list2)
app.jinja_env.filters['zip'] = zip_lists

def create_directory_path(directory):
    # Create the directory if it doesn't exist
    os.makedirs(directory_path, exist_ok=True)


def ClipList():
    cliplist = glob.glob("clip*.mp3")
    print(cliplist)
    return cliplist
for clip in ClipList():
    os.remove(clip)   


@app.route("/index2")
def index2():
    image_dir = 'static/images/MISC_MIX'
    image_files = [f for f in os.listdir(image_dir) if f.endswith('.jpg')]
    random_image_file = random.choice(image_files)
    return render_template('index2.html', random_image_file="images/MISC_MIX/" + random_image_file)


def generate_output():
    # Specify the path to your Bash script
    bash_script_path = '/home/jack/Desktop/StoryMaker/MakeVideo'
    # Execute the Bash script
    subprocess.run(['bash', bash_script_path])
    # Backup the result_videoxx.mp4 file
    current_datetime = str(int(time.time()))
    backup_filename = f"static/{current_datetime}.mp4"
    original_filename = "results/result_voice.mp4"
    shutil.copyfile(original_filename, backup_filename)
    return redirect('/final_lipsync')


@app.route('/create_avatar', methods=['GET', 'POST'])
def create_avatar():
    if request.method == 'POST':
        # check_point = os.path.join(app.config['CHECKPOINT_PATH'], 'checkpoints/wav2lip_gan.pth')
        return Response(generate_output(), mimetype='text/plain')
    else:
        return render_template('create_avatar.html')


@app.route('/run_command', methods=['GET'])
def run_command():
    # Specify the path to your Bash script
    bash_script_path = 'MakeVideo'
    # Execute the Bash script
    subprocess.run(['bash', bash_script_path])
    # Backup the result_videoxx.mp4 file
    current_datetime = str(int(time.time()))
    backup_filename = f"static/{current_datetime}.mp4"
    shutil.copyfile("results/result_voice.mp4", backup_filename)
    redirect('/final_lipsync')


@app.route('/result/<filename>')
def result(filename):
    return render_template('result.html', filename=filename)


@app.route('/convert_mp3_to_wav', methods=['GET', 'POST'])
def convert_mp3_to_wav():
    if request.method == 'POST':
        mp3_file = request.files['mp3_file']
        mp3_filename = mp3_file.filename
        mp3_path = os.path.join(app.static_folder, 'audio_mp3', mp3_filename)
        mp3_file.save(mp3_path)
        wav_filename = 'input_audio.wav'
        wav_path = os.path.join('sample_data', wav_filename)
        sound = AudioSegment.from_mp3(mp3_path)
        sound.export(wav_path, format='wav')
        return 'MP3 file converted to WAV successfully'
    else:
        return render_template('convert_mp3_to_wav.html')


@app.route('/final_lipsync')
def final_lipsync():
    VIDEO = 'result/result_voice.mp4'
    return render_template('final_lipsync.html', video=VIDEO)


@app.route('/text_mp3', methods=['GET', 'POST'])
def text_mp3():
    if request.method == 'POST':
        # Get the text from the textarea
        text = request.form['text']
        text0 = text
        # Remove whitespace from the text
        text = text.replace(" ", "")
        # Create a filename based on the first 25 characters of the text
        filename = "static/audio_mp3/" + text[:25] + ".mp3"
        textname = text[:25] + ".txt"
        # Save the text to a text file
        textname = textname.strip()
        with open("static/text/" + textname, 'w') as f:
            f.write(text0)
        filename = filename.strip()  # remove the newline character
        # Create a gTTS object and save the audio file
        tts = gTTS(text)
        filename = filename.strip()
        tts.save(filename)
        shutil.copy(filename, 'static/TEMP.mp3')
        # Play the mp3 file
        pygame.mixer.init()
        pygame.mixer.music.load(filename)
        pygame.mixer.music.play()
        # Wait for the audio to finish playing
        while pygame.mixer.music.get_busy():
            pygame.time.Clock().tick(10)
        # Stop pygame and exit the program
        pygame.mixer.quit()
        pygame.quit()
        # Return the text and filename to the template
        return render_template('text_mp3.html', text=text, filename=filename)
    else:
        # Render the home page template
        return render_template('text_mp3.html')


@app.route('/mp3_upload', methods=['POST', 'GET'])
def mp3_upload():
    if 'file' not in request.files:
        return 'No file uploaded', 400
    file = request.files['file']
    if file.filename == '':
        return 'No file selected', 400
    if file:
        audio_file = 'static/TEMP.mp3'
        file.save(audio_file)
        return render_template('player.html', audio_file=audio_file)


@app.route('/generate_video', methods=['GET', 'POST'])
def generate_video():
    if request.method == 'POST':
        # Set the input and output filenames
        eyes_filename = 'static/TEMP.png'
        input_filename = 'static/TEMP2.mp4'
        output_filename = 'static/TEMP2.mp4'
        # Set the paths for the video and audio files
        audio_file = 'static/TEMP.mp3'
        output_filenames = 'static/TEMP.mp4'
        # Extract eyes from the uploaded image and save as eyes_test.png
        image_path = "static/TEMP.jpg"
        shape_predictor_path = "/home/jack/hidden/shape_predictor_68_face_landmarks.dat"
        extract_eyes(image_path, eyes_filename, shape_predictor_path)
        # Load the image clip
        image_clip = ImageClip(image_path, duration=30)
        # Set the final clip properties
        final_clip = image_clip.set_audio(None)
        final_clip = final_clip.set_position('center')
        # Write the final video
        final_clip.write_videofile(
            output_filename, codec='libx264', fps=30, audio=False)
        # Load the input video without audio
        input_clip = VideoFileClip(input_filename, audio=False)
        # Load the eye image clip
        eyes_clip = ImageClip(eyes_filename)
        # Create multiple looping clips
        clips = []
        for i in range(8):
            loop_clip = mkloop(input_clip, eyes_clip)
            clips.append(loop_clip)
        # Concatenate all the clips
        final_clips = concatenate_videoclips(clips)
        # Write the final video
        final_clips.write_videofile(
            output_filenames, codec='libx264', fps=input_clip.fps, audio=False)
        # Load the video and audio files
        video_clip = VideoFileClip(output_filenames)
        audio_clip = AudioFileClip(audio_file)
        # Set the duration of the final video to match the audio clip's duration
        final_duration = audio_clip.duration + .5
        # Set the video clip's duration to match the final duration
        video_clip = video_clip.set_duration(final_duration)
        # Set the audio of the video clip to be the same as the loaded audio clip
        video_clip = video_clip.set_audio(audio_clip)
        # Write the final video file
        output_path = "static/final_video_blinking.mp4"
        video_clip.write_videofile(
            output_path, codec='libx264', audio_codec='aac', fps=24)
        shutil.copy(output_path, 'results/final_video_blinking.mp4')
        return render_template('generate_video.html', video_path=output_path)
    return render_template('generate_video.html')


def extract_eyes(image_path, eyes_filename, shape_predictor_path):
    # Function to extract eyes from an image using dlib
    # Load the image and shape predictor model
    image = cv2.imread(image_path)
    detector = dlib.get_frontal_face_detector()
    predictor = dlib.shape_predictor(shape_predictor_path)
    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # Detect faces in the image
    faces = detector(gray)
    # Iterate over the detected faces and extract the eye regions
    for face in faces:
        landmarks = predictor(gray, face)
        # Extract the coordinates of the left eye
        left_eye_pts = [(landmarks.part(i).x, landmarks.part(i).y)
                        for i in range(36, 42)]
        # Extract the coordinates of the right eye
        right_eye_pts = [(landmarks.part(i).x, landmarks.part(i).y)
                         for i in range(42, 48)]
        # Create a transparent image with an alpha channel
        transparent_image = np.zeros(
            (image.shape[0], image.shape[1], 4), dtype=np.uint8)
        # Define the skin color (e.g., light brown or tan) in BGR format
        # skin_color_bgr = (210, 180, 140)
        skin_color_bgr = (80, 80, 40)
        # Convert BGR to RGB
        skin_color_rgb = (skin_color_bgr[2],
                          skin_color_bgr[1], skin_color_bgr[0])
        # Draw the eye regions on the transparent image with the skin color and alpha channel
        cv2.fillPoly(transparent_image, [np.array(
            left_eye_pts)], skin_color_rgb + (200,))
        cv2.fillPoly(transparent_image, [np.array(
            right_eye_pts)], skin_color_rgb + (200,))
        blurred_image = cv2.GaussianBlur(transparent_image, (5, 5), 0)
        # Save the transparent image with only the eyes as a PNG file
        cv2.imwrite(eyes_filename, blurred_image)




def mkloop(input_clip, eyes_clip):
    # Function to create a looping clip with blinking eyes
    # Set the duration of the eye image clip
    eyes_duration = 0.1  # seconds
    # Set the position of the eye image clip
    eyes_position = 'center'
    # Set the start time of the eye image clip
    blink_start_time = randint(2, 4)
    # Create a CompositeVideoClip with the input video and the eye image clip
    final_clip = CompositeVideoClip([input_clip, eyes_clip.set_duration(eyes_duration)
                                     .set_position(eyes_position)
                                     .set_start(blink_start_time)])
    # Calculate the duration of the final clip
    final_duration = blink_start_time + eyes_duration + \
        randint(2, 4)  # 5 to 8 seconds after the blink
    # Set the duration of the final clip
    final_clip = final_clip.set_duration(final_duration)
    return final_clip


def apply_text(mp4_path, text, x, y):
    video = moviepy.editor.VideoFileClip(mp4_path)
    font = "/home/jack/fonts/OpenSansBold.ttf"
    text_clip = moviepy.editor.TextClip(
        text, font=font, fontsize=24, color="white")
    try:
        x = int(x)
        y = int(y)
    except ValueError:
        raise ValueError(
            "Invalid position values. Please provide integer values for x and y.")
    if not (0 <= x <= video.w):
        raise ValueError(
            "Invalid x position. Must be within the width of the video.")

    if not (0 <= y <= video.h):
        raise ValueError(
            "Invalid y position. Must be within the height of the video.")
    text_clip = text_clip.set_position((x, y))
    # Check if duration is None and set a default value if necessary
    video_duration = video.duration if video.duration is not None else 0
    text_clip_duration = text_clip.duration if text_clip.duration is not None else 0
    # Set the duration of the video and text clips
    duration = max(video_duration, text_clip_duration)
    video = video.set_duration(duration)
    text_clip = text_clip.set_duration(duration)
    # Create the composite video by overlaying the text clip onto the video clip
    new_video = moviepy.editor.CompositeVideoClip([video, text_clip])
    # Save the new video with the applied text
    new_mp4_path = 'static/TTMP.mp4'
    new_video.write_videofile(
        new_mp4_path, codec='libx264', audio_codec='aac', remove_temp=False)
    return new_mp4_path


@app.route("/apply_text_to_video", methods=["POST", "GET"])
def apply_text_to_video():
    if request.method == "POST":
        file = request.files["mp4_file"]
        if file.filename == '':
            return redirect(request.url)
        file.save('static/TTMP.mp4')
        mp4_path = 'static/TTMP.mp4'
        text = request.form["text"]
        x = request.form["x"]
        y = request.form["y"]
        new_mp4_path = apply_text(mp4_path, text, x, y)
        return render_template("apply_text_to_video.html", new_mp4_path=new_mp4_path)
    else:
        return render_template("apply_text_to_video.html")


def get_subDirectories(base_path):
    # Get a list of existing subdirectories in the video resources directory
    existing_subdirectories = [subdir for subdir in os.listdir(base_path) if os.path.isdir(os.path.join(base_path, subdir))]
    return existing_subdirectories


@app.route('/uploads', methods=['GET', 'POST'])
def upload_files():
    video_resources_dir = "static/current_project"
    if request.method == 'POST':
        # Get the selected subdirectory from the form
        selected_subdirectory = request.form.get('subdirectory')
        # Check if the selected subdirectory exists
        if selected_subdirectory in existing_subdirectories:
            # Handle the uploaded file
            file = request.files['file']
            if file:
                # Save the file to the selected subdirectory
                file.save(os.path.join(video_resources_dir,
                          selected_subdirectory, file.filename))
                # Get the URL for the uploaded image
                image_path = url_for('static', filename=os.path.join(
                    'current_project', selected_subdirectory, file.filename))
                return render_template('upload_files.html', image_path=image_path)
            else:
                return 'No file selected.'
        else:
            return 'Invalid subdirectory selected.'
    # Render the upload form with the list of existing subdirectories
    return render_template('upload_files.html', subdirectories=existing_subdirectories)


@app.route('/get_files', methods=['POST'])
def get_files():
    subdirectory = request.form.get('subdirectory')
    file_options = []
    if subdirectory and subdirectory in existing_subdirectories:
        subdirectory_path = os.path.join(
            "static/current_project", subdirectory)
        files = os.listdir(subdirectory_path)
        file_options = [
            f'<option value="{file}">{file}</option>'
            for file in files
            if os.path.isfile(os.path.join(subdirectory_path, file))        ]
    return ''.join(file_options)


@app.route('/image_list')
def image_list():
    image_directory = 'static/current_project/Narrators'
    image_list = [
        filename
        for filename in os.listdir(image_directory)
        if filename.endswith('.jpg') or filename.endswith('.png')]
    return render_template('image_list.html', image_list=image_list)


@app.route('/upload', methods=['POST', 'GET'])
def upload():
    filename = request.form['filename']
    if filename:
        src_path = 'static/current_project/Narrators/' + filename
        dest_path = 'static/TEMP.jpg'
        shutil.copyfile(src_path, dest_path)
        return redirect('/')
    else:
        return 'No file selected.'
           
   ---------
# test_py.py is a blueprint that contains the routes for the test_py application.
import os
from flask import Flask, render_template, request, Blueprint
import datetime
import glob
import shutil
test_py_bp = Blueprint('test_py', __name__)

# Configure logging
def logit(logdata):
    timestr = filename = datetime.datetime.now().strftime('%A_%b-%d-%Y')
    with open("testlog.txt", "a") as log_file:
        log_file.write(f"{timestr}: {logdata} <br/>")
    print("mylog.txt entry:", logdata)

logit("TEST: 12345")

@test_py_bp.route('/readlog')
def readlog():
    logdata = []
    with open("testlog.txt", "r") as log_file:
        logdata = log_file.readlines()
    return render_template('read_log.html', log_content=logdata)

# Read functions from app.py file into memory
def read_functions():
    with open('app_txt.py', 'r') as file:
        code = file.read()
        functions = code.split('\n\n')  # Assume functions are separated by empty lines
    return functions

functions = read_functions()

@test_py_bp.route('/index_y')
def index_y():
    return render_template('index_y.html')

@test_py_bp.route('/save', methods=['POST'])
def save():
    code = request.form['code']
    logit(f"Received code: {code}")
    suggestions = generate_suggestions(code)
    logit(f"Generated suggestions: {suggestions}")
    return {'suggestions': suggestions}

def generate_suggestions(code):
    logit("Generating suggestions...")
    # Retrieve the last line from the code
    lines = code.split('\n')
    last_line = lines[-1]

    # Split the last line into words and get the last four words
    words = last_line.split()
    last_four_words = ' '.join(words[-4:])
    logit(f"Last four words: {last_four_words}")

    # Search for a matching snippet based on the last four words
    matching_snippets = []
    for i, snippet in enumerate(functions, start=1):
        if last_four_words in snippet:
            # Format the snippet with line numbers and preserve whitespace
            formatted_snippet = f"<pre>{i}: {snippet.strip()}</pre>"
            matching_snippets.append(formatted_snippet)

    logit(f"Matching snippets: {matching_snippets}")

    return matching_snippets
@test_py_bp.route('/save_code', methods=['POST'])
def save_code():
    # Extract the code from the request body
    code = request.data.decode('utf-8')

    if code:
        # Append the code to the new_app.py file
        with open('new_app.py', 'a') as file:
            file.write(code + '\n')
        
        return 'Code saved successfully', 200
    else:
        return 'No code provided in the request', 400

ChatGPT
It seems like you've provided two separate Flask applications in one script. Let's organize the code and separate them into two different files to make it easier to manage.

First, let's divide the code into two Flask applications: one for `app.py` and another for the video-related functionality. We'll create two files: `app.py` for the main Flask application and `video_app.py` for the video-related functions. Then, we'll make sure to import the necessary functions and variables into each file.

Here's how we can structure `app.py`:

```python
# app.py

from flask import Flask, render_template, request, redirect, url_for, send_from_directory, Response, flash, session
from view_gallery import view_gallery_bp
from test_html_bp import test_html_bp_bp
from test_py import test_py_bp
from video_app import app as video_app

app = Flask(__name__)

app.register_blueprint(view_gallery_bp)
app.register_blueprint(test_html_bp_bp)
app.register_blueprint(test_py_bp)
app.register_blueprint(video_app)

# Define routes and functions for the main Flask application
# ...

if __name__ == "__main__":
    app.run(port=5100, debug=True)
```

And here's the structure for `video_app.py`:

```python
# video_app.py

from flask import Blueprint, render_template, request, redirect, url_for, send_from_directory, Response, flash, session
from moviepy.editor import *

video_app = Blueprint('video_app', __name__)

# Define routes and functions for the video-related Flask application
# ...

def findvideos():
    # Function definition for finding videos
    pass

# Define other video-related functions and routes
# ...

```

With this structure, we've separated the main Flask application logic in `app.py` from the video-related functions in `video_app.py`. This separation should make the code easier to manage and maintain. Let me know if you need further assistance!
user
# test_py.py is a blueprint that contains the routes for the test_py application.
import os
from flask import Flask, render_template, request, Blueprint
import datetime
import glob
import shutil
test_py_bp = Blueprint('test_py', __name__)

# Configure logging
def logit(logdata):
    timestr = filename = datetime.datetime.now().strftime('%A_%b-%d-%Y')
    with open("testlog.txt", "a") as log_file:
        log_file.write(f"{timestr}: {logdata} <br/>")
    print("mylog.txt entry:", logdata)

logit("TEST: 12345")

@test_py_bp.route('/readlog')
def readlog():
    logdata = []
    with open("testlog.txt", "r") as log_file:
        logdata = log_file.readlines()
    return render_template('read_log.html', log_content=logdata)

# Read functions from app.py file into memory
def read_functions():
    with open('app_txt.py', 'r') as file:
        code = file.read()
        functions = code.split('\n\n')  # Assume functions are separated by empty lines
    return functions

functions = read_functions()

@test_py_bp.route('/index_y')
def index_y():
    return render_template('index_y.html')

@test_py_bp.route('/save', methods=['POST'])
def save():
    code = request.form['code']
    logit(f"Received code: {code}")
    suggestions = generate_suggestions(code)
    logit(f"Generated suggestions: {suggestions}")
    return {'suggestions': suggestions}

def generate_suggestions(code):
    logit("Generating suggestions...")
    # Retrieve the last line from the code
    lines = code.split('\n')
    last_line = lines[-1]

    # Split the last line into words and get the last four words
    words = last_line.split()
    last_four_words = ' '.join(words[-4:])
    logit(f"Last four words: {last_four_words}")

    # Search for a matching snippet based on the last four words
    matching_snippets = []
    for i, snippet in enumerate(functions, start=1):
        if last_four_words in snippet:
            # Format the snippet with line numbers and preserve whitespace
            formatted_snippet = f"<pre>{i}: {snippet.strip()}</pre>"
            matching_snippets.append(formatted_snippet)

    logit(f"Matching snippets: {matching_snippets}")

    return matching_snippets
@test_py_bp.route('/save_code', methods=['POST'])
def save_code():
    # Extract the code from the request body
    code = request.data.decode('utf-8')

    if code:
        # Append the code to the new_app.py file
        with open('new_app.py', 'a') as file:
            file.write(code + '\n')
        
        return 'Code saved successfully', 200
    else:
        return 'No code provided in the request', 400
this will not import the rest do
ChatGPT
It seems like you want to include the remaining part of your Flask application script. Let's continue from where we left off:

```python
import os
from flask import Flask, render_template, request, Blueprint
import datetime

# Creating a Blueprint for the test_py application
test_py_bp = Blueprint('test_py', __name__)

# Configure logging
def logit(logdata):
    timestr = datetime.datetime.now().strftime('%A_%b-%d-%Y')
    with open("testlog.txt", "a") as log_file:
        log_file.write(f"{timestr}: {logdata} <br/>")
    print("mylog.txt entry:", logdata)

logit("TEST: 12345")

# Route for reading the log file
@test_py_bp.route('/readlog')
def readlog():
    logdata = []
    with open("testlog.txt", "r") as log_file:
        logdata = log_file.readlines()
    return render_template('read_log.html', log_content=logdata)

# Function to read functions from app.py file into memory
def read_functions():
    with open('app_txt.py', 'r') as file:
        code = file.read()
        functions = code.split('\n\n')  # Assume functions are separated by empty lines
    return functions

functions = read_functions()

# Route for rendering the index_y page
@test_py_bp.route('/index_y')
def index_y():
    return render_template('index_y.html')

# Route for receiving code input and generating suggestions
@test_py_bp.route('/save', methods=['POST'])
def save():
    code = request.form['code']
    logit(f"Received code: {code}")
    suggestions = generate_suggestions(code)
    logit(f"Generated suggestions: {suggestions}")
    return {'suggestions': suggestions}

# Function to generate code suggestions based on the input code
def generate_suggestions(code):
    logit("Generating suggestions...")
    # Retrieve the last line from the code
    lines = code.split('\n')
    last_line = lines[-1]

    # Split the last line into words and get the last four words
    words = last_line.split()
    last_four_words = ' '.join(words[-4:])
    logit(f"Last four words: {last_four_words}")

    # Search for a matching snippet based on the last four words
    matching_snippets = []
    for i, snippet in enumerate(functions, start=1):
        if last_four_words in snippet:
            # Format the snippet with line numbers and preserve whitespace
            formatted_snippet = f"<pre>{i}: {snippet.strip()}</pre>"
            matching_snippets.append(formatted_snippet)

    logit(f"Matching snippets: {matching_snippets}")

    return matching_snippets

# Route for saving code to new_app.py file
@test_py_bp.route('/save_code', methods=['POST'])
def save_code():
    # Extract the code from the request body
    code = request.data.decode('utf-8')

    if code:
        # Append the code to the new_app.py file
        with open('new_app.py', 'a') as file:
            file.write(code + '\n')
        
        return 'Code saved successfully', 200
    else:
        return 'No code provided in the request', 400
```

This should include the remaining part of your Flask application script. Let me know if you need further assistance or if you have any questions!
user
"/home/jack/Desktop/PROMPTS/app.py", line 16, in <module>
    from test_py import test_py_bp

ChatGPT
It seems like there's an error indicating that the script is unable to import the `test_py_bp` Blueprint from the `test_py` module. This error typically occurs when the Python interpreter cannot find the module you're trying to import.

To resolve this issue, make sure that:

1. The `test_py.py` file exists in the same directory as your main script (`app.py`) or in a directory that is included in the Python path.
2. The `test_py.py` file contains the `test_py_bp` Blueprint definition.

If both conditions are met and you're still encountering the error, try the following steps:

1. Check for any typos or errors in the filename (`test_py.py`) or the Blueprint definition (`test_py_bp`).
2. Ensure that there are no circular imports. Circular imports can occur when two or more modules import each other directly or indirectly.
3. Verify that the directory structure of your project is correct and that there are no issues with how modules are organized.

Once you've verified these points, try running your script again. If the issue persists, please provide more details or the relevant portions of your code for further assistance.
user
import os
from flask import Flask, render_template, request, Blueprint
import datetime

# Creating a Blueprint for the test_py application
test_py_bp = Blueprint('test_py', __name__)

# Configure logging
def logit(logdata):
    timestr = datetime.datetime.now().strftime('%A_%b-%d-%Y')
    with open("testlog.txt", "a") as log_file:
        log_file.write(f"{timestr}: {logdata} <br/>")
    print("mylog.txt entry:", logdata)

logit("TEST: 12345")

# Route for reading the log file
@test_py_bp.route('/readlog')
def readlog():
    logdata = []
    with open("testlog.txt", "r") as log_file:
        logdata = log_file.readlines()
    return render_template('read_log.html', log_content=logdata)

# Function to read functions from app.py file into memory
def read_functions():
    with open('app_txt.py', 'r') as file:
        code = file.read()
        functions = code.split('\n\n')  # Assume functions are separated by empty lines
    return functions

functions = read_functions()

# Route for rendering the index_y page
@test_py_bp.route('/index_y')
def index_y():
    return render_template('index_y.html')

# Route for receiving code input and generating suggestions
@test_py_bp.route('/save', methods=['POST'])
def save():
    code = request.form['code']
    logit(f"Received code: {code}")
    suggestions = generate_suggestions(code)
    logit(f"Generated suggestions: {suggestions}")
    return {'suggestions': suggestions}

# Function to generate code suggestions based on the input code
def generate_suggestions(code):
    logit("Generating suggestions...")
    # Retrieve the last line from the code
    lines = code.split('\n')
    last_line = lines[-1]

    # Split the last line into words and get the last four words
    words = last_line.split()
    last_four_words = ' '.join(words[-4:])
    logit(f"Last four words: {last_four_words}")

    # Search for a matching snippet based on the last four words
    matching_snippets = []
    for i, snippet in enumerate(functions, start=1):
        if last_four_words in snippet:
            # Format the snippet with line numbers and preserve whitespace
            formatted_snippet = f"<pre>{i}: {snippet.strip()}</pre>"
            matching_snippets.append(formatted_snippet)

    logit(f"Matching snippets: {matching_snippets}")

    return matching_snippets

# Route for saving code to new_app.py file
@test_py_bp.route('/save_code', methods=['POST'])
def save_code():
    # Extract the code from the request body
    code = request.data.decode('utf-8')

    if code:
        # Append the code to the new_app.py file
        with open('new_app.py', 'a') as file:
            file.write(code + '\n')
        
        return 'Code saved successfully', 200
    else:
        return 'No code provided in the request', 400

ChatGPT
Your code looks well-structured and organized. It defines a Flask Blueprint named `test_py_bp`, which contains routes for reading logs, rendering HTML pages, receiving code input, generating suggestions based on the input code, and saving code to a file.

Here's a brief summary of what each part of your code does:

1. **Blueprint Definition**: Defines a Flask Blueprint named `test_py_bp` to organize routes and views.

2. **Logging**: Implements a logging function `logit()` to log data to a file (`testlog.txt`) with a timestamp.

3. **Reading Log**: Defines a route (`/readlog`) to read the log file and render its content in an HTML template.

4. **Reading Functions**: Implements a function `read_functions()` to read functions from a Python file (`app_txt.py`) into memory.

5. **Rendering HTML Page**: Defines a route (`/index_y`) to render an HTML page (`index_y.html`).

6. **Receiving Code Input and Generating Suggestions**: Defines a route (`/save`) to receive code input via a POST request, generate suggestions based on the input code, and return the suggestions as JSON data.

7. **Generating Suggestions**: Implements a function `generate_suggestions()` to generate code suggestions based on the input code.

8. **Saving Code**: Defines a route (`/save_code`) to save code received via a POST request to a file (`new_app.py`).

Your code structure is clear, and you've used Flask Blueprints effectively to organize your routes. Let me know if you need further assistance or if there's anything specific you'd like to modify or add!
user
why won't it import ?
ChatGPT
If you're encountering an issue where your Flask application is unable to import the `test_py_bp` Blueprint from the file where it's defined (`test_py.py`), there are a few potential reasons this could be happening:

1. **File Path or Module Name Mismatch**: Ensure that the file path and module name are correctly specified when importing the Blueprint. If the file containing the Blueprint is named `test_py.py` and is located in the same directory as your main Flask application file, the import statement should be `from test_py import test_py_bp`. Double-check that the file path and module name match exactly.

2. **Circular Import**: Check for circular imports, where `test_py.py` or its dependencies import from the main Flask application file or each other in a way that creates a loop. Circular imports can lead to import errors. Make sure there are no circular dependencies between your files.

3. **Missing `__init__.py` File**: If the directory containing `test_py.py` is not recognized as a package, ensure that it contains an `__init__.py` file. This file can be empty but is necessary to indicate to Python that the directory is a package and to enable imports from it.

4. **File Permission Issues**: Check the file permissions of `test_py.py` to ensure that it's readable and executable by the user running the Flask application. Permission issues can prevent Python from importing the module correctly.

5. **Flask App Initialization**: Ensure that you're properly registering the Blueprint with your Flask application. In your main Flask application file (e.g., `app.py`), you should have a line like `app.register_blueprint(test_py_bp)`, where `app` is your Flask application instance.

By carefully reviewing these potential issues, you should be able to identify why the `test_py_bp` Blueprint is not importing correctly into your Flask application. If you continue to experience issues, providing more details or error messages would be helpful for further diagnosis.
user
#!/home/jack/miniconda3/envs/cloned_base/bin/python
# app.py
from flask import Flask, render_template, request, redirect, url_for
from flask import send_from_directory, Response, flash, request, session, jsonify, abort
import random
import glob
from PIL import Image
import os 
import shutil
import sqlite3
import base64
import datetime
import time
from view_gallery import view_gallery_bp
from test_html_bp import test_html_bp_bp
from test_py import test_py_bp
app = Flask(__name__)
# create  logging funtction
app.register_blueprint(view_gallery_bp)
app.register_blueprint(test_html_bp_bp)
app.register_blueprint(test_py_bp)

def logit(logdata):
    timestr = filename = datetime.datetime.now().strftime('%A_%b-%d-%Y')
    Input=open("mylog.txt","a")
    Input.write(f"{timestr}:{logdata}")
    Input.close()
    return print("mylog.txt entry: ",logdata)

def logit2(logdata):
    Input=open("mylog2.txt","a")
    Input.write(logdata+"\n")
    Input.close()
    return print("mylog2.txt entry: ",logdata)

@app.route('/readlog')
def readlog():
    logdata=[]
    logdatas=open("mylog.txt","r").read()
    logdata= logdatas.split("\n")
    for log in logdata:
        log=log.replace("\n","")
        logdata.append(log)
        return render_template('read_log.html', log_content=logdata)

@app.route('/', methods=['GET', 'POST'])
def index():
    text_files = find_txt()
    logit(f"text_files: {text_files}")
    return render_template('index.html', text_files=text_files)

def find_txt():
    filenames =sorted(glob.glob('static/text/*.txt'))
    return filenames
 
def create_database(database_name):
    conn = sqlite3.connect(database_name)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS prompts
                 (id INTEGER PRIMARY KEY,
                 CURRENT_date, TEXT,   
                 url_name TEXT,    
                 url_link BLOB,
                 prompt TEXT,
                 image_name text,
                 image_data BLOB)''')
    conn.commit()
    conn.close()

# CURRENT_date,url_name,url_link,prompt,image_name,image_data)''')
def insertData(CURRENT_date,database_name,filename,content,contents):
    conn = sqlite3.connect(database_name)
    c = conn.cursor()
    #c.execute("INSERT INTO dialogue (user_ChatGPT_PAIR) VALUES (?)", (dialogue_data,))
    c.execute("INSERT INTO prompt (CURRENT_date,url_name,url_linkdecode('utf-8',prompt,image_name,image_data.decode('utf-8') VALUES (?,?,?,?,?,?)", (CURRENT_date,url_name,url_link,prompt,image_name,image_data),)
    conn.commit()
    conn.close()
    
@app.route('/read_image', methods=['POST','GET'])
def read_image(image_path):    
    contents=open(image_path,'rb').read()
    image_data=contents.decode('utf-8')
    filename=filename.replace('static/uploads/','')
    insertData(database_name,filename,content,contents)
    return

@app.route('/help')
def get_help():
    content =open('static/text/help.txt','rb').read()
    help_content=content.decode('utf-8')
    return render_template('help.html',help_content=help_content)#search_multiple_term flask,app,route,port >resource         

@app.route('/edit_text_page')
def edit_text_page():
    selected_filename = request.args.get('filename')
    original_content = load_original_text_file(selected_filename)
    text_files = find_txt()
    return render_template('edit_text_page.html', selected_filename=selected_filename, original_content=original_content,text_files=text_files)

#/edit_text_save
@app.route('/edit_text_save', methods=['POST','GET'])
def edit_text_save():
    if request.method == 'POST':
        content = request.form['edited_content']
        filename = request.form['filename']
        open('static/text/'+filename,'w').write(content)
        return render_template('edit_file.html', filenames=filenames, selected_filename=filename)

@app.route('/edit_file', methods=['GET', 'POST'])
def edit_file():
    if request.method == 'POST':
        filename = request.form.get('filename')
        text = request.form.get('text')

        # Save the changes to the file
        with open(f'static/text/{filename}', 'w') as file:
            file.write(text)
    
    text_files_dir = 'static/text/'
    text_files = []

    # Retrieve list of text files in the directory
    for filename in os.listdir(text_files_dir):
        if filename.endswith('.txt'):
            text_files.append(filename)
            logit(filename)

    return render_template('edit_file.html', filenames=text_files)

static_dir = 'static'
text_dir = os.path.join(static_dir, 'text')
original_text_dir = os.path.join(text_dir, 'original')
os.makedirs(original_text_dir, exist_ok=True)

def load_original_text_file(filename):
    original_file_path = filename
    with open(original_file_path, 'r') as file:
        return file.read()

def save_original_text_file(filename, content):
    now = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    new_filename = f"{filename}_{now}.txt"
    new_file_path = os.path.join(original_text_dir, new_filename)
    with open(new_file_path, 'w') as file:
        file.write(content)

@app.route('/edit_text')
def edit_text():
    filenames =sorted(glob.glob('static/text/*.txt'))
    return render_template('edit_text.html', filenames=filenames)

@app.route('/find_text')
def find_text():
    #create a list of sorted text files
    filenames = sorted(glob.glob('static/text/*.txt'))
    logit(filenames)
    return render_template('edit_text.html', filenames=filenames)

def split_text(file_path, parts=5):
    # Read the content of the text file
    with open(file_path, 'rb') as file:
        text = file.read().decode('utf-8')  # Assuming text encoding is UTF-8
    
    # Calculate the length of each part
    part_length = len(text) // parts
    
    # Split the text into equal parts
    parts_list = [text[i:i+part_length] for i in range(0, len(text), part_length)]
    
    return parts_list

@app.route('/split-text', methods=['GET', 'POST'])
def split_text_route():
    if request.method == 'GET':
        # Get the directory path of the text files
        directory = os.path.join(app.static_folder, 'text')
        
        # Get the list of available text files
        text_files = [f for f in os.listdir(directory) if f.endswith('.txt')]
        
        return render_template('file_selection.html', text_files=text_files)
    elif request.method == 'POST':
        # Get the selected file name from the form
        file_name = request.form.get('file_name')
        
        if not file_name:
            abort(400, 'File name not provided.')
        
        # Get the directory path of the text files
        directory = os.path.join(app.static_folder, 'text')
        
        # Check if the file exists
        file_path = os.path.join(directory, file_name)
        if not os.path.exists(file_path):
            abort(404, 'File not found.')
        
        # Split the specified text file into five equal parts and save them
        parts = split_text(file_path)
        base_name, ext = os.path.splitext(file_name)
        for i, part in enumerate(parts):
            part_file_path = os.path.join(directory, f'{base_name}_part_{i+1}{ext}')
            with open(part_file_path, 'wb') as part_file:
                part_file.write(part.encode('utf-8'))
        
        return f'Text file "{file_name}" split into 5 equal parts and saved with original format.'

@app.route('/get_gallery')
def get_gallery():
    image_dir = 'static/images/uploads'
    image_names = os.listdir(image_dir)
    return render_template('get_gallery.html', image_names=image_names)

if __name__=="__main__":
    database_name = 'PROMPTS.db'
    create_database(database_name)
    app.run(port=5100,debug=True)
         
 
 #!/home/jack/Desktop/FlaskAppArchitect_Flask_App_Creator/env/bin/python
from moviepy.editor import *
from flask import Flask, render_template, request, redirect, url_for, send_from_directory, Response, flash, request, session, jsonify
from flask import send_file, g
import os
import pygame
from gtts import gTTS
import cv2
import dlib
import numpy as np
from random import randint
from moviepy.editor import VideoFileClip, ImageClip, CompositeVideoClip
from moviepy.editor import concatenate_videoclips, AudioFileClip
import moviepy.editor as mp
import moviepy.editor
import subprocess
from pathlib import Path as change_ext
import re
from io import BytesIO
import io
import matplotlib.pyplot as plt
import sqlite3
import random
import glob
import signal
import base64
import tempfile
import datetime
import imageio
import time
from werkzeug.utils import secure_filename
import shutil
from search import search
from time import sleep
from pydub import AudioSegment
from PIL import Image, ImageDraw, ImageFont
import uuid
from clean_images import clean_images
from flask_cors import CORS
import json
import logging
from logging.handlers import RotatingFileHandler
from view_gallery import view_gallery_bp
from create_comic import create_comic_bp
from view_archive_videos import view_archive_videos_bp
from api_search.api_search import api_search_bp
from mp3_sound.mp3_sound import mp3_sound_bp
from zoomin import zoomin_bp
import sys
from selenium import webdriver
from icecream import ic 
# Initialize Flask app
app = Flask(__name__)
# Set the template folder for the main app
app.template_folder = 'templates'
# Register your Blueprint and specify its template folder
api_search_template_folder = 'api_search/templates'
app.register_blueprint(api_search_bp, url_prefix='/api_search', template_folder=api_search_template_folder)
# Register the Blueprint from view_gallery.py with the main app
app.register_blueprint(view_gallery_bp)
app.register_blueprint(create_comic_bp)
app.register_blueprint(zoomin_bp)
app.register_blueprint(view_archive_videos_bp)
app.register_blueprint(mp3_sound_bp)
app.static_folder = 'static'
# allow CORS
CORS(app)
app.secret_key = os.urandom(24)
# Create a logger object
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Create a formatter for the log messages
formatter = logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]')

# Create a file handler to write log messages to a file
file_handler = RotatingFileHandler(
    'Logs/app.log', maxBytes=10000, backupCount=1)
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(formatter)

# Add the file handler to the logger
logger.addHandler(file_handler)

SDIR = "static/"
# Define the file path to store the script content
script_file = os.path.join(os.getcwd(), SDIR, 'scripts', 'scripts.js')

# Route to the main app's template

def findvideos():
    videoroot_directory = "static"
    MP4 = []
    for dirpath, dirnames, filenames in os.walk(videoroot_directory):
        for filename in filenames:
            if filename.endswith(".mp4") and "Final" in filename:
                MP4.append(os.path.join(dirpath, filename))
    if MP4:
        last_video = session.get("last_video")
        new_video = random.choice([video for video in MP4 if video != last_video])
        session["last_video"] = new_video
        return new_video
    else:
        return None


@app.route('/')
def index():
    video = findvideos()
    return render_template('index.html', video=video)


@app.route('/hello_world')
def hello_world():
    TExt = "TEXT TEST 6789"
    logger.debug('This is a debug message: %s', TExt)

    TEXT = "TEXT TEST abcd"
    logger.debug('This is a debug message: %s', TEXT)

    return "Hello, World!"


directory_path = "static/current_project"
if not os.path.exists(directory_path):
    os.makedirs(directory_path)
app.config['UPLOAD_FOLDER'] = 'static/images/uploads'
app.config['RESULTS_FOLDER'] = 'static/videos/results'
app.config['THUMBNAILS_FOLDER'] = 'static/images/thumbnails'
app.config['CHECKPOINT_PATH'] = 'checkpoints/wav2lip_gan.pth'
app.config['AUDIO_PATH'] = 'sample_data/input_audio.wav'
app.config['video_PATH'] = 'sample_data/input_videio.mp4'
app.config['DATABASE'] = 'code.db'  # SQLite database file
app.secret_key = "your_secret_key"  # Add a secret key for session management


@app.route('/favicons.ico')
def favicons():
    return send_from_directory(os.path.join(app.root_path, 'static'), 'favicon.ico', mimetype='image/vnd.microsoft.icon')


@app.route('/favicon.ico')
def favicon():
    # Set the size of the favicon
    size = (16, 16)
    # Create a new image with a transparent background
    favicon = Image.new('RGBA', size, (0, 0, 0, 0))
    # Create a drawing object
    draw = ImageDraw.Draw(favicon)
    # Draw a yellow square
    square_color = (255, 0, 255)
    draw.rectangle([(0, 0), size], fill=square_color)
    # Draw a red circle
    circle_center = (size[0] // 2, size[1] // 2)
    circle_radius = size[0] // 3
    logger.info(f'circle_center, circle_radius:,{circle_center} {circle_radius}')
    circle_color = (255, 255, 0)
    draw.ellipse(
        [(circle_center[0] - circle_radius, circle_center[1] - circle_radius),
         (circle_center[0] + circle_radius, circle_center[1] + circle_radius)],
        fill=circle_color
    )
    # Save the image to a memory buffer
    image_buffer = io.BytesIO()
    favicon.save(image_buffer, format='ICO')
    image_buffer.seek(0)
    return Response(image_buffer.getvalue(), content_type='image/x-icon')


# use the search function as a route
app.add_url_rule('/search', 'search', search)


def zip_lists(list1, list2):
    return zip(list1, list2)
app.jinja_env.filters['zip'] = zip_lists

def create_directory_path(directory):
    # Create the directory if it doesn't exist
    os.makedirs(directory_path, exist_ok=True)


def ClipList():
    cliplist = glob.glob("clip*.mp3")
    print(cliplist)
    return cliplist
for clip in ClipList():
    os.remove(clip)   


@app.route("/index2")
def index2():
    image_dir = 'static/images/MISC_MIX'
    image_files = [f for f in os.listdir(image_dir) if f.endswith('.jpg')]
    random_image_file = random.choice(image_files)
    return render_template('index2.html', random_image_file="images/MISC_MIX/" + random_image_file)


def generate_output():
    # Specify the path to your Bash script
    bash_script_path = '/home/jack/Desktop/StoryMaker/MakeVideo'
    # Execute the Bash script
    subprocess.run(['bash', bash_script_path])
    # Backup the result_videoxx.mp4 file
    current_datetime = str(int(time.time()))
    backup_filename = f"static/{current_datetime}.mp4"
    original_filename = "results/result_voice.mp4"
    shutil.copyfile(original_filename, backup_filename)
    return redirect('/final_lipsync')


@app.route('/create_avatar', methods=['GET', 'POST'])
def create_avatar():
    if request.method == 'POST':
        # check_point = os.path.join(app.config['CHECKPOINT_PATH'], 'checkpoints/wav2lip_gan.pth')
        return Response(generate_output(), mimetype='text/plain')
    else:
        return render_template('create_avatar.html')


@app.route('/run_command', methods=['GET'])
def run_command():
    # Specify the path to your Bash script
    bash_script_path = 'MakeVideo'
    # Execute the Bash script
    subprocess.run(['bash', bash_script_path])
    # Backup the result_videoxx.mp4 file
    current_datetime = str(int(time.time()))
    backup_filename = f"static/{current_datetime}.mp4"
    shutil.copyfile("results/result_voice.mp4", backup_filename)
    redirect('/final_lipsync')


@app.route('/result/<filename>')
def result(filename):
    return render_template('result.html', filename=filename)


@app.route('/convert_mp3_to_wav', methods=['GET', 'POST'])
def convert_mp3_to_wav():
    if request.method == 'POST':
        mp3_file = request.files['mp3_file']
        mp3_filename = mp3_file.filename
        mp3_path = os.path.join(app.static_folder, 'audio_mp3', mp3_filename)
        mp3_file.save(mp3_path)
        wav_filename = 'input_audio.wav'
        wav_path = os.path.join('sample_data', wav_filename)
        sound = AudioSegment.from_mp3(mp3_path)
        sound.export(wav_path, format='wav')
        return 'MP3 file converted to WAV successfully'
    else:
        return render_template('convert_mp3_to_wav.html')


@app.route('/final_lipsync')
def final_lipsync():
    VIDEO = 'result/result_voice.mp4'
    return render_template('final_lipsync.html', video=VIDEO)


@app.route('/text_mp3', methods=['GET', 'POST'])
def text_mp3():
    if request.method == 'POST':
        # Get the text from the textarea
        text = request.form['text']
        text0 = text
        # Remove whitespace from the text
        text = text.replace(" ", "")
        # Create a filename based on the first 25 characters of the text
        filename = "static/audio_mp3/" + text[:25] + ".mp3"
        textname = text[:25] + ".txt"
        # Save the text to a text file
        textname = textname.strip()
        with open("static/text/" + textname, 'w') as f:
            f.write(text0)
        filename = filename.strip()  # remove the newline character
        # Create a gTTS object and save the audio file
        tts = gTTS(text)
        filename = filename.strip()
        tts.save(filename)
        shutil.copy(filename, 'static/TEMP.mp3')
        # Play the mp3 file
        pygame.mixer.init()
        pygame.mixer.music.load(filename)
        pygame.mixer.music.play()
        # Wait for the audio to finish playing
        while pygame.mixer.music.get_busy():
            pygame.time.Clock().tick(10)
        # Stop pygame and exit the program
        pygame.mixer.quit()
        pygame.quit()
        # Return the text and filename to the template
        return render_template('text_mp3.html', text=text, filename=filename)
    else:
        # Render the home page template
        return render_template('text_mp3.html')


@app.route('/mp3_upload', methods=['POST', 'GET'])
def mp3_upload():
    if 'file' not in request.files:
        return 'No file uploaded', 400
    file = request.files['file']
    if file.filename == '':
        return 'No file selected', 400
    if file:
        audio_file = 'static/TEMP.mp3'
        file.save(audio_file)
        return render_template('player.html', audio_file=audio_file)


@app.route('/generate_video', methods=['GET', 'POST'])
def generate_video():
    if request.method == 'POST':
        # Set the input and output filenames
        eyes_filename = 'static/TEMP.png'
        input_filename = 'static/TEMP2.mp4'
        output_filename = 'static/TEMP2.mp4'
        # Set the paths for the video and audio files
        audio_file = 'static/TEMP.mp3'
        output_filenames = 'static/TEMP.mp4'
        # Extract eyes from the uploaded image and save as eyes_test.png
        image_path = "static/TEMP.jpg"
        shape_predictor_path = "/home/jack/hidden/shape_predictor_68_face_landmarks.dat"
        extract_eyes(image_path, eyes_filename, shape_predictor_path)
        # Load the image clip
        image_clip = ImageClip(image_path, duration=30)
        # Set the final clip properties
        final_clip = image_clip.set_audio(None)
        final_clip = final_clip.set_position('center')
        # Write the final video
        final_clip.write_videofile(
            output_filename, codec='libx264', fps=30, audio=False)
        # Load the input video without audio
        input_clip = VideoFileClip(input_filename, audio=False)
        # Load the eye image clip
        eyes_clip = ImageClip(eyes_filename)
        # Create multiple looping clips
        clips = []
        for i in range(8):
            loop_clip = mkloop(input_clip, eyes_clip)
            clips.append(loop_clip)
        # Concatenate all the clips
        final_clips = concatenate_videoclips(clips)
        # Write the final video
        final_clips.write_videofile(
            output_filenames, codec='libx264', fps=input_clip.fps, audio=False)
        # Load the video and audio files
        video_clip = VideoFileClip(output_filenames)
        audio_clip = AudioFileClip(audio_file)
        # Set the duration of the final video to match the audio clip's duration
        final_duration = audio_clip.duration + .5
        # Set the video clip's duration to match the final duration
        video_clip = video_clip.set_duration(final_duration)
        # Set the audio of the video clip to be the same as the loaded audio clip
        video_clip = video_clip.set_audio(audio_clip)
        # Write the final video file
        output_path = "static/final_video_blinking.mp4"
        video_clip.write_videofile(
            output_path, codec='libx264', audio_codec='aac', fps=24)
        shutil.copy(output_path, 'results/final_video_blinking.mp4')
        return render_template('generate_video.html', video_path=output_path)
    return render_template('generate_video.html')


def extract_eyes(image_path, eyes_filename, shape_predictor_path):
    # Function to extract eyes from an image using dlib
    # Load the image and shape predictor model
    image = cv2.imread(image_path)
    detector = dlib.get_frontal_face_detector()
    predictor = dlib.shape_predictor(shape_predictor_path)
    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # Detect faces in the image
    faces = detector(gray)
    # Iterate over the detected faces and extract the eye regions
    for face in faces:
        landmarks = predictor(gray, face)
        # Extract the coordinates of the left eye
        left_eye_pts = [(landmarks.part(i).x, landmarks.part(i).y)
                        for i in range(36, 42)]
        # Extract the coordinates of the right eye
        right_eye_pts = [(landmarks.part(i).x, landmarks.part(i).y)
                         for i in range(42, 48)]
        # Create a transparent image with an alpha channel
        transparent_image = np.zeros(
            (image.shape[0], image.shape[1], 4), dtype=np.uint8)
        # Define the skin color (e.g., light brown or tan) in BGR format
        # skin_color_bgr = (210, 180, 140)
        skin_color_bgr = (80, 80, 40)
        # Convert BGR to RGB
        skin_color_rgb = (skin_color_bgr[2],
                          skin_color_bgr[1], skin_color_bgr[0])
        # Draw the eye regions on the transparent image with the skin color and alpha channel
        cv2.fillPoly(transparent_image, [np.array(
            left_eye_pts)], skin_color_rgb + (200,))
        cv2.fillPoly(transparent_image, [np.array(
            right_eye_pts)], skin_color_rgb + (200,))
        blurred_image = cv2.GaussianBlur(transparent_image, (5, 5), 0)
        # Save the transparent image with only the eyes as a PNG file
        cv2.imwrite(eyes_filename, blurred_image)




def mkloop(input_clip, eyes_clip):
    # Function to create a looping clip with blinking eyes
    # Set the duration of the eye image clip
    eyes_duration = 0.1  # seconds
    # Set the position of the eye image clip
    eyes_position = 'center'
    # Set the start time of the eye image clip
    blink_start_time = randint(2, 4)
    # Create a CompositeVideoClip with the input video and the eye image clip
    final_clip = CompositeVideoClip([input_clip, eyes_clip.set_duration(eyes_duration)
                                     .set_position(eyes_position)
                                     .set_start(blink_start_time)])
    # Calculate the duration of the final clip
    final_duration = blink_start_time + eyes_duration + \
        randint(2, 4)  # 5 to 8 seconds after the blink
    # Set the duration of the final clip
    final_clip = final_clip.set_duration(final_duration)
    return final_clip


def apply_text(mp4_path, text, x, y):
    video = moviepy.editor.VideoFileClip(mp4_path)
    font = "/home/jack/fonts/OpenSansBold.ttf"
    text_clip = moviepy.editor.TextClip(
        text, font=font, fontsize=24, color="white")
    try:
        x = int(x)
        y = int(y)
    except ValueError:
        raise ValueError(
            "Invalid position values. Please provide integer values for x and y.")
    if not (0 <= x <= video.w):
        raise ValueError(
            "Invalid x position. Must be within the width of the video.")

    if not (0 <= y <= video.h):
        raise ValueError(
            "Invalid y position. Must be within the height of the video.")
    text_clip = text_clip.set_position((x, y))
    # Check if duration is None and set a default value if necessary
    video_duration = video.duration if video.duration is not None else 0
    text_clip_duration = text_clip.duration if text_clip.duration is not None else 0
    # Set the duration of the video and text clips
    duration = max(video_duration, text_clip_duration)
    video = video.set_duration(duration)
    text_clip = text_clip.set_duration(duration)
    # Create the composite video by overlaying the text clip onto the video clip
    new_video = moviepy.editor.CompositeVideoClip([video, text_clip])
    # Save the new video with the applied text
    new_mp4_path = 'static/TTMP.mp4'
    new_video.write_videofile(
        new_mp4_path, codec='libx264', audio_codec='aac', remove_temp=False)
    return new_mp4_path


@app.route("/apply_text_to_video", methods=["POST", "GET"])
def apply_text_to_video():
    if request.method == "POST":
        file = request.files["mp4_file"]
        if file.filename == '':
            return redirect(request.url)
        file.save('static/TTMP.mp4')
        mp4_path = 'static/TTMP.mp4'
        text = request.form["text"]
        x = request.form["x"]
        y = request.form["y"]
        new_mp4_path = apply_text(mp4_path, text, x, y)
        return render_template("apply_text_to_video.html", new_mp4_path=new_mp4_path)
    else:
        return render_template("apply_text_to_video.html")


def get_subDirectories(base_path):
    # Get a list of existing subdirectories in the video resources directory
    existing_subdirectories = [subdir for subdir in os.listdir(base_path) if os.path.isdir(os.path.join(base_path, subdir))]
    return existing_subdirectories


@app.route('/uploads', methods=['GET', 'POST'])
def upload_files():
    video_resources_dir = "static/current_project"
    if request.method == 'POST':
        # Get the selected subdirectory from the form
        selected_subdirectory = request.form.get('subdirectory')
        # Check if the selected subdirectory exists
        if selected_subdirectory in existing_subdirectories:
            # Handle the uploaded file
            file = request.files['file']
            if file:
                # Save the file to the selected subdirectory
                file.save(os.path.join(video_resources_dir,
                          selected_subdirectory, file.filename))
                # Get the URL for the uploaded image
                image_path = url_for('static', filename=os.path.join(
                    'current_project', selected_subdirectory, file.filename))
                return render_template('upload_files.html', image_path=image_path)
            else:
                return 'No file selected.'
        else:
            return 'Invalid subdirectory selected.'
    # Render the upload form with the list of existing subdirectories
    return render_template('upload_files.html', subdirectories=existing_subdirectories)


@app.route('/get_files', methods=['POST'])
def get_files():
    subdirectory = request.form.get('subdirectory')
    file_options = []
    if subdirectory and subdirectory in existing_subdirectories:
        subdirectory_path = os.path.join(
            "static/current_project", subdirectory)
        files = os.listdir(subdirectory_path)
        file_options = [
            f'<option value="{file}">{file}</option>'
            for file in files
            if os.path.isfile(os.path.join(subdirectory_path, file))        ]
    return ''.join(file_options)


@app.route('/image_list')
def image_list():
    image_directory = 'static/current_project/Narrators'
    image_list = [
        filename
        for filename in os.listdir(image_directory)
        if filename.endswith('.jpg') or filename.endswith('.png')]
    return render_template('image_list.html', image_list=image_list)


@app.route('/upload', methods=['POST', 'GET'])
def upload():
    filename = request.form['filename']
    if filename:
        src_path = 'static/current_project/Narrators/' + filename
        dest_path = 'static/TEMP.jpg'
        shutil.copyfile(src_path, dest_path)
        return redirect('/')
    else:
        return 'No file selected.'
                     
    



ChatGPT
It seems like you have two Flask applications defined in separate files (`app.py` and another file). When you run your Flask application using `app.py`, it imports modules and resources from the other file. However, it's not directly importing the Flask application instance (`app`) from the other file, which might be the reason it's not recognizing the routes or other resources.

To fix this, you need to ensure that your `app.py` file imports the Flask application instance (`app`) from the other file where it's defined. Additionally, make sure that the routes and other resources are registered with the Flask application instance (`app`) in that file.

Here's how you can modify your `app.py` file to correctly import the Flask application instance from the other file:

```python
from your_other_file import app

if __name__ == "__main__":
    app.run(port=5100, debug=True)
```

Replace `"your_other_file"` with the actual name of the file where your Flask application instance (`app`) is defined. With this modification, your `app.py` file will correctly import the Flask application instance from the other file and run the Flask application with all its routes and resources.

