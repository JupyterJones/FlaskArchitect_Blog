Zoom into specific point
user
def create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5):
    """Create zoom effect frames and save them to the database."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute('''
        CREATE TABLE IF NOT EXISTS frames (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            frame BLOB NOT NULL
        )
    ''')

    img = Image.open(image_path)
    width, height = img.size

    for i in range(num_frames):
        scale = 1 + (zoom_factor - 1) * (i / (num_frames - 1))
        new_width = int(width * scale)
        new_height = int(height * scale)
        resized_img = img.resize((new_width, new_height), Image.LANCZOS)

        # Calculate cropping coordinates for top center focus
        left = (new_width - width) // 2
        top = 0
        right = left + width
        bottom = height

        cropped_img = resized_img.crop((left, top, right, bottom))
        
        # Save frame to database
        buffer = io.BytesIO()
        cropped_img.save(buffer, format="PNG")
        cursor.execute('INSERT INTO frames (frame) VALUES (?)', (buffer.getvalue(),))
        print(f"Saved frame {i + 1}/{num_frames} to database")

    conn.commit()
    conn.close()
---------- can you explain in detail how to zoom into different locations.Example:
if i wanted to these points: x=300 and y=500
ChatGPT
To zoom into different locations, you need to modify the cropping coordinates dynamically based on the desired focus points (x, y). When you zoom into a specific point, you need to ensure that point remains in the same relative position in the frame after resizing the image.

Here’s a detailed explanation and a modified version of your function to allow zooming into a specified point (x, y):

1. **Calculate the scale factor**: This is the same as your current implementation, determining the new size of the image at each frame.

2. **Resize the image**: Resize the image using the calculated scale factor.

3. **Calculate cropping coordinates**:
   - Determine the new dimensions of the resized image.
   - Calculate the new coordinates for the point (x, y) after resizing.
   - Calculate the top-left corner of the cropping area to ensure the point (x, y) remains centered or at a specific position.

4. **Crop the resized image**:
   - Ensure the cropping area is within the bounds of the resized image.
   - Adjust the cropping box if necessary to ensure it does not exceed the image dimensions.

Here’s the complete modified script:

```python
import sqlite3
import io
from PIL import Image

def create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5):
    """
    Create zoom effect frames focusing on a specific point and save them to the database.

    :param image_path: Path to the input image.
    :param db_path: Path to the SQLite database.
    :param num_frames: Number of frames to generate.
    :param zoom_factor: Maximum zoom factor.
    :param focus_x: X-coordinate of the focus point (relative, 0 to 1).
    :param focus_y: Y-coordinate of the focus point (relative, 0 to 1).
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute('''
        CREATE TABLE IF NOT EXISTS frames (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            frame BLOB NOT NULL
        )
    ''')

    img = Image.open(image_path)
    width, height = img.size

    for i in range(num_frames):
        scale = 1 + (zoom_factor - 1) * (i / (num_frames - 1))
        new_width = int(width * scale)
        new_height = int(height * scale)
        resized_img = img.resize((new_width, new_height), Image.LANCZOS)

        # Calculate cropping coordinates for the specified focus point
        focus_x_new = focus_x * new_width
        focus_y_new = focus_y * new_height
        left = int(focus_x_new - (width * focus_x))
        top = int(focus_y_new - (height * focus_y))
        right = left + width
        bottom = top + height

        # Ensure cropping box is within the image bounds
        left = max(0, min(left, new_width - width))
        top = max(0, min(top, new_height - height))
        right = left + width
        bottom = top + height

        cropped_img = resized_img.crop((left, top, right, bottom))

        # Save frame to database
        buffer = io.BytesIO()
        cropped_img.save(buffer, format="PNG")
        cursor.execute('INSERT INTO frames (frame) VALUES (?)', (buffer.getvalue(),))
        print(f"Saved frame {i + 1}/{num_frames} to database")

    conn.commit()
    conn.close()

# Example usage:
# create_zoom_frames('path_to_image.jpg', 'frames.db', num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5)
```

### Explanation of Changes:

1. **Focus Points**: The parameters `focus_x` and `focus_y` are introduced to specify the focus point. These should be provided as relative values (0 to 1), where (0,0) is the top-left and (1,1) is the bottom-right of the image.

2. **Resizing**: The image is resized as before.

3. **Calculating Cropping Coordinates**:
   - The new coordinates of the focus point are calculated based on the resized image dimensions.
   - The top-left corner of the cropping box is calculated to keep the focus point in the same relative position after resizing.

4. **Cropping**: The crop box is adjusted to ensure it stays within the bounds of the resized image.

This way, you can zoom into any point in the image by specifying the relative coordinates of that point. For instance, to zoom into a point at (300, 500) in an image of size (width, height), you would set `focus_x = 300 / width` and `focus_y = 500 / height`.
user
  if image path='/home/jack/Desktop/images/pp001.jpg
i want db_path=  'pp001.db'
image_path= argv[1]
db_path =image_path.split("/")[-1][-3] + ".db"
should this work ?
ChatGPT
The code snippet you provided has a minor issue with string manipulation. Specifically, the slice `[-3]` will only get the third character from the end of the string, rather than the last three characters of the filename without the extension.

Here’s the correct way to extract the filename (without the extension) from `image_path` and construct `db_path` accordingly:

1. Extract the filename from `image_path` using `os.path.basename()`.
2. Remove the file extension using `os.path.splitext()`.
3. Add the `.db` extension to create `db_path`.

Here's how you can do this:

```python
import os
import sys

# Assuming image_path is provided as a command line argument
image_path = sys.argv[1]

# Extract the base name (file name with extension)
base_name = os.path.basename(image_path)

# Remove the file extension
name_without_extension = os.path.splitext(base_name)[0]

# Create the db_path by appending '.db' to the name without extension
db_path = name_without_extension + ".db"

print(f"Image path: {image_path}")
print(f"Database path: {db_path}")
```

### Complete Example with the Zoom Function:

Here’s the complete script including your function to create zoom frames, incorporating the dynamic `db_path` generation:

```python
import sqlite3
import io
from PIL import Image
import os
import sys

def create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5):
    """
    Create zoom effect frames focusing on a specific point and save them to the database.

    :param image_path: Path to the input image.
    :param db_path: Path to the SQLite database.
    :param num_frames: Number of frames to generate.
    :param zoom_factor: Maximum zoom factor.
    :param focus_x: X-coordinate of the focus point (relative, 0 to 1).
    :param focus_y: Y-coordinate of the focus point (relative, 0 to 1).
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute('''
        CREATE TABLE IF NOT EXISTS frames (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            frame BLOB NOT NULL
        )
    ''')

    img = Image.open(image_path)
    width, height = img.size

    for i in range(num_frames):
        scale = 1 + (zoom_factor - 1) * (i / (num_frames - 1))
        new_width = int(width * scale)
        new_height = int(height * scale)
        resized_img = img.resize((new_width, new_height), Image.LANCZOS)

        # Calculate cropping coordinates for the specified focus point
        focus_x_new = focus_x * new_width
        focus_y_new = focus_y * new_height
        left = int(focus_x_new - (width * focus_x))
        top = int(focus_y_new - (height * focus_y))
        right = left + width
        bottom = top + height

        # Ensure cropping box is within the image bounds
        left = max(0, min(left, new_width - width))
        top = max(0, min(top, new_height - height))
        right = left + width
        bottom = top + height

        cropped_img = resized_img.crop((left, top, right, bottom))

        # Save frame to database
        buffer = io.BytesIO()
        cropped_img.save(buffer, format="PNG")
        cursor.execute('INSERT INTO frames (frame) VALUES (?)', (buffer.getvalue(),))
        print(f"Saved frame {i + 1}/{num_frames} to database")

    conn.commit()
    conn.close()

# Main execution
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python script.py <image_path>")
        sys.exit(1)

    image_path = sys.argv[1]
    
    # Extract the base name (file name with extension)
    base_name = os.path.basename(image_path)

    # Remove the file extension
    name_without_extension = os.path.splitext(base_name)[0]

    # Create the db_path by appending '.db' to the name without extension
    db_path = name_without_extension + ".db"

    print(f"Image path: {image_path}")
    print(f"Database path: {db_path}")

    # Call the function with the paths
    create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5)
```

### Explanation:
1. **Path Handling**: `os.path.basename()` is used to get the file name from the path, and `os.path.splitext()` is used to separate the file name from its extension.
2. **Command-line Arguments**: The script expects the image path as a command-line argument. This allows dynamic input when running the script.
3. **Database Path**: The database path is constructed by appending `.db` to the file name without its extension.

This should work correctly for converting an image path to a corresponding database path.
user
db_path =image_path.split("/")[-1][:-3] + ".db"
ChatGPT
The code snippet you provided, `db_path = image_path.split("/")[-1][:-3] + ".db"`, is incorrect because it slices the filename incorrectly. The expression `[:-3]` will remove the last three characters of the filename, which is not the intended outcome.

To achieve the correct result, you should remove the file extension and append `.db` to the filename. Here’s the correct way to do it:

```python
import os
import sys

# Assuming image_path is provided as a command line argument
image_path = sys.argv[1]

# Extract the base name (file name with extension)
base_name = os.path.basename(image_path)

# Remove the file extension
name_without_extension = os.path.splitext(base_name)[0]

# Create the db_path by appending '.db' to the name without extension
db_path = name_without_extension + ".db"

print(f"Image path: {image_path}")
print(f"Database path: {db_path}")
```

### Complete Example with the Zoom Function:

Here’s the complete script including your function to create zoom frames, incorporating the dynamic `db_path` generation:

```python
import sqlite3
import io
from PIL import Image
import os
import sys

def create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5):
    """
    Create zoom effect frames focusing on a specific point and save them to the database.

    :param image_path: Path to the input image.
    :param db_path: Path to the SQLite database.
    :param num_frames: Number of frames to generate.
    :param zoom_factor: Maximum zoom factor.
    :param focus_x: X-coordinate of the focus point (relative, 0 to 1).
    :param focus_y: Y-coordinate of the focus point (relative, 0 to 1).
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute('''
        CREATE TABLE IF NOT EXISTS frames (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            frame BLOB NOT NULL
        )
    ''')

    img = Image.open(image_path)
    width, height = img.size

    for i in range(num_frames):
        scale = 1 + (zoom_factor - 1) * (i / (num_frames - 1))
        new_width = int(width * scale)
        new_height = int(height * scale)
        resized_img = img.resize((new_width, new_height), Image.LANCZOS)

        # Calculate cropping coordinates for the specified focus point
        focus_x_new = focus_x * new_width
        focus_y_new = focus_y * new_height
        left = int(focus_x_new - (width * focus_x))
        top = int(focus_y_new - (height * focus_y))
        right = left + width
        bottom = top + height

        # Ensure cropping box is within the image bounds
        left = max(0, min(left, new_width - width))
        top = max(0, min(top, new_height - height))
        right = left + width
        bottom = top + height

        cropped_img = resized_img.crop((left, top, right, bottom))

        # Save frame to database
        buffer = io.BytesIO()
        cropped_img.save(buffer, format="PNG")
        cursor.execute('INSERT INTO frames (frame) VALUES (?)', (buffer.getvalue(),))
        print(f"Saved frame {i + 1}/{num_frames} to database")

    conn.commit()
    conn.close()

# Main execution
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python script.py <image_path>")
        sys.exit(1)

    image_path = sys.argv[1]
    
    # Extract the base name (file name with extension)
    base_name = os.path.basename(image_path)

    # Remove the file extension
    name_without_extension = os.path.splitext(base_name)[0]

    # Create the db_path by appending '.db' to the name without extension
    db_path = name_without_extension + ".db"

    print(f"Image path: {image_path}")
    print(f"Database path: {db_path}")

    # Call the function with the paths
    create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5)
```

### Explanation:
1. **Path Handling**: `os.path.basename()` is used to get the file name from the path, and `os.path.splitext()` is used to separate the file name from its extension.
2. **Command-line Arguments**: The script expects the image path as a command-line argument. This allows dynamic input when running the script.
3. **Database Path**: The database path is constructed by appending `.db` to the file name without its extension.

This should work correctly for converting an image path to a corresponding database path.
user
def retrieve_frames(conn):
    """Retrieve frames from the database and return them as a list of Image objects."""
    cursor = conn.cursor()
    cursor.execute('SELECT frame FROM frames ORDER BY id')
    frames = cursor.fetchall()
    images = []

    for frame in frames:
        buffer = io.BytesIO(frame[0])
        img = Image.open(buffer)
        images.append(np.array(img))

    return images

def create_video_from_db(db_path, output_video_path, fps=30):
    """Create a video from frames stored in the database."""
    conn = sqlite3.connect(db_path)
    
    # Retrieve frames from the database
    frames = retrieve_frames(conn)
    
    # Create a video from the frames
    clips = [mpy.ImageClip(img).set_duration(1/fps) for img in frames]
    video = mpy.concatenate_videoclips(clips, method="compose")
    video.write_videofile(output_video_path, fps=fps)
    
    print(f"Saved video: {output_video_path}")
now lets make that database a video
ChatGPT
Let's combine the functions you've provided and ensure everything is in place to create a video from the frames stored in the database.

Here’s the complete script to:
1. Retrieve frames from the database.
2. Create a video from those frames.

### Complete Script

```python
import sqlite3
import io
import numpy as np
from PIL import Image
import moviepy.editor as mpy

def retrieve_frames(conn):
    """Retrieve frames from the database and return them as a list of Image objects."""
    cursor = conn.cursor()
    cursor.execute('SELECT frame FROM frames ORDER BY id')
    frames = cursor.fetchall()
    images = []

    for frame in frames:
        buffer = io.BytesIO(frame[0])
        img = Image.open(buffer)
        images.append(np.array(img))

    return images

def create_video_from_db(db_path, output_video_path, fps=30):
    """Create a video from frames stored in the database."""
    conn = sqlite3.connect(db_path)
    
    # Retrieve frames from the database
    frames = retrieve_frames(conn)
    
    # Create a video from the frames
    clips = [mpy.ImageClip(img).set_duration(1/fps) for img in frames]
    video = mpy.concatenate_videoclips(clips, method="compose")
    video.write_videofile(output_video_path, fps=fps)
    
    print(f"Saved video: {output_video_path}")

# Example usage:
# db_path = 'pp001.db'
# output_video_path = 'output_video.mp4'
# create_video_from_db(db_path, output_video_path, fps=30)
```

### Explanation:

1. **retrieve_frames**: This function connects to the database, retrieves all frames, and converts them from BLOBs to `numpy` arrays that can be used to create video frames.

2. **create_video_from_db**: This function uses `moviepy` to create video clips from the frames retrieved by `retrieve_frames`. Each frame is set to a specific duration based on the frames per second (fps) and concatenated to form a complete video. Finally, the video is saved to the specified output path.

### Usage:

1. Save the script to a file, for example, `create_video.py`.
2. Ensure you have all necessary dependencies installed:
   - `numpy`
   - `Pillow`
   - `moviepy`
   - `sqlite3` (standard library)

3. Run the script with the desired database path and output video path:
   ```bash
   python create_video.py pp001.db output_video.mp4
   ```

This script will create a video from the frames stored in the database and save it to the specified output path. If you have any questions or need further adjustments, feel free to ask!
user
can we combine everything into one script 
ChatGPT
Sure, let's combine everything into one script. This script will:

1. Generate zoom frames from an image and store them in a SQLite database.
2. Retrieve the stored frames from the database.
3. Create a video from the retrieved frames.

Here is the complete script:

```python
import sqlite3
import io
import numpy as np
from PIL import Image
import moviepy.editor as mpy
import os
import sys

def create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5):
    """
    Create zoom effect frames focusing on a specific point and save them to the database.

    :param image_path: Path to the input image.
    :param db_path: Path to the SQLite database.
    :param num_frames: Number of frames to generate.
    :param zoom_factor: Maximum zoom factor.
    :param focus_x: X-coordinate of the focus point (relative, 0 to 1).
    :param focus_y: Y-coordinate of the focus point (relative, 0 to 1).
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute('''
        CREATE TABLE IF NOT EXISTS frames (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            frame BLOB NOT NULL
        )
    ''')

    img = Image.open(image_path)
    width, height = img.size

    for i in range(num_frames):
        scale = 1 + (zoom_factor - 1) * (i / (num_frames - 1))
        new_width = int(width * scale)
        new_height = int(height * scale)
        resized_img = img.resize((new_width, new_height), Image.LANCZOS)

        # Calculate cropping coordinates for the specified focus point
        focus_x_new = focus_x * new_width
        focus_y_new = focus_y * new_height
        left = int(focus_x_new - (width * focus_x))
        top = int(focus_y_new - (height * focus_y))
        right = left + width
        bottom = top + height

        # Ensure cropping box is within the image bounds
        left = max(0, min(left, new_width - width))
        top = max(0, min(top, new_height - height))
        right = left + width
        bottom = top + height

        cropped_img = resized_img.crop((left, top, right, bottom))

        # Save frame to database
        buffer = io.BytesIO()
        cropped_img.save(buffer, format="PNG")
        cursor.execute('INSERT INTO frames (frame) VALUES (?)', (buffer.getvalue(),))
        print(f"Saved frame {i + 1}/{num_frames} to database")

    conn.commit()
    conn.close()

def retrieve_frames(conn):
    """Retrieve frames from the database and return them as a list of Image objects."""
    cursor = conn.cursor()
    cursor.execute('SELECT frame FROM frames ORDER BY id')
    frames = cursor.fetchall()
    images = []

    for frame in frames:
        buffer = io.BytesIO(frame[0])
        img = Image.open(buffer)
        images.append(np.array(img))

    return images

def create_video_from_db(db_path, output_video_path, fps=30):
    """Create a video from frames stored in the database."""
    conn = sqlite3.connect(db_path)
    
    # Retrieve frames from the database
    frames = retrieve_frames(conn)
    
    # Create a video from the frames
    clips = [mpy.ImageClip(img).set_duration(1/fps) for img in frames]
    video = mpy.concatenate_videoclips(clips, method="compose")
    video.write_videofile(output_video_path, fps=fps)
    
    print(f"Saved video: {output_video_path}")

# Main execution
if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python script.py <image_path> <output_video_path> [num_frames] [zoom_factor] [focus_x] [focus_y]")
        sys.exit(1)

    image_path = sys.argv[1]
    output_video_path = sys.argv[2]
    
    # Extract the base name (file name with extension)
    base_name = os.path.basename(image_path)

    # Remove the file extension
    name_without_extension = os.path.splitext(base_name)[0]

    # Create the db_path by appending '.db' to the name without extension
    db_path = name_without_extension + ".db"

    # Optional parameters with default values
    num_frames = int(sys.argv[3]) if len(sys.argv) > 3 else 500
    zoom_factor = float(sys.argv[4]) if len(sys.argv) > 4 else 3.5
    focus_x = float(sys.argv[5]) if len(sys.argv) > 5 else 0.5
    focus_y = float(sys.argv[6]) if len(sys.argv) > 6 else 0.5

    print(f"Image path: {image_path}")
    print(f"Database path: {db_path}")
    print(f"Output video path: {output_video_path}")
    print(f"Number of frames: {num_frames}")
    print(f"Zoom factor: {zoom_factor}")
    print(f"Focus X: {focus_x}")
    print(f"Focus Y: {focus_y}")

    # Create zoom frames and store them in the database
    create_zoom_frames(image_path, db_path, num_frames, zoom_factor, focus_x, focus_y)

    # Create a video from the frames stored in the database
    create_video_from_db(db_path, output_video_path, fps=30)
```

### Explanation:
1. **Path Handling**: Extract the filename from the provided image path and create a corresponding database path.
2. **Zoom Frames Creation**: The `create_zoom_frames` function generates zoom frames and stores them in the database.
3. **Retrieve Frames**: The `retrieve_frames` function retrieves frames from the database.
4. **Create Video**: The `create_video_from_db` function creates a video from the retrieved frames.
5. **Command-line Arguments**: The script expects the image path, output video path, and optional parameters (number of frames, zoom factor, focus X, and focus Y) as command-line arguments.

### Usage:
Save the script to a file (e.g., `create_video.py`) and run it with the appropriate arguments:
```bash
python create_video.py /home/jack/Desktop/images/pp001.jpg output_video.mp4 500 3.5 0.5 0.5
```

This will generate zoom frames from the specified image, store them in a database, retrieve the frames, and create a video from them.
user
i can also run
create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5) 
with default values?
ChatGPT
Yes, you can run `create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5)` with default values. The function is designed to accept these default values if specific parameters are not provided.

Here's the updated script with the option to run the function with default values:

```python
import sqlite3
import io
import numpy as np
from PIL import Image
import moviepy.editor as mpy
import os
import sys

def create_zoom_frames(image_path, db_path, num_frames=500, zoom_factor=3.5, focus_x=0.5, focus_y=0.5):
    """
    Create zoom effect frames focusing on a specific point and save them to the database.

    :param image_path: Path to the input image.
    :param db_path: Path to the SQLite database.
    :param num_frames: Number of frames to generate.
    :param zoom_factor: Maximum zoom factor.
    :param focus_x: X-coordinate of the focus point (relative, 0 to 1).
    :param focus_y: Y-coordinate of the focus point (relative, 0 to 1).
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute('''
        CREATE TABLE IF NOT EXISTS frames (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            frame BLOB NOT NULL
        )
    ''')

    img = Image.open(image_path)
    width, height = img.size

    for i in range(num_frames):
        scale = 1 + (zoom_factor - 1) * (i / (num_frames - 1))
        new_width = int(width * scale)
        new_height = int(height * scale)
        resized_img = img.resize((new_width, new_height), Image.LANCZOS)

        # Calculate cropping coordinates for the specified focus point
        focus_x_new = focus_x * new_width
        focus_y_new = focus_y * new_height
        left = int(focus_x_new - (width * focus_x))
        top = int(focus_y_new - (height * focus_y))
        right = left + width
        bottom = top + height

        # Ensure cropping box is within the image bounds
        left = max(0, min(left, new_width - width))
        top = max(0, min(top, new_height - height))
        right = left + width
        bottom = top + height

        cropped_img = resized_img.crop((left, top, right, bottom))

        # Save frame to database
        buffer = io.BytesIO()
        cropped_img.save(buffer, format="PNG")
        cursor.execute('INSERT INTO frames (frame) VALUES (?)', (buffer.getvalue(),))
        print(f"Saved frame {i + 1}/{num_frames} to database")

    conn.commit()
    conn.close()

def retrieve_frames(conn):
    """Retrieve frames from the database and return them as a list of Image objects."""
    cursor = conn.cursor()
    cursor.execute('SELECT frame FROM frames ORDER BY id')
    frames = cursor.fetchall()
    images = []

    for frame in frames:
        buffer = io.BytesIO(frame[0])
        img = Image.open(buffer)
        images.append(np.array(img))

    return images

def create_video_from_db(db_path, output_video_path, fps=30):
    """Create a video from frames stored in the database."""
    conn = sqlite3.connect(db_path)
    
    # Retrieve frames from the database
    frames = retrieve_frames(conn)
    
    # Create a video from the frames
    clips = [mpy.ImageClip(img).set_duration(1/fps) for img in frames]
    video = mpy.concatenate_videoclips(clips, method="compose")
    video.write_videofile(output_video_path, fps=fps)
    
    print(f"Saved video: {output_video_path}")

# Main execution
if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python script.py <image_path> <output_video_path> [num_frames] [zoom_factor] [focus_x] [focus_y]")
        sys.exit(1)

    image_path = sys.argv[1]
    output_video_path = sys.argv[2]
    
    # Extract the base name (file name with extension)
    base_name = os.path.basename(image_path)

    # Remove the file extension
    name_without_extension = os.path.splitext(base_name)[0]

    # Create the db_path by appending '.db' to the name without extension
    db_path = name_without_extension + ".db"

    # Optional parameters with default values
    num_frames = int(sys.argv[3]) if len(sys.argv) > 3 else 500
    zoom_factor = float(sys.argv[4]) if len(sys.argv) > 4 else 3.5
    focus_x = float(sys.argv[5]) if len(sys.argv) > 5 else 0.5
    focus_y = float(sys.argv[6]) if len(sys.argv) > 6 else 0.5

    print(f"Image path: {image_path}")
    print(f"Database path: {db_path}")
    print(f"Output video path: {output_video_path}")
    print(f"Number of frames: {num_frames}")
    print(f"Zoom factor: {zoom_factor}")
    print(f"Focus X: {focus_x}")
    print(f"Focus Y: {focus_y}")

    # Create zoom frames and store them in the database
    create_zoom_frames(image_path, db_path, num_frames, zoom_factor, focus_x, focus_y)

    # Create a video from the frames stored in the database
    create_video_from_db(db_path, output_video_path, fps=30)
```

### Explanation:
1. **Default Values**: The `create_zoom_frames` function is designed to use default values for `num_frames`, `zoom_factor`, `focus_x`, and `focus_y` if these parameters are not provided.
2. **Command-line Arguments**: The script now accepts the image path and output video path as mandatory command-line arguments. Optional parameters (`num_frames`, `zoom_factor`, `focus_x`, `focus_y`) are accepted if provided, otherwise, default values are used.

### Usage Examples:
- Run with default values:
  ```bash
  python script.py /home/jack/Desktop/images/pp001.jpg output_video.mp4
  ```
- Run with custom values:
  ```bash
  python script.py /home/jack/Desktop/images/pp001.jpg output_video.mp4 600 4.0 0.4 0.4
  ```

This way, you have the flexibility to use default values or provide custom parameters as needed.

