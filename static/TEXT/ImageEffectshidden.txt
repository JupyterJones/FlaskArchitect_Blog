
from moviepy.video.compositing.transitions import slide_in
from moviepy.video.fx import all
from moviepy.editor import *
import glob
import random
from PIL import Image
import cv2
import uuid
import shutil
def HELP():
    text ="""
    DIR="/home/jack/Desktop/LearnFlask_step-by-step/static/imagez/misc_images/"
    title_image_path = "/mnt/HDD500/EXPER/static/assets/Title_Image02.png"
    #video_path = generate_video(DIR)
    video_path = slidein(DIR)
    #add_title_image(video_path, title_image_path, hex_color = "#408913")
    add_title_image(video_path, hex_color = "#A52A2A")
    """
    print(text)
    return (text)
# Set the output video parameters
def add_title_image(video_path, title_image_path, hex_color = "#94493c"):
    # Load the video file and title image
    video_clip = VideoFileClip(video_path)
    print(video_clip.size)
    width, height = video_clip.size

    # Set the desired size of the padded video (e.g., video width + padding, video height + padding)
    padded_size = (width + 90, height + 90)

    # Calculate the position for centering the video within the larger frame
    x_position = (padded_size[0] - video_clip.size[0]) / 2
    y_position = (padded_size[1] - video_clip.size[1]) / 2
    #hex_color = "#09723c"
    # Remove the '#' and split the hex code into R, G, and B components
    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)

    # Create an RGB tuple
    rgb_tuple = (r, g, b)

    # Create a blue ColorClip as the background
    blue_background = ColorClip(padded_size, color=rgb_tuple)

    # Add the video clip on top of the red background
    padded_video_clip = CompositeVideoClip([blue_background, video_clip.set_position((x_position, y_position))])
    padded_video_clip = padded_video_clip.set_duration(video_clip.duration)
    #title_image_path = "/home/jack/Desktop/EXPER/static/assets/Title_Image02.png"
    # Load the title image
    title_image = ImageClip(title_image_path)

    # Set the duration of the title image
    title_duration = video_clip.duration
    title_image = title_image.set_duration(title_duration)

    print(video_clip.size)
    # Position the title image at the center and resize it to fit the video dimensions
    #title_image = title_image.set_position(("left", "top"))
    title_image = title_image.set_position((0, -5))
    #video_clip.size = (620,620)
    title_image = title_image.resize(padded_video_clip.size)

    # Position the title image at the center and resize it to fit the video dimensions
    #title_image = title_image.set_position(("center", "center")).resize(video_clip.size)

    # Create a composite video clip with the title image overlay
    composite_clip = CompositeVideoClip([padded_video_clip, title_image])
    # Limit the length to 58 seconds
    composite_clip = composite_clip.subclip(0, 40)
    # Load a random background music
    mp3_files = glob.glob("/mnt/HDD500/collections/Music/*.mp3")
    random.shuffle(mp3_files)

    # Now choose a random MP3 file from the shuffled list
    mp_music = random.choice(mp3_files)

    # Load the background music without setting duration
    music_clip = AudioFileClip(mp_music)
    music_clip = music_clip.subclip(0, 40)
    fade_duration = 1.0
    music_clip = music_clip.audio_fadein(fade_duration).audio_fadeout(fade_duration)
    # Set the audio of the composite clip to the background music
    composite_clip = composite_clip.set_audio(music_clip)
    output_path = 'temp/final_output3.mp4'
    # Export the final video with the background music
    composite_clip.write_videofile(output_path)
    uid = str(uuid.uuid4())  # Generate a unique ID using uuid
    mp4_file =  f"/home/jack/Desktop/HDD500/collections/vids/{uid}.mp4"
    shutil.copyfile(output_path, mp4_file)     
    print(mp4_file)
    VIDEO = output_path
    return VIDEO

def slidein(DIR):
    #print(DIR+"*.jpg")
    image_files=glob.glob(DIR+"*.jpg")
    print("image_files: ",image_files)
    fps = 25 # Frames per second
    #size = (512, 768) # Size of the output video
    duration =1 # Duration of each image in seconds
    size=Image.open(image_files[1]).size
    random.shuffle(image_files)
    print(image_files)
    # Create a list of image clips with transitions
    clips = []

    for i in range(len(image_files)):
        # Load the image and create a video clip
        image_clip = ImageClip(image_files[i]).set_duration(duration)
        direction = random.choice(['right','left','top','bottom'])
        
        if i > 0:
            # Add a vertical slide transition to the previous clip
            transition = slide_in(image_clip, duration=1, side=direction)
            clips.append(CompositeVideoClip([clips[-1], transition]).set_duration(1))
            
        clips.append(image_clip)

    # Concatenate the clips to create the final video
    video = concatenate_videoclips(clips)

    # Set the output video parameters
    video = video.set_fps(fps)
    video = video.resize(size)

    # Save the video
    VIDEO = 'temp/final_output.mp4'
    video.write_videofile(VIDEO)
    print("Video Created at: ",VIDEO)
    return VIDEO

def get_an_mp3():
    all_mp3s = glob.glob("/home/jack/Desktop/HDD500/collections/Music/*.mp3")
    random.shuffle(all_mp3s)
    MP3 = random.choice(all_mp3s)
    return MP3 

def generate_video(DIR):
        image_files = glob.glob(DIR+"*.jpg")
        # Shuffle the image files to mix them randomly
        random.shuffle(image_files)

        # Create a temporary directory to store the resized images
        temp_dir = 'temp/'
        os.makedirs(temp_dir, exist_ok=True)

        # Load and resize the images
        resized_images = []
        for image_file in image_files:
            im = Image.open(image_file)
            SIZE = im.size

            img = cv2.imread(image_file)
            img = cv2.resize(img, SIZE)  # Resize to the same size as the original image
            resized_images.append(img)

        # Create a video writer
        out_path = 'temp/output.mp4'
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # You may need to change the codec depending on your system
        out = cv2.VideoWriter(out_path, fourcc, 30, SIZE)

        # Keep track of video duration
        video_duration = 0

        # Create the video with fading transitions
        for i in range(len(resized_images)):
            if video_duration >= 58:  # Limit video to 58 seconds
                break

            img1 = resized_images[i]
            img2 = resized_images[(i + 1) % len(resized_images)]  # Wrap around to the first image
            # changing the alpha step size will change the duration of the fade effect
            step_size = 5
            for alpha in range(0, 150):  # Gradually change alpha from 0 to 100 for fade effect
                alpha /= 150.0
                blended = cv2.addWeighted(img1, 1 - alpha, img2, alpha, 0)
                out.write(blended)
                video_duration += 1 / 30  # Assuming 30 FPS

        out.release()

        # Prepare an audio clip of the same duration (58 seconds)
        audio_clip = AudioFileClip(get_an_mp3())  # Replace with your audio file path
        audio_clip = audio_clip.subclip(0, 58)  # Limit audio to 58 seconds
        # Load the video clip
        video_clip = VideoFileClip(out_path)

        # Set the audio of the video clip
        video_clip = video_clip.set_audio(audio_clip)

        # Save the final video with music
        final_output_path = 'temp/final_output.mp4'
        uid = str(uuid.uuid4())  # Generate a unique ID using uuid
        mp4_file =  f"temp/{uid}.mp4"
      
        
        video_clip.write_videofile(final_output_path, codec='libx264')
        shutil.copyfile(final_output_path, mp4_file) 
        print(final_output_path)
        VIDEO=final_output_path
        return VIDEO



#video_path = slidein(DIR)
def storeit (video_path):
    # Split the video_path using '/'
    path_parts = video_path.split('/')
    fname = "POSTED_" + video_path.split("/")[-1]
    print(fname)
    uid = str(uuid.uuid4())  # Generate a unique ID using uuid
    dest =  f"/home/jack/Desktop/HDD500/collections/vids/{fname[:-4]}{uid}.mp4"    
    print (dest)
    # Join the path parts up to the last directory to reconstruct the base path
    print("Source:", video_path, "  Base Path:", dest)
    src = "temp/final_output.mp4"
    shutil.copy(src, dest)
    #if os.path.exists(video_path):
    #    os.remove(video_path)
    #    print(f"File '{video_path}' has been removed.")
    #else:
    #    print(f"File '{video_path}' does not exist, so it cannot be removed.")

