from PIL import Image
import PIL
import tensorflow as tf
import numpy as np
import tensorflow_hub as hub
import time
from tensorflow.python.ops.numpy_ops import np_config
np_config.enable_numpy_behavior()
from PIL import Image
import random
import os
from sys import argv
"""
Let's break down the script and understand each part, narrated in a way that can be converted to an MP3 for your convenience.

Introduction:

Hello, Jack! Today, we'll walk through a Python script that uses TensorFlow, PIL, and TensorFlow Hub to apply artistic styles from one image to another. We'll explain each part of the script step-by-step, so let's dive in!

Libraries and Imports:

First, we import the necessary libraries. The Python Imaging Library (PIL) is used for image processing tasks. TensorFlow and TensorFlow Hub are utilized for loading and executing machine learning models. We also use numpy for numerical operations and os for directory management.

python

from PIL import Image
import PIL
import tensorflow as tf
import numpy as np
import tensorflow_hub as hub
import time
from tensorflow.python.ops.numpy_ops import np_config
np_config.enable_numpy_behavior()
from PIL import Image
import random
import os
from sys import argv

Creating Directories:

We create two directories, preped_images and _images, if they do not already exist. These directories will store the processed content and style images, and the final stylized images, respectively.

python

directory = 'preped_images'
if not os.path.exists(directory):
    os.makedirs(directory)
directory = '_images'
if not os.path.exists(directory):
    os.makedirs(directory)

Helper Functions:

    tensor_to_image(tensor):

This function converts a TensorFlow tensor to a PIL image. It multiplies the tensor values by 255 to get the pixel values, converts it to a numpy array, and then to a PIL image.

python

def tensor_to_image(tensor):
  tensor = tensor * 255
  tensor = np.array(tensor, dtype=np.uint8)
  if np.ndim(tensor) > 3:
    assert tensor.shape[0] == 1
    tensor = tensor[0]
  return PIL.Image.fromarray(tensor)

    load_img(path_to_img):

This function loads an image from a given path, resizes it to a maximum dimension of 512 pixels while maintaining the aspect ratio, and converts it to a TensorFlow tensor.

python

def load_img(path_to_img):
  max_dim = 512
  img = tf.io.read_file(path_to_img)
  img = tf.image.decode_image(img, channels=3)
  img = tf.image.convert_image_dtype(img, tf.float32)

  shape = tf.cast(tf.shape(img)[:-1], tf.float32)
  long_dim = max(shape)
  scale = max_dim / long_dim

  new_shape = tf.cast(shape * scale, tf.int32)

  img = tf.image.resize(img, new_shape)
  img = img[tf.newaxis, :]
  return img

    prep_content(content) and prep_style(style):

These functions open an image, resize it to 512x768 pixels using the nearest neighbor method, and save it to the preped_images directory with a modified filename. They return the new file path.

python

def prep_content(content):
    PI = Image.open(content)
    PI = PI.resize((512, 768), Image.NEAREST)
    CFilename = os.path.basename(content)
    PI.save("preped_images/Content_" + CFilename)
    Content_data = "preped_images/Content_" + CFilename
    return Content_data

def prep_style(style):
    PI = Image.open(style)
    PI = PI.resize((512, 768), Image.NEAREST)
    SFilename = os.path.basename(style)
    PI.save("preped_images/Style_" + SFilename)
    Style_data = "preped_images/Style_" + SFilename
    return Style_data

Selecting Random Images:

We define paths to two directories containing images. For each directory, we randomly select an image file to be used as the content and style images, respectively.

python

path = r"/home/jack/Desktop/collections/images/Alien_Comic/"
base_image = random.choice([x for x in os.listdir(path) if os.path.isfile(os.path.join(path, x))])
content = (path + base_image)
print("content " + path + base_image)

path2 = r"/home/jack/Desktop/collections/images/accident3/"
base_image = random.choice([x for x in os.listdir(path2) if os.path.isfile(os.path.join(path2, x))])
style = (path2 + base_image)
print("style " + path2 + base_image)

Loading and Preparing Images:

We load and prepare the content and style images using the previously defined functions.

python

content_image = load_img(prep_content(content))
style_image = load_img(prep_style(style))
print(content_image.size)
print(style_image.size)

Loading the Model and Stylizing the Image:

We load a pre-trained image stylization model from TensorFlow Hub. This model takes the content and style images as inputs and outputs the stylized image.

python

hub_model = hub.load("http://0.0.0.0:8000/Models/magenta_arbitrary-image-stylization-v1-256_2.tar.gz")
stylized_image = hub_model(tf.constant(content_image), tf.constant(style_image))[0]

Saving the Stylized Image:

We convert the stylized image tensor to a PIL image, generate a timestamped filename, save the image in the _images directory, and print the saved file path.

python

im = tensor_to_image(stylized_image)
timestr = time.strftime("%Y%m%d-%H%M%S")
savefile = "_images/" + timestr + ".jpg"
im.save(savefile)
print(im.size)
print("Saved to: " + savefile)

Conclusion:

And there you have it, Jack! This script uses TensorFlow and TensorFlow Hub to apply artistic styles from one image to another, saving the final result. This process involves image preparation, loading a pre-trained model, and saving the output. It's a fascinating example of how machine learning models can create stunning visual art.

I hope this walkthrough helps you understand the script better. Happy coding!
"""
directory ='preped_images'
if not os.path.exists(directory):
    os.makedirs(directory)
directory ='_images'
if not os.path.exists(directory):
    os.makedirs(directory)   
def tensor_to_image(tensor):
  tensor = tensor*255
  tensor = np.array(tensor, dtype=np.uint8)
  if np.ndim(tensor)>3:
    assert tensor.shape[0] == 1
    tensor = tensor[0]
  return PIL.Image.fromarray(tensor)
    
def load_img(path_to_img):
  max_dim = 512
  img = tf.io.read_file(path_to_img)
  img = tf.image.decode_image(img, channels=3)
  img = tf.image.convert_image_dtype(img, tf.float32)

  shape = tf.cast(tf.shape(img)[:-1], tf.float32)
  long_dim = max(shape)
  scale = max_dim / long_dim

  new_shape = tf.cast(shape * scale, tf.int32)

  img = tf.image.resize(img, new_shape)
  img = img[tf.newaxis, :]
  return img    
def prep_content(content):
    PI = Image.open(content)
    PI = PI.resize((512,768), Image.NEAREST)
    CFilename = os.path.basename(content)
    PI.save("preped_images/Content_"+CFilename)
    Content_data="preped_images/Content_"+CFilename
    return Content_data
    
def prep_style(style):
    PI = Image.open(style)
    PI = PI.resize((512,768), Image.NEAREST)
    SFilename = os.path.basename(style)
    PI.save("preped_images/Style_"+SFilename)
    Style_data="preped_images/Style_"+SFilename
    return Style_data    


path = r"/home/jack/Desktop/collections/images/Alien_Comic/"
#path = argv[1]
base_image = random.choice([
    x for x in os.listdir(path)
    if os.path.isfile(os.path.join(path, x))
])
content=(path+base_image)
con=Image.open(content)
CFilename = os.path.basename(content)
con.save("_images/Content_"+CFilename)
print("content"+path+base_image)

#content = "/home/jack/Pictures/1022362.jpg"
#content = "/home/jack/Desktop/TENSORFLOW/images/default-file-q4.png"

path2 = r"/home/jack/Desktop/collections/images/accident3/"
#path2 = argv[2]
base_image = random.choice([
    x for x in os.listdir(path2)
    if os.path.isfile(os.path.join(path2, x))
])
style=(path2+base_image)
sty=Image.open(style)
SFilename = os.path.basename(style)
sty.save("_images/Style_"+SFilename)
print("style"+path2+base_image)
content_image = load_img(prep_content(content))
style_image = load_img(prep_style(style))
print(content_image.size)
print(style_image.size)

hub_model = hub.load("http://0.0.0.0:8000/Models/magenta_arbitrary-image-stylization-v1-256_2.tar.gz")
stylized_image = hub_model(tf.constant(content_image), tf.constant(style_image))[0]
im = tensor_to_image(stylized_image)
timestr = time.strftime("%Y%m%d-%H%M%S")
savefile = "_images/"+timestr+".jpg"
im.save(savefile)
print(im.size)
print("Saved to: "+savefile)
