Extract Code Cells Jupyter
user
how can i the code cells from a directory of jupyter notebooks
ChatGPT
To extract code cells from a directory of Jupyter notebooks, you can use Python to read and parse the notebook files (`.ipynb`), which are JSON files. Here's a complete script that does this:

1. Scans a directory for Jupyter notebook files.
2. Reads each notebook file and extracts code cells.
3. Saves the extracted code cells to a specified directory.

Here's the complete script:

```python
import os
import json
import logging

# Setup logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

def extract_code_cells_from_notebook(notebook_path):
    """
    Extract code cells from a Jupyter notebook.
    :param notebook_path: Path to the Jupyter notebook file.
    :return: List of code cells.
    """
    with open(notebook_path, 'r', encoding='utf-8') as file:
        notebook_content = json.load(file)
    
    code_cells = []
    for cell in notebook_content['cells']:
        if cell['cell_type'] == 'code':
            code_cells.append(''.join(cell['source']))
    
    return code_cells

def save_code_cells(code_cells, output_path):
    """
    Save code cells to a file.
    :param code_cells: List of code cells.
    :param output_path: Path to the output file.
    """
    with open(output_path, 'w', encoding='utf-8') as file:
        for cell in code_cells:
            file.write(cell)
            file.write('\n\n')

def process_notebooks_in_directory(directory_path, output_directory):
    """
    Process all Jupyter notebooks in a directory to extract and save code cells.
    :param directory_path: Path to the directory containing Jupyter notebooks.
    :param output_directory: Path to the directory to save extracted code cells.
    """
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)
    
    for filename in os.listdir(directory_path):
        if filename.endswith('.ipynb'):
            notebook_path = os.path.join(directory_path, filename)
            logging.info(f'Processing notebook: {notebook_path}')
            
            code_cells = extract_code_cells_from_notebook(notebook_path)
            if code_cells:
                output_path = os.path.join(output_directory, f'{os.path.splitext(filename)[0]}_code_cells.py')
                save_code_cells(code_cells, output_path)
                logging.info(f'Saved code cells to: {output_path}')
            else:
                logging.info(f'No code cells found in notebook: {notebook_path}')

# Directory containing Jupyter notebooks
notebooks_directory = '/path/to
otebooks'

# Directory to save extracted code cells
output_directory = '/path/to/output'

# Process the notebooks
process_notebooks_in_directory(notebooks_directory, output_directory)
```

### Explanation:

1. **Logging Setup**: Configures logging to output debug information to the console.

2. **extract_code_cells_from_notebook**:
   - Reads a Jupyter notebook file.
   - Parses it as JSON.
   - Extracts cells of type `code`.

3. **save_code_cells**:
   - Saves the extracted code cells to a file.

4. **process_notebooks_in_directory**:
   - Scans the specified directory for `.ipynb` files.
   - For each notebook file, extracts code cells and saves them to the output directory.

### Usage:
1. Replace `/path/to
otebooks` with the path to the directory containing your Jupyter notebooks.
2. Replace `/path/to/output` with the path to the directory where you want to save the extracted code cells.

This script will extract code cells from all Jupyter notebooks in the specified directory and save them as `.py` files in the output directory.
user
, in extract_code_cells_from_notebook
    notebook_content = json.load(file)
  File "/home/jack/miniconda3/envs/cloned_base/lib/python3.9/json/__init__.py", line 293, in load
    return loads(fp.read(),
  File "/home/jack/miniconda3/envs/cloned_base/lib/python3.9/json/__init__.py", line 346, in loads
    return _default_decoder.decode(s)
  File "/home/jack/miniconda3/envs/cloned_base/lib/python3.9/json/decoder.py", line 337, in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
  File "/home/jack/miniconda3/envs/cloned_base/lib/python3.9/json/decoder.py", line 355, in raw_decode
    raise JSONDecodeError("Expecting value", s, err.value) from None
json.decoder.JSONDecodeError: Expecting value: line 7 column 1 (char 80)

ChatGPT
The `JSONDecodeError` typically occurs if the notebook file is not valid JSON. This can happen if the file is corrupted or if it contains invalid JSON syntax. To handle this error and continue processing other notebooks, you can add error handling in the script. Hereâ€™s the updated script with enhanced error handling and logging:

```python
import os
import json
import logging

# Setup logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

def extract_code_cells_from_notebook(notebook_path):
    """
    Extract code cells from a Jupyter notebook.
    :param notebook_path: Path to the Jupyter notebook file.
    :return: List of code cells.
    """
    try:
        with open(notebook_path, 'r', encoding='utf-8') as file:
            notebook_content = json.load(file)
        
        code_cells = []
        for cell in notebook_content['cells']:
            if cell['cell_type'] == 'code':
                code_cells.append(''.join(cell['source']))
        
        return code_cells
    except json.JSONDecodeError as e:
        logging.error(f'Error decoding JSON from notebook {notebook_path}: {e}')
        return []
    except Exception as e:
        logging.error(f'Unexpected error processing notebook {notebook_path}: {e}')
        return []

def save_code_cells(code_cells, output_path):
    """
    Save code cells to a file.
    :param code_cells: List of code cells.
    :param output_path: Path to the output file.
    """
    try:
        with open(output_path, 'w', encoding='utf-8') as file:
            for cell in code_cells:
                file.write(cell)
                file.write('\n\n')
    except Exception as e:
        logging.error(f'Error saving code cells to {output_path}: {e}')

def process_notebooks_in_directory(directory_path, output_directory):
    """
    Process all Jupyter notebooks in a directory to extract and save code cells.
    :param directory_path: Path to the directory containing Jupyter notebooks.
    :param output_directory: Path to the directory to save extracted code cells.
    """
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)
    
    for filename in os.listdir(directory_path):
        if filename.endswith('.ipynb'):
            notebook_path = os.path.join(directory_path, filename)
            logging.info(f'Processing notebook: {notebook_path}')
            
            code_cells = extract_code_cells_from_notebook(notebook_path)
            if code_cells:
                output_path = os.path.join(output_directory, f'{os.path.splitext(filename)[0]}_code_cells.py')
                save_code_cells(code_cells, output_path)
                logging.info(f'Saved code cells to: {output_path}')
            else:
                logging.info(f'No code cells found in notebook: {notebook_path}')

# Directory containing Jupyter notebooks
notebooks_directory = '/path/to
otebooks'

# Directory to save extracted code cells
output_directory = '/path/to/output'

# Process the notebooks
process_notebooks_in_directory(notebooks_directory, output_directory)
```

### Explanation of Changes:

1. **Error Handling in `extract_code_cells_from_notebook`**:
   - Added a `try-except` block to catch `json.JSONDecodeError` and log an error message.
   - If a `JSONDecodeError` occurs, the function returns an empty list to indicate no code cells were extracted.
   - Added a general `except` block to catch any other unexpected errors.

2. **Error Handling in `save_code_cells`**:
   - Added a `try-except` block to catch and log any errors that occur while saving the code cells.

This will allow the script to continue processing other notebooks even if one of them has invalid JSON or some other issue. Replace `/path/to
otebooks` and `/path/to/output` with the appropriate paths for your setup.
user
from PIL import Image, ImageTk
import PIL
from sys import argv
import sys
from tkinter import *
import cv2
import numpy as np 
'''
'''

window = Tk(className="Clickable")
data = []
image = PIL.Image.open("/home/jack/Desktop/FlaskBlog/TRANSITIONS/images/images/00022.jpg")
canvas = Canvas(window, width=image.size[0], height=image.size[1])
canvas.pack()
image_tk = ImageTk.PhotoImage(image)
canvas.create_image(image.size[0]//2, image.size[1]//2, image=image_tk)

def callback(event):
    #print "[",event.x,"],["+event.y,"]"
    #Data= ("[",event.x,",",event.y,"],",)
    Data= [event.x,event.y]
    data.append(Data)
    print ("[",event.x,",",event.y,"],",)

canvas.bind("<Button-1>", callback)
mainloop()

poly = np.array(data, np.int32)

# Read images
dst = cv2.imread("/home/jack/Desktop/FlaskBlog/TRANSITIONS/images/images/00021.jpg")
src = cv2.imread("/home/jack/Desktop/FlaskBlog/TRANSITIONS/images/images/00022.jpg")
src_mask = np.zeros(src.shape, src.dtype)
#poly = np.array([ [1,100], [1,50], [151,63], [254,37], [298,90], [272,134], [43,122] ], np.int32)
cv2.fillPoly(src_mask, [poly], (255, 255, 255))
# This is where the CENTER where thr 'poly' will be placed
center = (250,275)
# Clone seamlessly.
output = cv2.seamlessClone(src, dst, src_mask, center, cv2.NORMAL_CLONE)
# Write result
cv2.imwrite("01-cloning-xxz1.jpg", output);
im = PIL.Image.open("01-cloning-xxz1.jpg")
im.show()

import tkinter as tk
Name="fds"
window = tk.Tk(className = Name)
def change_className():
    global Name
    Name = "dsfsd"
    window.title(Name)
explain in detail what this script does
ChatGPT
This script is a combination of Python code using the Tkinter library for GUI interactions and OpenCV for image processing. The purpose of the script appears to be to allow the user to click on points of an image displayed in a Tkinter window, record those points, and then use those points to perform a seamless clone operation with OpenCV. Let's break down the script in detail:

### Step-by-Step Breakdown:

1. **Imports and Initializations:**

    ```python
    from PIL import Image, ImageTk
    import PIL
    from sys import argv
    import sys
    from tkinter import *
    import cv2
    import numpy as np
    ```

    - **PIL (Pillow)**: Used for opening and displaying images.
    - **sys**: Provides access to system-specific parameters and functions.
    - **tkinter**: Used to create GUI elements.
    - **cv2 (OpenCV)**: Used for image processing.
    - **numpy**: Used for handling arrays, particularly for the points clicked on the image.

2. **Setting up Tkinter Window:**

    ```python
    window = Tk(className="Clickable")
    data = []
    image = PIL.Image.open("/home/jack/Desktop/FlaskBlog/TRANSITIONS/images/images/00022.jpg")
    canvas = Canvas(window, width=image.size[0], height=image.size[1])
    canvas.pack()
    image_tk = ImageTk.PhotoImage(image)
    canvas.create_image(image.size[0]//2, image.size[1]//2, image=image_tk)
    ```

    - A Tkinter window named "Clickable" is created.
    - An empty list `data` is initialized to store the points clicked by the user.
    - An image is loaded using PIL and displayed on a Tkinter canvas.

3. **Callback Function for Mouse Clicks:**

    ```python
    def callback(event):
        Data = [event.x, event.y]
        data.append(Data)
        print("[", event.x, ",", event.y, "],")

    canvas.bind("<Button-1>", callback)
    mainloop()
    ```

    - The `callback` function captures the coordinates of mouse clicks on the canvas.
    - These coordinates are appended to the `data` list.
    - The canvas is bound to the `<Button-1>` event (left mouse click), so that each click calls the `callback` function.
    - `mainloop()` starts the Tkinter event loop, waiting for user actions.

4. **Using Collected Points for Seamless Cloning:**

    ```python
    poly = np.array(data, np.int32)

    dst = cv2.imread("/home/jack/Desktop/FlaskBlog/TRANSITIONS/images/images/00021.jpg")
    src = cv2.imread("/home/jack/Desktop/FlaskBlog/TRANSITIONS/images/images/00022.jpg")
    src_mask = np.zeros(src.shape, src.dtype)
    cv2.fillPoly(src_mask, [poly], (255, 255, 255))

    center = (250, 275)
    output = cv2.seamlessClone(src, dst, src_mask, center, cv2.NORMAL_CLONE)
    cv2.imwrite("01-cloning-xxz1.jpg", output)
    im = PIL.Image.open("01-cloning-xxz1.jpg")
    im.show()
    ```

    - The collected points are converted to a numpy array `poly`.
    - Two images are read using OpenCV: `dst` (destination image) and `src` (source image, which was also displayed in Tkinter).
    - A mask `src_mask` of the same size as the source image is created and filled with the polygon defined by `poly`.
    - The `cv2.seamlessClone` function performs the seamless cloning operation, blending the source image into the destination image at the specified `center` position using the mask.
    - The result is saved to a file and displayed using PIL.

5. **Additional Tkinter Window (Unused):**

    ```python
    import tkinter as tk
    Name = "fds"
    window = tk.Tk(className=Name)

    def change_className():
        global Name
        Name = "dsfsd"
        window.title(Name)
    ```

    - This part of the script creates another Tkinter window and a function to change its title. However, this part is not connected to the main flow of the script.

### Summary:

1. **GUI Setup**: A Tkinter window displays an image, allowing the user to click on it.
2. **Data Collection**: Click coordinates are collected and stored in a list.
3. **Image Processing**: These points are used to create a mask, which is then used for seamless cloning with OpenCV.
4. **Display Result**: The result of the seamless cloning is saved and displayed.

This script allows users to interactively select points on an image and use those points to perform a seamless cloning operation on another image, effectively blending the selected area into a new image.
user
This script works great and is a perfect example of seamlessclone.
ChatGPT
I'm glad to hear that the script works well for you! Seamless cloning is indeed a powerful technique for blending images, and it's great to see it being applied effectively in your use case. If you have any further questions or need additional features or modifications for the script, feel free to ask. Happy coding, Jack!

