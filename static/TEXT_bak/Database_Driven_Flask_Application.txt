Database-Driven Flask Application
user
from flask import Flask, request, jsonify, render_template, redirect, url_for
import sqlite3
import os
import datetime
from transformers import pipeline, Conversation
from transformers import AutoModelForCausalLM, AutoTokenizer, Conversation, pipeline
import glob
import random
app = Flask(__name__)

BASEPATH = os.path.dirname(os.path.abspath(__file__))

def logit(logdata):
    timestr = datetime.datetime.now().strftime('%A_%b-%d-%Y %H:%M:%S')
    log_file_path = os.path.join(BASEPATH, "testlog2.txt")
    with open(log_file_path, "a") as log_file:
        log_file.write(f"{timestr}: {logdata}\n")
    print("testlog2.txt entry:", logdata)

logit("TEST: 12345 in testlog2.txt")

@app.route('/view_log')
def readlog():
    log_file_path = os.path.join(BASEPATH, "testlog2.txt")
    with open(log_file_path, "r") as log_file:
        logdata = log_file.readlines()
    return render_template('read_log.html', log_content=logdata)

def create_connection():
    connection = sqlite3.connect('conversations.db')
    return connection
def get_db_connection():
    # Replace this with your actual database connection logic
    connection = sqlite3.connect('conversations.db')
    pass
def create_tables():
    connection = create_connection()
    cursor = connection.cursor()
    
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS conversations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_input TEXT NOT NULL,
        bot_response TEXT NOT NULL
    )
    ''')
    
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS training_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_input TEXT NOT NULL,
        bot_response TEXT NOT NULL
    )
    ''')
    
    connection.commit()
    connection.close()

def get_db_connection():
    conn = sqlite3.connect('conversations.db')
    conn.row_factory = sqlite3.Row
    return conn

# Initialize the transformers pipeline for conversational response generation
conversational_pipeline = pipeline("conversational")

def generate_response_with_persona(user_input):
    # List of predefined responses with a friendly female persona
    predefined_responses = {
        "hello": "Hi there! I'm Ginny, your friendly chatbot. How can I help you today?",
        "how are you": "I'm just a bot, but I'm here to assist you! How are you?",
        "what's your name": "My name is Ginny. It's nice to meet you!",
        "are you a dude": "No, I'm Ginny, your friendly female chatbot.",
        "goodbye": "Goodbye! Have a wonderful day!"
    }
    
    # Check if the user_input matches any predefined response
    if user_input.lower() in predefined_responses:
        return predefined_responses[user_input.lower()]
    # If no predefined response, generate a response using the conversational model
    conversation = Conversation(user_input)
    result = conversational_pipeline(conversation)
    logit(f'Result from conversational_pipeline: {result}')
    try:
        bot_response = result.generated_responses[-1]
    except (KeyError, IndexError, AttributeError) as e:
        logit(f"Error accessing bot response: {e}")
        bot_response = "Sorry, I couldn't generate a response."
    
    return bot_response

def images():
    images = glob.glob('static/images/*.jpg')
    imag=random.choice(images)
    return imag    
   
@app.route('/')
def index():
    img=images()
    return render_template('index.html' , img=img)

@app.route('/train', methods=['GET', 'POST'])
def train():
    if request.method == 'POST':
        dialogue_text = request.form.get('dialogue')
        process_and_insert_dialogue_text(dialogue_text)
        return redirect(url_for('train'))
    
    # Fetch existing training data
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM training_data')
    training_data = cursor.fetchall()
    conn.close()
    
    return render_template('train.html', training_data=training_data)

def insert_training_data(user_input, bot_response):
    conn = get_db_connection()
    cursor = conn.cursor()

    # Check for duplicates before inserting
    cursor.execute('''
    SELECT COUNT(*) FROM training_data 
    WHERE user_input = ? AND bot_response = ?
    ''', (user_input, bot_response))
    
    count = cursor.fetchone()[0]
    
    if count == 0:
        cursor.execute('INSERT INTO training_data (user_input, bot_response) VALUES (?, ?)', (user_input, bot_response))
        conn.commit()
    conn.close()

def process_and_insert_dialogue_text(dialogue_text):
    lines = dialogue_text.split('\n')
    for line in lines:
        if '|' in line:
            parts = line.strip().split('|', 1)
            if len(parts) == 2:
                user_input, bot_response = parts
                insert_training_data(user_input, bot_response)
            else:
                logit(f"Invalid format in line: {line}")
        else:
            logit(f"Missing '|' in line: {line}")

@app.route('/conversations', methods=['GET'])
def get_conversations():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM conversations')
    conversations = cursor.fetchall()
    conn.close()
    
    return jsonify([dict(ix) for ix in conversations])

@app.route('/conversations/<int:id>', methods=['PUT'])
def update_response(id):
    new_response = request.json.get('bot_response')
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('UPDATE conversations SET bot_response = ? WHERE id = ?', (new_response, id))
    conn.commit()
    conn.close()
    
    return jsonify({'status': 'success', 'message': 'Response updated'})

@app.route('/view_conversations', methods=['GET', 'POST'])
def view_conversations():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM conversations')
    conversations = cursor.fetchall()
    conn.close()
    return render_template('view_conversations.html', conversations=conversations)

@app.route('/view_training', methods=['GET', 'POST'])
def view_view_training():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM training_data')
    training_data = cursor.fetchall()
    conn.close()
    return render_template('view_training_data.html', training_data=training_data)

'''
# Load the tokenizer and model
model_name = "microsoft/DialoGPT-medium"
logit("Loading tokenizer and model")
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForCausalLM.from_pretrained(model_name)

# Set the pad_token_id to eos_token_id to avoid warnings
logit("Setting pad_token_id to eos_token_id")
model.config.pad_token_id = model.config.eos_token_id

# Create the conversational pipeline with generation parameters to reduce repetition
logit("Creating conversational pipeline")
conversational_pipeline = pipeline(
    "conversational", 
    model=model, 
    tokenizer=tokenizer,
    max_length=250,  # Adjust the maximum length as needed
    no_repeat_ngram_size=3,  # Avoid repeating trigrams
    repetition_penalty=2.0  # Penalize repetition
)
'''
try:
    #model_name = "microsoft/DialoGPT-medium"
    model_name = "models--gpt2-xl"
    # Load the tokenizer and model
    logit("Loading tokenizer and model")
    tokenizer = AutoTokenizer.from_pretrained(model_name)
    model = AutoModelForCausalLM.from_pretrained(model_name)

    # Set the pad_token_id to eos_token_id to avoid warnings
    logit("Setting pad_token_id to eos_token_id")
    model.config.pad_token_id = model.config.eos_token_id

    # Create the conversational pipeline with generation parameters to reduce repetition
    logit("Creating conversational pipeline")
    conversational_pipeline = pipeline(
        "conversational", 
        model=model, 
        tokenizer=tokenizer,
        max_length=250,  # Adjust the maximum length as needed
        no_repeat_ngram_size=2,  # Avoid repeating bigrams
        repetition_penalty=1.2,  # Penalize repetition slightly
        temperature=0.7,  # Control the creativity of the model
        top_p=0.9  # Top-p sampling for diversity
    )

    # Example conversation
    logit("Starting conversation")
    conversation = Conversation("How are you?")
    response = conversational_pipeline([conversation])
    logit(f"User: {conversation.past_user_inputs[-1]}")
    logit(f"Assistant: {conversation.generated_responses[-1]}")
    print(f"Assistant: {conversation.generated_responses[-1]}")

    # Continuing the conversation
    conversation.add_user_input("Good day, my friend.")
    response = conversational_pipeline([conversation])
    logit(f"User: {conversation.past_user_inputs[-1]}")
    logit(f"Assistant: {conversation.generated_responses[-1]}")
    print(f"Assistant: {conversation.generated_responses[-1]}")

except Exception as e:
    logit("An error occurred-> " + str(e))
    print(f"An error occurred: {e}")
# Function to generate response
def generate_response_with_persona(user_input):
    logit(f"Generating response for input: {user_input}")
    conversation = Conversation(user_input)
    response = conversational_pipeline([conversation])
    return conversation.generated_responses[-1]

@app.route('/chat', methods=['POST', 'GET'])
def chat():
    try:
        user_input = request.json.get('message')
        logit(f'Received user input: {user_input}')

        if not user_input or len(user_input) <= 5:
            chat()
            logit('User input is either blank or less than 5 characters. Conversation not saved.')
            return jsonify({'response': 'Invalid input.'})

        bot_response = generate_response_with_persona(user_input)
        logit(f'Bot response: {bot_response}')

        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('INSERT INTO conversations (user_input, bot_response) VALUES (?, ?)', 
                       (user_input, bot_response))
        conn.commit()
        logit('Conversation saved to database successfully.')
    except Exception as e:
        logit(f'Error processing request: {str(e)}')
        return jsonify({'response': 'Error processing request.'}), 500
    finally:
        if 'conn' in locals() or 'conn' in globals():
            conn.close()
            logit('Database connection closed.')

    return jsonify({'response': bot_response})


@app.route('/edit_conversation', methods=['GET'])
def edit_conversation_form():
    id = request.args.get('id', type=int)
    if id is not None:
        return redirect(url_for('edit_conversation', id=id))
    return 'ID is required.', 400

@app.route('/edit_training', methods=['GET'])
def edit_training_form():
    id = request.args.get('id', type=int)
    if id is not None:
        return redirect(url_for('edit_training', id=id))
    return 'ID is required.', 400


def update_conversation(conn, id, new_bot_response):
    cursor = conn.cursor()
    cursor.execute('UPDATE conversations SET bot_response = ? WHERE id = ?', (new_bot_response, id))
    conn.commit()

def update_training(conn, id, new_bot_response):
    cursor = conn.cursor()
    cursor.execute('UPDATE training_data SET bot_response = ? WHERE id = ?', (new_bot_response, id))
    conn.commit()    

@app.route('/append_dialogue', methods=['POST', 'GET'])
def append_dialogue():
    dialogue_file_path = 'dialogue.txt'  # Adjust the file path as needed
    with open(dialogue_file_path, 'r') as file:
        dialogue_text = file.read()
    process_and_insert_dialogue_text(dialogue_text)
    return redirect(url_for('train',text=dialogue_text))

def move_conversations_to_training():
    conn = get_db_connection()
    cursor = conn.cursor()
    # Fetch conversations
    cursor.execute('SELECT user_input, bot_response FROM conversations')
    conversations = cursor.fetchall()
    # Insert each conversation into training_data
    for conversation in conversations:
        user_input = conversation['user_input']
        bot_response = conversation['bot_response']
        
        # Skip if either user_input or bot_response is empty
        if not user_input or not bot_response:
            # Log a warning or handle the empty values
            logit(f"Skipping conversation due to empty value: user_input={user_input}, bot_response={bot_response}")
            continue
        
        insert_training_data(user_input, bot_response)
    
    conn.close()


@app.route('/move_conversations')
def move_conversations():
    move_conversations_to_training()
    return 'Conversations moved to training_data table'



# Route to display edit form and handle updates
@app.route('/edit_entry/<int:id>', methods=['GET', 'POST'])
def edit_entry(id):
    connection = create_connection()
    cursor = connection.cursor()

    if request.method == 'GET':
        # Retrieve data from both tables for the given id
        cursor.execute('SELECT user_input, bot_response FROM conversations WHERE id = ?', (id,))
        conversation_data = cursor.fetchone()
        cursor.execute('SELECT user_input, bot_response FROM training_data WHERE id = ?', (id,))
        training_data = cursor.fetchone()

        if conversation_data or training_data:
            # Render edit form with retrieved data
            return render_template('edit.html', id=id, conversation_data=conversation_data, training_data=training_data)
        else:
            return 'Entry not found.', 404

    elif request.method == 'POST':
        # Handle form submission to update both tables
        user_input_conversation = request.form.get('conversation_user_input', '')
        bot_response_conversation = request.form.get('conversation_bot_response', '')
        user_input_training = request.form.get('training_user_input', '')
        bot_response_training = request.form.get('training_bot_response', '')

        # Update conversations table
        cursor.execute('UPDATE conversations SET user_input = ?, bot_response = ? WHERE id = ?', 
                       (user_input_conversation, bot_response_conversation, id))

        # Update training_data table
        cursor.execute('UPDATE training_data SET user_input = ?, bot_response = ? WHERE id = ?', 
                       (user_input_training, bot_response_training, id))

        connection.commit()
        connection.close()

        return redirect(url_for('edit_entry', id=id))  # Redirect to GET after update

    return 'Method not allowed', 405
@app.route('/edit_conversation/<int:id>', methods=['GET', 'POST'])
def edit_conversation(id):
    connection = create_connection()
    cursor = connection.cursor()

    if request.method == 'GET':
        cursor.execute('SELECT user_input, bot_response FROM conversations WHERE id = ?', (id,))
        conversation_data = cursor.fetchone()

        if conversation_data:
            return render_template('edit_conversation.html', id=id, conversation_data=conversation_data)
        else:
            return 'Conversation entry not found.', 404

    elif request.method == 'POST':
        user_input_conversation = request.form.get('conversation_user_input', '')
        bot_response_conversation = request.form.get('conversation_bot_response', '')

        cursor.execute('UPDATE conversations SET user_input = ?, bot_response = ? WHERE id = ?', 
                       (user_input_conversation, bot_response_conversation, id))

        connection.commit()
        connection.close()

        return redirect(url_for('edit_conversation', id=id))

    return 'Method not allowed', 405


@app.route('/edit_training/<int:id>', methods=['GET', 'POST'])
def edit_training(id):
    connection = create_connection()
    cursor = connection.cursor()

    if request.method == 'GET':
        cursor.execute('SELECT user_input, bot_response FROM training_data WHERE id = ?', (id,))
        training_data = cursor.fetchone()

        if training_data:
            return render_template('edit_training.html', id=id, training_data=training_data)
        else:
            return 'Training entry not found.', 404

    elif request.method == 'POST':
        user_input_training = request.form.get('training_user_input', '')
        bot_response_training = request.form.get('training_bot_response', '')

        cursor.execute('UPDATE training_data SET user_input = ?, bot_response = ? WHERE id = ?', 
                       (user_input_training, bot_response_training, id))

        connection.commit()
        connection.close()

        return redirect(url_for('edit_training', id=id))

    return 'Method not allowed', 405
def copy_data():
    """Copy data from the conversations table to the training_data table."""
    connection = create_connection()
    cursor = connection.cursor()
    
    try:
        cursor.execute('''
        INSERT INTO training_data (user_input, bot_response)
        SELECT user_input, bot_response FROM conversations
        ''')
        connection.commit()
        logit("Data copied from 'conversations' to 'training_data' successfully.")
    except sqlite3.Error as e:
        logit(f"The error '{e}' occurred during data copy.")
    
    connection.close()
@app.route('/print_training')
def print_training():
    connection = create_connection()
    File = open("training.txt", "w")
    cursor = connection.cursor()
    rows = cursor.execute('SELECT user_input, bot_response FROM training_data')
    for row in rows:
        File.write(row[0] + " | " + row[1] + "\n")
    File.close()
    connection.close()
    logit("Data printed to 'training.txt' successfully.")
    return "Data printed to 'training.txt' successfully."
        
        
if __name__ == '__main__':
    create_tables()
    #copy_data()    
    app.run(debug=True)
----------------------------------------
could you make this run 100% off database no transformers
i still need all the database edit features
user
 
ChatGPT
Certainly, Jack! Here's your Flask application modified to run 100% off the database without using transformers. All the database edit features are retained. The chatbot will now respond based on predefined responses stored in the `training_data` table.

```python
from flask import Flask, request, jsonify, render_template, redirect, url_for
import sqlite3
import os
import datetime
import glob
import random

app = Flask(__name__)

BASEPATH = os.path.dirname(os.path.abspath(__file__))

def logit(logdata):
    timestr = datetime.datetime.now().strftime('%A_%b-%d-%Y %H:%M:%S')
    log_file_path = os.path.join(BASEPATH, "testlog2.txt")
    with open(log_file_path, "a") as log_file:
        log_file.write(f"{timestr}: {logdata}\n")
    print("testlog2.txt entry:", logdata)

logit("TEST: 12345 in testlog2.txt")

@app.route('/view_log')
def readlog():
    log_file_path = os.path.join(BASEPATH, "testlog2.txt")
    with open(log_file_path, "r") as log_file:
        logdata = log_file.readlines()
    return render_template('read_log.html', log_content=logdata)

def create_connection():
    connection = sqlite3.connect('conversations.db')
    return connection

def create_tables():
    connection = create_connection()
    cursor = connection.cursor()
    
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS conversations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_input TEXT NOT NULL,
        bot_response TEXT NOT NULL
    )
    ''')
    
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS training_data (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_input TEXT NOT NULL,
        bot_response TEXT NOT NULL
    )
    ''')
    
    connection.commit()
    connection.close()

def get_db_connection():
    conn = sqlite3.connect('conversations.db')
    conn.row_factory = sqlite3.Row
    return conn

def images():
    images = glob.glob('static/images/*.jpg')
    imag = random.choice(images)
    return imag    

@app.route('/')
def index():
    img = images()
    return render_template('index.html', img=img)

@app.route('/train', methods=['GET', 'POST'])
def train():
    if request.method == 'POST':
        dialogue_text = request.form.get('dialogue')
        process_and_insert_dialogue_text(dialogue_text)
        return redirect(url_for('train'))
    
    # Fetch existing training data
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM training_data')
    training_data = cursor.fetchall()
    conn.close()
    
    return render_template('train.html', training_data=training_data)

def insert_training_data(user_input, bot_response):
    conn = get_db_connection()
    cursor = conn.cursor()

    # Check for duplicates before inserting
    cursor.execute('''
    SELECT COUNT(*) FROM training_data 
    WHERE user_input = ? AND bot_response = ?
    ''', (user_input, bot_response))
    
    count = cursor.fetchone()[0]
    
    if count == 0:
        cursor.execute('INSERT INTO training_data (user_input, bot_response) VALUES (?, ?)', (user_input, bot_response))
        conn.commit()
    conn.close()

def process_and_insert_dialogue_text(dialogue_text):
    lines = dialogue_text.split('\n')
    for line in lines:
        if '|' in line:
            parts = line.strip().split('|', 1)
            if len(parts) == 2:
                user_input, bot_response = parts
                insert_training_data(user_input, bot_response)
            else:
                logit(f"Invalid format in line: {line}")
        else:
            logit(f"Missing '|' in line: {line}")

@app.route('/conversations', methods=['GET'])
def get_conversations():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM conversations')
    conversations = cursor.fetchall()
    conn.close()
    
    return jsonify([dict(ix) for ix in conversations])

@app.route('/conversations/<int:id>', methods=['PUT'])
def update_response(id):
    new_response = request.json.get('bot_response')
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('UPDATE conversations SET bot_response = ? WHERE id = ?', (new_response, id))
    conn.commit()
    conn.close()
    
    return jsonify({'status': 'success', 'message': 'Response updated'})

@app.route('/view_conversations', methods=['GET', 'POST'])
def view_conversations():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM conversations')
    conversations = cursor.fetchall()
    conn.close()
    return render_template('view_conversations.html', conversations=conversations)

@app.route('/view_training', methods=['GET', 'POST'])
def view_view_training():
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT * FROM training_data')
    training_data = cursor.fetchall()
    conn.close()
    return render_template('view_training_data.html', training_data=training_data)

def generate_response_from_database(user_input):
    logit(f"Generating response for input: {user_input}")
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute('SELECT bot_response FROM training_data WHERE user_input = ?', (user_input,))
    result = cursor.fetchone()
    conn.close()

    if result:
        return result['bot_response']
    else:
        return "Sorry, I couldn't generate a response."

@app.route('/chat', methods=['POST', 'GET'])
def chat():
    try:
        user_input = request.json.get('message')
        logit(f'Received user input: {user_input}')

        if not user_input or len(user_input) <= 5:
            logit('User input is either blank or less than 5 characters. Conversation not saved.')
            return jsonify({'response': 'Invalid input.'})

        bot_response = generate_response_from_database(user_input)
        logit(f'Bot response: {bot_response}')

        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute('INSERT INTO conversations (user_input, bot_response) VALUES (?, ?)', 
                       (user_input, bot_response))
        conn.commit()
        logit('Conversation saved to database successfully.')
    except Exception as e:
        logit(f'Error processing request: {str(e)}')
        return jsonify({'response': 'Error processing request.'}), 500
    finally:
        if 'conn' in locals() or 'conn' in globals():
            conn.close()
            logit('Database connection closed.')

    return jsonify({'response': bot_response})

@app.route('/edit_conversation', methods=['GET'])
def edit_conversation_form():
    id = request.args.get('id', type=int)
    if id is not None:
        return redirect(url_for('edit_conversation', id=id))
    return 'ID is required.', 400

@app.route('/edit_training', methods=['GET'])
def edit_training_form():
    id = request.args.get('id', type=int)
    if id is not None:
        return redirect(url_for('edit_training', id=id))
    return 'ID is required.', 400

def update_conversation(conn, id, new_bot_response):
    cursor = conn.cursor()
    cursor.execute('UPDATE conversations SET bot_response = ? WHERE id = ?', (new_bot_response, id))
    conn.commit()

def update_training(conn, id, new_bot_response):
    cursor = conn.cursor()
    cursor.execute('UPDATE training_data SET bot_response = ? WHERE id = ?', (new_bot_response, id))
    conn.commit()    

@app.route('/append_dialogue', methods=['POST', 'GET'])
def append_dialogue():
    dialogue_file_path = 'dialogue.txt'  # Adjust the file path as needed
    with open(dialogue_file_path, 'r') as file:
        dialogue_text = file.read()
    process_and_insert_dialogue_text(dialogue_text)
    return redirect(url_for('train', text=dialogue_text))

def move_conversations_to_training():
    conn = get_db_connection()
    cursor = conn.cursor()
    # Fetch conversations
    cursor.execute('SELECT user_input, bot_response FROM conversations')
    conversations = cursor.fetchall()
    # Insert each conversation into training_data
    for conversation in conversations:
        user_input = conversation['user_input']
        bot_response = conversation['bot_response']
        
        # Skip if either user_input or bot_response is empty
        if not user_input or not bot_response:
            # Log a warning or handle the empty values
            logit(f"Skipping conversation due to empty value: user_input={user_input}, bot_response={bot_response}")
            continue
        
        insert_training_data(user_input, bot_response)
    
    conn.close()

@app.route('/move_conversations')
def move_conversations():
    move_conversations_to_training()
    return 'Conversations moved to training_data table'

# Route to display edit form and handle updates
@app.route('/edit_entry/<int:id>', methods=['GET', 'POST'])
def edit_entry(id):
    connection = create_connection()
    cursor = connection.cursor()

    if request.method == 'GET':
        # Retrieve data from both tables for the given id
        cursor.execute('SELECT user_input, bot_response FROM conversations WHERE id = ?', (id,))
        conversation_data = cursor.fetchone()
        cursor.execute('SELECT user_input, bot_response FROM training_data WHERE id = ?', (id,))
        training_data = cursor.fetchone()

        if conversation_data or training_data:
            # Render edit form with retrieved data
            return render_template('edit.html', id=id, conversation_data=conversation_data, training_data=training_data)
        else:
            return
ChatGPT
 'Entry not found', 404

    elif request.method == 'POST':
        new_user_input = request.form.get('user_input')
        new_bot_response = request.form.get('bot_response')
        
        # Update both tables if entries exist
        if new_user_input and new_bot_response:
            cursor.execute('UPDATE conversations SET user_input = ?, bot_response = ? WHERE id = ?', 
                           (new_user_input, new_bot_response, id))
            cursor.execute('UPDATE training_data SET user_input = ?, bot_response = ? WHERE id = ?', 
                           (new_user_input, new_bot_response, id))
            connection.commit()
            return redirect(url_for('index'))
        else:
            return 'Invalid input', 400

@app.route('/edit_conversation/<int:id>', methods=['GET', 'POST'])
def edit_conversation(id):
    conn = get_db_connection()
    cursor = conn.cursor()

    if request.method == 'POST':
        new_bot_response = request.form['bot_response']
        cursor.execute('UPDATE conversations SET bot_response = ? WHERE id = ?', (new_bot_response, id))
        conn.commit()
        conn.close()
        return redirect(url_for('view_conversations'))
    
    cursor.execute('SELECT * FROM conversations WHERE id = ?', (id,))
    conversation = cursor.fetchone()
    conn.close()
    return render_template('edit_conversation.html', conversation=conversation)

@app.route('/edit_training/<int:id>', methods=['GET', 'POST'])
def edit_training(id):
    conn = get_db_connection()
    cursor = conn.cursor()

    if request.method == 'POST':
        new_bot_response = request.form['bot_response']
        cursor.execute('UPDATE training_data SET bot_response = ? WHERE id = ?', (new_bot_response, id))
        conn.commit()
        conn.close()
        return redirect(url_for('view_view_training'))
    
    cursor.execute('SELECT * FROM training_data WHERE id = ?', (id,))
    training_data = cursor.fetchone()
    conn.close()
    return render_template('edit_training.html', training_data=training_data)

if __name__ == '__main__':
    create_tables()
    app.run(debug=True)
```

### Explanation:
- **Database-driven Response Generation**: The chatbot now fetches predefined responses from the `training_data` table, ensuring the responses are generated solely based on the database content.
- **Editing Capabilities**: Included routes for editing both `conversations` and `training_data`.
- **Logging**: The `logit` function logs various activities and potential errors, aiding in debugging and monitoring.

This setup will ensure your Flask application operates fully on the database for chatbot responses, eliminating the dependency on transformers while retaining full functionality for data editing and training.

