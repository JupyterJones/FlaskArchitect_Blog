Zoom Video Processing Assistant
user
import cv2
import numpy as np
import os
import imagehash
from PIL import Image

def calculate_hash(frame):
    # Convert frame to grayscale
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Calculate hash using average hashing (aHash)
    hash_value = imagehash.average_hash(Image.fromarray(gray_frame))

    return hash_value

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_hash = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        # Calculate hash of the frame
        hash_value = calculate_hash(frame)

        # Check if the hash is different from the previous frame
        if prev_hash is None or hash_value != prev_hash:
            unique_frames.append(frame)
            prev_hash = hash_value

    cap.release()
    return unique_frames, fps

def create_zoom_video(frames, output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50):
    # Define video codec and create VideoWriter object
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))

    for frame in frames:
        # Apply zoom effect to the frame
        zoomed_frames = interpolate_zoom(frame, zoom_factor, num_frames_zoom)

        # Add frames to video writer
        for zoomed_frame in zoomed_frames:
            video_writer.write(zoomed_frame)

    video_writer.release()

def interpolate_zoom(frame, zoom_factor, num_frames_zoom):
    zoomed_frames = []
    for i in range(num_frames_zoom):
        # Interpolate zoom factor
        current_zoom = 1 + (zoom_factor - 1) * (i / (num_frames_zoom - 1))

        # Apply zoom effect to the frame
        zoomed_frame = zoom_frame(frame, current_zoom)

        zoomed_frames.append(zoomed_frame)

    return zoomed_frames

def zoom_frame(frame, zoom_factor):
    # Get frame dimensions
    height, width = frame.shape[:2]

    # Compute new dimensions after zooming
    new_width = int(width * zoom_factor)
    new_height = int(height * zoom_factor)

    # Resize the frame to apply the zoom effect
    zoomed_frame = cv2.resize(frame, (new_width, new_height))

    # Compute cropping coordinates to maintain original size and zoom to center
    crop_x1 = (new_width - width) // 2
    crop_x2 = crop_x1 + width
    crop_y1 = (new_height - height) // 2
    crop_y2 = crop_y1 + height

    # Crop the zoomed frame to original dimensions
    zoomed_frame = zoomed_frame[crop_y1:crop_y2, crop_x1:crop_x2]

    return zoomed_frame

if __name__ == "__main__":
    input_video = "video.mp4"
    output_video_directory = "zoomed_videos"

    # Create output directory if it doesn't exist
    if not os.path.exists(output_video_directory):
        os.makedirs(output_video_directory)

    # Extract unique frames from the input video
    unique_frames, fps = extract_unique_frames(input_video)

    # Create zoomed video for each frame
    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)
please convert to flask app
choose mp4 from computer in index.html
ChatGPT

ChatGPT
To convert this script into a Flask application, we'll create routes to handle file uploads, process the uploaded video, and return the zoomed video to the user. Here's the complete Flask application:

```python
import os
from flask import Flask, render_template, request, redirect, url_for, send_from_directory
import cv2
from zoom_utils import calculate_hash, extract_unique_frames, create_zoom_video

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    # Extract unique frames from the input video
    unique_frames, fps = extract_unique_frames(input_video_path)

    # Create zoomed video for each frame
    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    return redirect(url_for('download_zoomed_videos', filename=filename))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    zip_file = f'{filename.split(".")[0]}_zoomed_videos.zip'
    zip_path = os.path.join(app.config['UPLOAD_FOLDER'], zip_file)
    os.system(f'zip -r {zip_path} {zoomed_directory}')
    return send_from_directory(app.config['UPLOAD_FOLDER'], zip_file, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

Here's what we did:

1. Created Flask routes for uploading a video file (`/upload`), processing the video (`/process/<filename>`), and downloading the processed videos (`/download/<filename>`).
2. Defined an `allowed_file` function to ensure only MP4 files are uploaded.
3. Used OpenCV functions to extract unique frames from the uploaded video and create zoomed videos for each frame.
4. Implemented file handling to save the uploaded video and the generated zoomed videos in specified directories.
5. Created a route to download the zoomed videos as a zip file.
6. Utilized Flask's `render_template` function to render an HTML file for the upload form (`index.html`).

You'll need to create an HTML file named `index.html` in a folder named `templates` within the same directory as your Flask app. This HTML file will contain the form to upload the video file.

Let me know if you need help with the HTML form!
user
index.html
ChatGPT
Sure, here's a simple HTML file named `index.html` for the upload form:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload Video</title>
</head>
<body>
    <h1>Upload Video</h1>
    <form action="/upload" method="post" enctype="multipart/form-data">
        <input type="file" name="file" accept=".mp4">
        <input type="submit" value="Upload">
    </form>
</body>
</html>
```

This HTML file contains a form with a file input field where users can select an MP4 video file to upload. When the form is submitted, it sends a POST request to the `/upload` route in the Flask app.

You can save this HTML code in a file named `index.html` and place it in a folder named `templates` within the same directory as your Flask app. This ensures that Flask can render the HTML template correctly. Let me know if you need further assistance!
user
@app.route('/')
def index():
content ='''
    return render_template('index.html')
can  the form be created here
ChatGPT
Certainly! You can generate the HTML form directly in the `index` route function. Here's how you can modify the route function to include the form:

```python
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
    content = '''
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Upload Video</title>
    </head>
    <body>
        <h1>Upload Video</h1>
        <form action="/upload" method="post" enctype="multipart/form-data">
            <input type="file" name="file" accept=".mp4">
            <input type="submit" value="Upload">
        </form>
    </body>
    </html>
    '''
    return content

if __name__ == "__main__":
    app.run(debug=True)
```

With this modification, when a user accesses the root URL of your Flask app, they will see the HTML form for uploading a video file. When the form is submitted, it will send a POST request to the `/upload` route, as specified in the form's action attribute.

Remember, it's a common practice to separate HTML templates from Python code for better organization and maintainability. However, for simple applications or prototypes, embedding HTML directly in the Python code as shown above can be acceptable.
user
from zoom_utils import calculate_hash, extract_unique_frames, create_zoom_video
ModuleNotFoundError: No module named 'zoom_utils
ChatGPT
It seems like there's an issue with importing the `zoom_utils` module. Let's ensure that the `zoom_utils.py` file is in the same directory as your Flask application script or is accessible from your Python path.

If `zoom_utils.py` is in a different directory, you can add its location to Python's sys.path. For example:

```python
import sys
sys.path.append('/path/to/zoom_utils.py')
```

Replace `'/path/to/zoom_utils.py'` with the actual path to the directory containing `zoom_utils.py`.

Alternatively, if `zoom_utils.py` is part of a package installed via pip, ensure that the package is installed in the environment where you're running the Flask application.

Once you've ensured that `zoom_utils.py` is accessible, the import statement should work correctly. Let me know if you need further assistance!
user
locate zoom_utils
/home/jack/miniconda3/envs/cloned_base/lib/python3.9/site-packages/zoom_utils-0.0.0.dist-info
/home/jack/miniconda3/envs/cloned_base/lib/python3.9/site-packages/zoom_utils-0.0.0.dist-info/INSTALLER
/home/jack/miniconda3/envs/cloned_base/lib/python3.9/site-packages/zoom_utils-0.0.0.dist-info/METADATA
/home/jack/miniconda3/envs/cloned_base/lib/python3.9/site-packages/zoom_utils-0.0.0.dist-info/RECORD
/home/jack/miniconda3/envs/cloned_base/lib/python3.9/site-packages/zoom_utils-0.0.0.dist-info/REQUESTED
/home/jack/miniconda3/envs/cloned_base/lib/python3.9/site-packages/zoom_utils-0.0.0.dist-info/WHEEL
/home/jack/miniconda3/envs/cloned_base/lib/python3.9/site-packages/zoom_utils-0.0.0.dist-info/licenses
/home/jack/miniconda3/envs/cloned_base/lib/python3.9/site-packages/zoom_utils-0.0.0.dist-info/licenses/LICENSE

ChatGPT
It seems that `zoom_utils` is installed as a package in your Python environment, but it appears to contain metadata files rather than the actual Python module. This might be due to a misconfiguration during installation.

If `zoom_utils` is supposed to contain Python code, you may need to reinstall it or check if there was an issue during installation. You can reinstall it using pip:

```
pip install --upgrade --force-reinstall zoom_utils
```

If `zoom_utils` is not a package containing Python code but rather just metadata, you might need to locate the actual `zoom_utils.py` file and ensure it's accessible to your Flask application.

Once you've confirmed the correct location of `zoom_utils.py`, you can adjust your Flask application's import statement accordingly. Let me know if you need further assistance!
user
do it without zoom_utils
ChatGPT
Sure, let's modify the Flask application to remove the dependency on `zoom_utils` and directly implement the functionality within the Flask app itself. We'll integrate the frame processing and video zooming directly into the Flask routes. Here's the updated Flask application:

```python
import os
from flask import Flask, render_template, request, redirect, url_for, send_from_directory
import cv2

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_frame = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        # Check if the frame is different from the previous frame
        if prev_frame is None or not np.array_equal(frame, prev_frame):
            unique_frames.append(frame)
            prev_frame = frame

    cap.release()
    return unique_frames, fps

def create_zoom_video(frames, output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50):
    # Define video codec and create VideoWriter object
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))

    for frame in frames:
        # Apply zoom effect to the frame
        zoomed_frames = interpolate_zoom(frame, zoom_factor, num_frames_zoom)

        # Add frames to video writer
        for zoomed_frame in zoomed_frames:
            video_writer.write(zoomed_frame)

    video_writer.release()

def interpolate_zoom(frame, zoom_factor, num_frames_zoom):
    zoomed_frames = []
    for i in range(num_frames_zoom):
        # Interpolate zoom factor
        current_zoom = 1 + (zoom_factor - 1) * (i / (num_frames_zoom - 1))

        # Apply zoom effect to the frame
        zoomed_frame = zoom_frame(frame, current_zoom)

        zoomed_frames.append(zoomed_frame)

    return zoomed_frames

def zoom_frame(frame, zoom_factor):
    # Get frame dimensions
    height, width = frame.shape[:2]

    # Compute new dimensions after zooming
    new_width = int(width * zoom_factor)
    new_height = int(height * zoom_factor)

    # Resize the frame to apply the zoom effect
    zoomed_frame = cv2.resize(frame, (new_width, new_height))

    # Compute cropping coordinates to maintain original size and zoom to center
    crop_x1 = (new_width - width) // 2
    crop_x2 = crop_x1 + width
    crop_y1 = (new_height - height) // 2
    crop_y2 = crop_y1 + height

    # Crop the zoomed frame to original dimensions
    zoomed_frame = zoomed_frame[crop_y1:crop_y2, crop_x1:crop_x2]

    return zoomed_frame

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    # Extract unique frames from the input video
    unique_frames, fps = extract_unique_frames(input_video_path)

    # Create zoomed video for each frame
    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    return redirect(url_for('download_zoomed_videos', filename=filename))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    zip_file = f'{filename.split(".")[0]}_zoomed_videos.zip'
    zip_path = os.path.join(app.config['UPLOAD_FOLDER'], zip_file)
    os.system(f'zip -r {zip_path} {zoomed_directory}')
    return send_from_directory(app.config['UPLOAD_FOLDER'], zip_file, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

This code directly integrates the frame processing and video zooming functionality within the Flask application itself, eliminating the need for the `zoom_utils` module. Let me know if you need further assistance!
user
@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    zip_file = f'{filename.split(".")[0]}_zoomed_videos.zip'
    zip_path = os.path.join(app.config['UPLOAD_FOLDER'], zip_file)
    os.system(f'zip -r {zip_path} {zoomed_directory}')
    return send_from_directory(app.config['UPLOAD_FOLDER'], zip_file, as_attachment=True)
what is this zip stufff about
ChatGPT
This route `/download/<filename>` is responsible for creating a zip file containing all the zoomed videos generated from the input video file and then sending this zip file as an attachment for the user to download.

Here's how it works:

1. The `zoomed_directory` variable holds the path to the directory where the zoomed videos are stored.
2. The `zip_file` variable is created by taking the filename provided in the URL and replacing the extension with `_zoomed_videos.zip`. This will be the name of the zip file that will contain all the zoomed videos.
3. `zip_path` is the full path where the zip file will be saved. It's the combination of the upload folder and the zip file name.
4. `os.system(f'zip -r {zip_path} {zoomed_directory}')` creates a zip file named `zip_file` containing all the files in the `zoomed_directory`.
5. Finally, `send_from_directory(app.config['UPLOAD_FOLDER'], zip_file, as_attachment=True)` sends the zip file as an attachment for download. The `as_attachment=True` parameter ensures that the browser treats the file as an attachment and prompts the user to download it instead of displaying it in the browser.

This process allows users to download all the zoomed videos generated from the input video in a single zip file. Let me know if you have further questions!
user
did i ask for that to be added ... SIMPLE SIMPLE NO ZIP JUNK 
ChatGPT
Got it, let's simplify the download functionality and remove the zip file creation. We'll just provide direct download links to each zoomed video instead. Here's the updated route:

```python
@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    return send_from_directory(zoomed_directory, filename, as_attachment=True)
```

With this change, when a user visits the `/download/<filename>` route, they will be prompted to download the individual zoomed video file directly, instead of downloading a zip file containing all the zoomed videos.

Let me know if you need further assistance!
user
i need the whole script with logging
ChatGPT
Sure, here's the complete Flask application script with logging integrated:

```python
import os
import cv2
import numpy as np
from flask import Flask, render_template, request, redirect, url_for, send_from_directory
import logging

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_frame = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        # Check if the frame is different from the previous frame
        if prev_frame is None or not np.array_equal(frame, prev_frame):
            unique_frames.append(frame)
            prev_frame = frame

    cap.release()
    return unique_frames, fps

def create_zoom_video(frames, output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50):
    logging.info(f"Creating zoomed video: {output_video_path}")
    # Define video codec and create VideoWriter object
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))

    for frame in frames:
        # Apply zoom effect to the frame
        zoomed_frames = interpolate_zoom(frame, zoom_factor, num_frames_zoom)

        # Add frames to video writer
        for zoomed_frame in zoomed_frames:
            video_writer.write(zoomed_frame)

    video_writer.release()

def interpolate_zoom(frame, zoom_factor, num_frames_zoom):
    zoomed_frames = []
    for i in range(num_frames_zoom):
        # Interpolate zoom factor
        current_zoom = 1 + (zoom_factor - 1) * (i / (num_frames_zoom - 1))

        # Apply zoom effect to the frame
        zoomed_frame = zoom_frame(frame, current_zoom)

        zoomed_frames.append(zoomed_frame)

    return zoomed_frames

def zoom_frame(frame, zoom_factor):
    # Get frame dimensions
    height, width = frame.shape[:2]

    # Compute new dimensions after zooming
    new_width = int(width * zoom_factor)
    new_height = int(height * zoom_factor)

    # Resize the frame to apply the zoom effect
    zoomed_frame = cv2.resize(frame, (new_width, new_height))

    # Compute cropping coordinates to maintain original size and zoom to center
    crop_x1 = (new_width - width) // 2
    crop_x2 = crop_x1 + width
    crop_y1 = (new_height - height) // 2
    crop_y2 = crop_y1 + height

    # Crop the zoomed frame to original dimensions
    zoomed_frame = zoomed_frame[crop_y1:crop_y2, crop_x1:crop_x2]

    return zoomed_frame

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            logging.info(f"File uploaded: {filename}")
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    # Extract unique frames from the input video
    unique_frames, fps = extract_unique_frames(input_video_path)

    # Create zoomed video for each frame
    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    logging.info(f"Zoomed videos created for: {filename}")
    return redirect(url_for('index'))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    return send_from_directory(zoomed_directory, filename, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

This script includes logging statements throughout various parts of the application. The logs are written to a file named `app.log` in the same directory as the script. Let me know if you need further assistance!
user
will that make folders if they dont exist?
ChatGPT
No, the current implementation does not automatically create the `uploads` and `zoomed_videos` folders if they do not exist. We can modify the script to create these folders if they are missing. Here's the updated script with folder creation logic:

```python
import os
import cv2
import numpy as np
from flask import Flask, render_template, request, redirect, url_for, send_from_directory
import logging

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_folders_exist():
    if not os.path.exists(UPLOAD_FOLDER):
        os.makedirs(UPLOAD_FOLDER)
    if not os.path.exists(ZOOMED_FOLDER):
        os.makedirs(ZOOMED_FOLDER)

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_frame = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        # Check if the frame is different from the previous frame
        if prev_frame is None or not np.array_equal(frame, prev_frame):
            unique_frames.append(frame)
            prev_frame = frame

    cap.release()
    return unique_frames, fps

def create_zoom_video(frames, output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50):
    logging.info(f"Creating zoomed video: {output_video_path}")
    # Define video codec and create VideoWriter object
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))

    for frame in frames:
        # Apply zoom effect to the frame
        zoomed_frames = interpolate_zoom(frame, zoom_factor, num_frames_zoom)

        # Add frames to video writer
        for zoomed_frame in zoomed_frames:
            video_writer.write(zoomed_frame)

    video_writer.release()

def interpolate_zoom(frame, zoom_factor, num_frames_zoom):
    zoomed_frames = []
    for i in range(num_frames_zoom):
        # Interpolate zoom factor
        current_zoom = 1 + (zoom_factor - 1) * (i / (num_frames_zoom - 1))

        # Apply zoom effect to the frame
        zoomed_frame = zoom_frame(frame, current_zoom)

        zoomed_frames.append(zoomed_frame)

    return zoomed_frames

def zoom_frame(frame, zoom_factor):
    # Get frame dimensions
    height, width = frame.shape[:2]

    # Compute new dimensions after zooming
    new_width = int(width * zoom_factor)
    new_height = int(height * zoom_factor)

    # Resize the frame to apply the zoom effect
    zoomed_frame = cv2.resize(frame, (new_width, new_height))

    # Compute cropping coordinates to maintain original size and zoom to center
    crop_x1 = (new_width - width) // 2
    crop_x2 = crop_x1 + width
    crop_y1 = (new_height - height) // 2
    crop_y2 = crop_y1 + height

    # Crop the zoomed frame to original dimensions
    zoomed_frame = zoomed_frame[crop_y1:crop_y2, crop_x1:crop_x2]

    return zoomed_frame

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    ensure_folders_exist()
    
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            logging.info(f"File uploaded: {filename}")
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    ensure_folders_exist()

    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    # Extract unique frames from the input video
    unique_frames, fps = extract_unique_frames(input_video_path)

    # Create zoomed video for each frame
    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    logging.info(f"Zoomed videos created for: {filename}")
    return redirect(url_for('index'))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    return send_from_directory(zoomed_directory, filename, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

Now, the `ensure_folders_exist()` function is called at the beginning of the `upload_file()` and `process_video()` routes to ensure that the `uploads` and `zoomed_videos` folders are created before attempting to save files into them. Let me know if you need further assistance!
user
you did not use hash to get unique images. I have thousands of identical videos
ChatGPT
You're correct. Let's reintegrate the hash-based approach to ensure that only unique frames are extracted. We'll use the `imagehash` library to calculate the hash of each frame and compare it with the hashes of previously extracted frames to ensure uniqueness. Here's the updated `extract_unique_frames()` function:

```python
import imagehash

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_hash = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        # Calculate hash of the frame
        hash_value = calculate_hash(frame)

        # Check if the hash is different from the previous frame
        if prev_hash is None or hash_value != prev_hash:
            unique_frames.append(frame)
            prev_hash = hash_value

    cap.release()
    return unique_frames, fps

def calculate_hash(frame):
    # Convert frame to grayscale
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Calculate hash using average hashing (aHash)
    hash_value = imagehash.average_hash(Image.fromarray(gray_frame))

    return hash_value
```

With this implementation, only frames with unique hashes will be considered, ensuring that duplicate frames are not included in the list of unique frames. Let me know if you need further assistance!
user
coul you send the complete script
ChatGPT
Certainly! Here's the complete Flask application script with the reintegrated hash-based approach for extracting unique frames:

```python
import os
import cv2
import numpy as np
from flask import Flask, render_template, request, redirect, url_for, send_from_directory
import logging
import imagehash
from PIL import Image

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_folders_exist():
    if not os.path.exists(UPLOAD_FOLDER):
        os.makedirs(UPLOAD_FOLDER)
    if not os.path.exists(ZOOMED_FOLDER):
        os.makedirs(ZOOMED_FOLDER)

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_hash = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        # Calculate hash of the frame
        hash_value = calculate_hash(frame)

        # Check if the hash is different from the previous frame
        if prev_hash is None or hash_value != prev_hash:
            unique_frames.append(frame)
            prev_hash = hash_value

    cap.release()
    return unique_frames, fps

def calculate_hash(frame):
    # Convert frame to grayscale
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Calculate hash using average hashing (aHash)
    hash_value = imagehash.average_hash(Image.fromarray(gray_frame))

    return hash_value

def create_zoom_video(frames, output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50):
    logging.info(f"Creating zoomed video: {output_video_path}")
    # Define video codec and create VideoWriter object
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))

    for frame in frames:
        # Apply zoom effect to the frame
        zoomed_frames = interpolate_zoom(frame, zoom_factor, num_frames_zoom)

        # Add frames to video writer
        for zoomed_frame in zoomed_frames:
            video_writer.write(zoomed_frame)

    video_writer.release()

def interpolate_zoom(frame, zoom_factor, num_frames_zoom):
    zoomed_frames = []
    for i in range(num_frames_zoom):
        # Interpolate zoom factor
        current_zoom = 1 + (zoom_factor - 1) * (i / (num_frames_zoom - 1))

        # Apply zoom effect to the frame
        zoomed_frame = zoom_frame(frame, current_zoom)

        zoomed_frames.append(zoomed_frame)

    return zoomed_frames

def zoom_frame(frame, zoom_factor):
    # Get frame dimensions
    height, width = frame.shape[:2]

    # Compute new dimensions after zooming
    new_width = int(width * zoom_factor)
    new_height = int(height * zoom_factor)

    # Resize the frame to apply the zoom effect
    zoomed_frame = cv2.resize(frame, (new_width, new_height))

    # Compute cropping coordinates to maintain original size and zoom to center
    crop_x1 = (new_width - width) // 2
    crop_x2 = crop_x1 + width
    crop_y1 = (new_height - height) // 2
    crop_y2 = crop_y1 + height

    # Crop the zoomed frame to original dimensions
    zoomed_frame = zoomed_frame[crop_y1:crop_y2, crop_x1:crop_x2]

    return zoomed_frame

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    ensure_folders_exist()
    
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            logging.info(f"File uploaded: {filename}")
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    ensure_folders_exist()

    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    # Extract unique frames from the input video
    unique_frames, fps = extract_unique_frames(input_video_path)

    # Create zoomed video for each frame
    for i, frame in enumerate(unique_frames):
        output_video
user
it is not complete
ChatGPT
My apologies for the interruption. Here's the continuation and completion of the script:

```python
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    logging.info(f"Zoomed videos created for: {filename}")
    return redirect(url_for('index'))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    return send_from_directory(zoomed_directory, filename, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

This should now be the complete Flask application script. Let me know if you need further assistance!
user
you cant put them together complete ?
ChatGPT
Apologies for the oversight. Here's the complete Flask application script with all the sections combined:

```python
import os
import cv2
import numpy as np
from flask import Flask, render_template, request, redirect, url_for, send_from_directory
import logging
import imagehash
from PIL import Image

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_folders_exist():
    if not os.path.exists(UPLOAD_FOLDER):
        os.makedirs(UPLOAD_FOLDER)
    if not os.path.exists(ZOOMED_FOLDER):
        os.makedirs(ZOOMED_FOLDER)

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_hash = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        # Calculate hash of the frame
        hash_value = calculate_hash(frame)

        # Check if the hash is different from the previous frame
        if prev_hash is None or hash_value != prev_hash:
            unique_frames.append(frame)
            prev_hash = hash_value

    cap.release()
    return unique_frames, fps

def calculate_hash(frame):
    # Convert frame to grayscale
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Calculate hash using average hashing (aHash)
    hash_value = imagehash.average_hash(Image.fromarray(gray_frame))

    return hash_value

def create_zoom_video(frames, output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50):
    logging.info(f"Creating zoomed video: {output_video_path}")
    # Define video codec and create VideoWriter object
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))

    for frame in frames:
        # Apply zoom effect to the frame
        zoomed_frames = interpolate_zoom(frame, zoom_factor, num_frames_zoom)

        # Add frames to video writer
        for zoomed_frame in zoomed_frames:
            video_writer.write(zoomed_frame)

    video_writer.release()

def interpolate_zoom(frame, zoom_factor, num_frames_zoom):
    zoomed_frames = []
    for i in range(num_frames_zoom):
        # Interpolate zoom factor
        current_zoom = 1 + (zoom_factor - 1) * (i / (num_frames_zoom - 1))

        # Apply zoom effect to the frame
        zoomed_frame = zoom_frame(frame, current_zoom)

        zoomed_frames.append(zoomed_frame)

    return zoomed_frames

def zoom_frame(frame, zoom_factor):
    # Get frame dimensions
    height, width = frame.shape[:2]

    # Compute new dimensions after zooming
    new_width = int(width * zoom_factor)
    new_height = int(height * zoom_factor)

    # Resize the frame to apply the zoom effect
    zoomed_frame = cv2.resize(frame, (new_width, new_height))

    # Compute cropping coordinates to maintain original size and zoom to center
    crop_x1 = (new_width - width) // 2
    crop_x2 = crop_x1 + width
    crop_y1 = (new_height - height) // 2
    crop_y2 = crop_y1 + height

    # Crop the zoomed frame to original dimensions
    zoomed_frame = zoomed_frame[crop_y1:crop_y2, crop_x1:crop_x2]

    return zoomed_frame

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    ensure_folders_exist()
    
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            logging.info(f"File uploaded: {filename}")
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    ensure_folders_exist()

    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    # Extract unique frames from the input video
    unique_frames, fps = extract_unique_frames(input_video_path)

    # Create zoomed video for each frame
    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    logging.info(f"Zoomed videos created for: {filename}")
    return redirect(url_for('index'))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    return send_from_directory(zoomed_directory, filename, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

This script should now be complete and ready to run. Let me know if you need further assistance!
user
This works fine
ChatGPT
Great to hear that it's working fine! If you have any further questions or need additional assistance, feel free to ask. Happy coding, Jack! 😊
user
@app.route('/reverse_and_concatenate', methods=['POST', 'GET'])
def reverse_and_concatenate_video(input_video, output_video):
    try:
        if not os.path.exists(input_video):
            logging.error(f"Input video '{input_video}' not found.")
            return
        
        # Step 1: Reverse the input video
        reversed_video = "reversed_" + input_video
        reverse_command = ["ffmpeg","-hide_banner" ,"-i", input_video, "-vf", "reverse", "-an", "-y",reversed_video]
        logging.info("Reversing the input video...")
        subprocess.run(reverse_command, check=True)

        # Step 2: Concatenate the original and reversed videos
        concat_command = [
            "ffmpeg",
            "-i", input_video,
            "-i", reversed_video,
            "-filter_complex", "[0:v][1:v]concat=n=2:v=1:a=0[outv]",
            "-map", "[outv]", "-y" ,
            output_video
        ]
        logging.info("Concatenating the original and reversed videos...")
        subprocess.run(concat_command, check=True)

        logging.info("Video concatenation completed successfully!")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error occurred: {e}")
        
    mp4_files = glob.glob("zoomed_videos/*.mp4")
    for mp4_file in mp4_files:
        input_video = mp4_file
        output_video = "output"+input_video
        reverse_and_concatenate_video(input_video, output_video)
    return redirect(url_for('index')) 
this is not working TypeError

TypeError: reverse_and_concatenate_video() missing 2 required positional arguments: 'input_video' and 'output_video'

ChatGPT
It looks like you're trying to call the `reverse_and_concatenate_video` function directly, but it's designed to be used as a route handler in Flask. To fix this, you need to modify the function so it can handle the input video paths dynamically, and then properly call the function within the route. Let's adjust the code accordingly:

1. Separate the video processing logic into a standalone function.
2. Create the route handler that will call this function with appropriate parameters.

Here's the corrected code:

```python
import os
import subprocess
import glob
import logging
from flask import Flask, render_template, request, redirect, url_for

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_folders_exist():
    if not os.path.exists(UPLOAD_FOLDER):
        os.makedirs(UPLOAD_FOLDER)
    if not os.path.exists(ZOOMED_FOLDER):
        os.makedirs(ZOOMED_FOLDER)

def reverse_and_concatenate_video(input_video, output_video):
    try:
        if not os.path.exists(input_video):
            logging.error(f"Input video '{input_video}' not found.")
            return
        
        # Step 1: Reverse the input video
        reversed_video = "reversed_" + os.path.basename(input_video)
        reverse_command = ["ffmpeg", "-hide_banner", "-i", input_video, "-vf", "reverse", "-an", "-y", reversed_video]
        logging.info("Reversing the input video...")
        subprocess.run(reverse_command, check=True)

        # Step 2: Concatenate the original and reversed videos
        concat_command = [
            "ffmpeg",
            "-i", input_video,
            "-i", reversed_video,
            "-filter_complex", "[0:v][1:v]concat=n=2:v=1:a=0[outv]",
            "-map", "[outv]", "-y",
            output_video
        ]
        logging.info("Concatenating the original and reversed videos...")
        subprocess.run(concat_command, check=True)

        logging.info("Video concatenation completed successfully!")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error occurred: {e}")

@app.route('/reverse_and_concatenate', methods=['POST'])
def reverse_and_concatenate_route():
    ensure_folders_exist()
    
    mp4_files = glob.glob(os.path.join(ZOOMED_FOLDER, "*.mp4"))
    for mp4_file in mp4_files:
        input_video = mp4_file
        output_video = os.path.join(ZOOMED_FOLDER, "output_" + os.path.basename(input_video))
        reverse_and_concatenate_video(input_video, output_video)
    
    return redirect(url_for('index'))

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    ensure_folders_exist()
    
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            logging.info(f"File uploaded: {filename}")
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    ensure_folders_exist()

    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    # Extract unique frames from the input video
    unique_frames, fps = extract_unique_frames(input_video_path)

    # Create zoomed video for each frame
    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    logging.info(f"Zoomed videos created for: {filename}")
    return redirect(url_for('index'))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    return send_from_directory(zoomed_directory, filename, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

### Explanation:
1. **Standalone Function**: `reverse_and_concatenate_video` is a standalone function that can be called with parameters `input_video` and `output_video`.
2. **Route Handler**: The route `/reverse_and_concatenate` calls this function for each MP4 file in the `zoomed_videos` folder and then redirects to the index page.

This setup ensures that the `reverse_and_concatenate_video` function is correctly called with the necessary parameters without any TypeError.
user
i should have sent the entire script
it creates the zoomed videos fine. i want to also create the zoom and concatenate after the zoomed videos are finished if run all at once automatically that would even be better
ChatGPT
Got it! Let's integrate the functionality to automatically reverse and concatenate the zoomed videos after they are created. I'll provide the complete script for the Flask application with this additional feature.

### Complete Flask Application Script:

```python
import os
import cv2
import numpy as np
from flask import Flask, render_template, request, redirect, url_for, send_from_directory
import logging
import subprocess
import glob
import imagehash
from PIL import Image

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_folders_exist():
    if not os.path.exists(UPLOAD_FOLDER):
        os.makedirs(UPLOAD_FOLDER)
    if not os.path.exists(ZOOMED_FOLDER):
        os.makedirs(ZOOMED_FOLDER)

def calculate_hash(frame):
    # Convert frame to grayscale
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Calculate hash using average hashing (aHash)
    hash_value = imagehash.average_hash(Image.fromarray(gray_frame))

    return hash_value

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_hash = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        # Calculate hash of the frame
        hash_value = calculate_hash(frame)

        # Check if the hash is different from the previous frame
        if prev_hash is None or hash_value != prev_hash:
            unique_frames.append(frame)
            prev_hash = hash_value

    cap.release()
    return unique_frames, fps

def create_zoom_video(frames, output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50):
    logging.info(f"Creating zoomed video: {output_video_path}")
    # Define video codec and create VideoWriter object
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))

    for frame in frames:
        # Apply zoom effect to the frame
        zoomed_frames = interpolate_zoom(frame, zoom_factor, num_frames_zoom)

        # Add frames to video writer
        for zoomed_frame in zoomed_frames:
            video_writer.write(zoomed_frame)

    video_writer.release()

def interpolate_zoom(frame, zoom_factor, num_frames_zoom):
    zoomed_frames = []
    for i in range(num_frames_zoom):
        # Interpolate zoom factor
        current_zoom = 1 + (zoom_factor - 1) * (i / (num_frames_zoom - 1))

        # Apply zoom effect to the frame
        zoomed_frame = zoom_frame(frame, current_zoom)

        zoomed_frames.append(zoomed_frame)

    return zoomed_frames

def zoom_frame(frame, zoom_factor):
    # Get frame dimensions
    height, width = frame.shape[:2]

    # Compute new dimensions after zooming
    new_width = int(width * zoom_factor)
    new_height = int(height * zoom_factor)

    # Resize the frame to apply the zoom effect
    zoomed_frame = cv2.resize(frame, (new_width, new_height))

    # Compute cropping coordinates to maintain original size and zoom to center
    crop_x1 = (new_width - width) // 2
    crop_x2 = crop_x1 + width
    crop_y1 = (new_height - height) // 2
    crop_y2 = crop_y1 + height

    # Crop the zoomed frame to original dimensions
    zoomed_frame = zoomed_frame[crop_y1:crop_y2, crop_x1:crop_x2]

    return zoomed_frame

def reverse_and_concatenate_video(input_video, output_video):
    try:
        if not os.path.exists(input_video):
            logging.error(f"Input video '{input_video}' not found.")
            return
        
        # Step 1: Reverse the input video
        reversed_video = "reversed_" + os.path.basename(input_video)
        reverse_command = ["ffmpeg", "-hide_banner", "-i", input_video, "-vf", "reverse", "-an", "-y", reversed_video]
        logging.info("Reversing the input video...")
        subprocess.run(reverse_command, check=True)

        # Step 2: Concatenate the original and reversed videos
        concat_command = [
            "ffmpeg",
            "-i", input_video,
            "-i", reversed_video,
            "-filter_complex", "[0:v][1:v]concat=n=2:v=1:a=0[outv]",
            "-map", "[outv]", "-y",
            output_video
        ]
        logging.info("Concatenating the original and reversed videos...")
        subprocess.run(concat_command, check=True)

        logging.info("Video concatenation completed successfully!")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error occurred: {e}")

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    ensure_folders_exist()
    
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
            logging.info(f"File uploaded: {filename}")
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    ensure_folders_exist()

    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    # Extract unique frames from the input video
    unique_frames, fps = extract_unique_frames(input_video_path)

    # Create zoomed video for each frame
    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    # After creating zoomed videos, reverse and concatenate them
    mp4_files = glob.glob(os.path.join(output_video_directory, "*.mp4"))
    for mp4_file in mp4_files:
        reversed_and_concatenated_output = os.path.join(output_video_directory, "concatenated_" + os.path.basename(mp4_file))
        reverse_and_concatenate_video(mp4_file, reversed_and_concatenated_output)

    logging.info(f"Zoomed, reversed, and concatenated videos created for: {filename}")
    return redirect(url_for('index'))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    return send_from_directory(zoomed_directory, filename, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

### Explanation:
1. **Folders Creation**: Ensures the necessary folders exist before processing.
2. **File Upload**: Handles file upload and saves the file to the `uploads` folder.
3. **Processing Video**: Extracts unique frames, creates zoomed videos, and then reverses and concatenates these videos.
4. **Reversal and Concatenation**: After creating the zoomed videos, the script automatically processes each video to create a reversed and concatenated version.
5. **Download Endpoint**: Provides a route to download the processed videos.

This script should now cover the full process from uploading the video, creating zoomed videos, reversing, concatenating, and finally providing a way to download the final video.
user
@app.route('/')
def index():
    content = '''
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Upload Video</title>
    </head>
    <body>
        <h1>Upload Video</h1>
        <form action="/upload" method="post" enctype="multipart/form-data">
            <input type="file" name="file" accept=".mp4">
            <input type="submit" value="Upload">
        </form>
    </body>
    </html>
    '''
    return content

ChatGPT
Here's the complete updated script with the HTML form defined in the `index` route, integrated logging, and the entire process from uploading to creating zoomed, reversed, and concatenated videos:

```python
import os
import cv2
import numpy as np
from flask import Flask, request, redirect, url_for, send_from_directory
import logging
import subprocess
import glob
import imagehash
from PIL import Image

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_folders_exist():
    if not os.path.exists(UPLOAD_FOLDER):
        os.makedirs(UPLOAD_FOLDER)
    if not os.path.exists(ZOOMED_FOLDER):
        os.makedirs(ZOOMED_FOLDER)

def calculate_hash(frame):
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    hash_value = imagehash.average_hash(Image.fromarray(gray_frame))
    return hash_value

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_hash = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        hash_value = calculate_hash(frame)

        if prev_hash is None or hash_value != prev_hash:
            unique_frames.append(frame)
            prev_hash = hash_value

    cap.release()
    return unique_frames, fps

def create_zoom_video(frames, output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50):
    logging.info(f"Creating zoomed video: {output_video_path}")
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))

    for frame in frames:
        zoomed_frames = interpolate_zoom(frame, zoom_factor, num_frames_zoom)
        for zoomed_frame in zoomed_frames:
            video_writer.write(zoomed_frame)

    video_writer.release()

def interpolate_zoom(frame, zoom_factor, num_frames_zoom):
    zoomed_frames = []
    for i in range(num_frames_zoom):
        current_zoom = 1 + (zoom_factor - 1) * (i / (num_frames_zoom - 1))
        zoomed_frame = zoom_frame(frame, current_zoom)
        zoomed_frames.append(zoomed_frame)
    return zoomed_frames

def zoom_frame(frame, zoom_factor):
    height, width = frame.shape[:2]
    new_width = int(width * zoom_factor)
    new_height = int(height * zoom_factor)
    zoomed_frame = cv2.resize(frame, (new_width, new_height))

    crop_x1 = (new_width - width) // 2
    crop_x2 = crop_x1 + width
    crop_y1 = (new_height - height) // 2
    crop_y2 = crop_y1 + height

    zoomed_frame = zoomed_frame[crop_y1:crop_y2, crop_x1:crop_x2]
    return zoomed_frame

def reverse_and_concatenate_video(input_video, output_video):
    try:
        if not os.path.exists(input_video):
            logging.error(f"Input video '{input_video}' not found.")
            return

        reversed_video = "reversed_" + os.path.basename(input_video)
        reverse_command = ["ffmpeg", "-hide_banner", "-i", input_video, "-vf", "reverse", "-an", "-y", reversed_video]
        logging.info("Reversing the input video...")
        subprocess.run(reverse_command, check=True)

        concat_command = [
            "ffmpeg",
            "-i", input_video,
            "-i", reversed_video,
            "-filter_complex", "[0:v][1:v]concat=n=2:v=1:a=0[outv]",
            "-map", "[outv]", "-y",
            output_video
        ]
        logging.info("Concatenating the original and reversed videos...")
        subprocess.run(concat_command, check=True)

        logging.info("Video concatenation completed successfully!")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error occurred: {e}")

@app.route('/')
def index():
    content = '''
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Upload Video</title>
    </head>
    <body>
        <h1>Upload Video</h1>
        <form action="/upload" method="post" enctype="multipart/form-data">
            <input type="file" name="file" accept=".mp4">
            <input type="submit" value="Upload">
        </form>
    </body>
    </html>
    '''
    return content

@app.route('/upload', methods=['POST'])
def upload_file():
    ensure_folders_exist()
    
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(file_path)
            logging.info(f"File uploaded: {filename}")
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    ensure_folders_exist()

    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    unique_frames, fps = extract_unique_frames(input_video_path)

    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    mp4_files = glob.glob(os.path.join(output_video_directory, "*.mp4"))
    for mp4_file in mp4_files:
        reversed_and_concatenated_output = os.path.join(output_video_directory, "concatenated_" + os.path.basename(mp4_file))
        reverse_and_concatenate_video(mp4_file, reversed_and_concatenated_output)

    logging.info(f"Zoomed, reversed, and concatenated videos created for: {filename}")
    return redirect(url_for('index'))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    return send_from_directory(zoomed_directory, filename, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

### Key Points:
1. **Folders Creation**: Ensures the necessary folders exist before processing.
2. **File Upload**: Handles file upload and saves the file to the `uploads` folder.
3. **Processing Video**: Extracts unique frames, creates zoomed videos, and then reverses and concatenates these videos.
4. **Reversal and Concatenation**: After creating the zoomed videos, the script automatically processes each video to create a reversed and concatenated version.
5. **Download Endpoint**: Provides a route to download the processed videos.
6. **Logging**: Comprehensive logging to help with debugging and understanding the flow of the application.
user
concat_command = [
            "ffmpeg",
            "-i", input_video,
            "-i", reversed_video,
            "-filter_complex", "[0:v][1:v]concat=n=2:v=1:a=0[outv]",
            "-map", "[outv]", "-y",
            output_video
        ]can it be slowed by 50% here ?
ChatGPT
Yes, you can slow down the concatenated video by 50% using FFmpeg. To do this, you'll need to adjust the filter complex to include the `setpts` filter, which changes the presentation timestamp of the frames, effectively slowing down the video. Here's how you can modify the `concat_command` to achieve this:

1. Concatenate the videos.
2. Slow down the concatenated video using the `setpts` filter.

Here's the modified `concat_command`:

```python
concat_command = [
    "ffmpeg",
    "-i", input_video,
    "-i", reversed_video,
    "-filter_complex", "[0:v][1:v]concat=n=2:v=1:a=0, setpts=2*PTS[outv]",
    "-map", "[outv]", "-y",
    output_video
]
```

### Explanation:
- `concat=n=2:v=1:a=0`: Concatenates two video streams (no audio streams).
- `setpts=2*PTS`: This filter will slow down the video by 50%. The `2*PTS` means that each frame's presentation timestamp is doubled, effectively slowing down the video playback to half speed.

Here is the updated script with the modified `concat_command`:

```python
import os
import cv2
import numpy as np
from flask import Flask, request, redirect, url_for, send_from_directory
import logging
import subprocess
import glob
import imagehash
from PIL import Image

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ZOOMED_FOLDER = 'zoomed_videos'
ALLOWED_EXTENSIONS = {'mp4'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['ZOOMED_FOLDER'] = ZOOMED_FOLDER

logging.basicConfig(filename='app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def ensure_folders_exist():
    if not os.path.exists(UPLOAD_FOLDER):
        os.makedirs(UPLOAD_FOLDER)
    if not os.path.exists(ZOOMED_FOLDER):
        os.makedirs(ZOOMED_FOLDER)

def calculate_hash(frame):
    gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    hash_value = imagehash.average_hash(Image.fromarray(gray_frame))
    return hash_value

def extract_unique_frames(input_video_path):
    cap = cv2.VideoCapture(input_video_path)
    fps = cap.get(cv2.CAP_PROP_FPS)

    unique_frames = []
    prev_hash = None

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        hash_value = calculate_hash(frame)

        if prev_hash is None or hash_value != prev_hash:
            unique_frames.append(frame)
            prev_hash = hash_value

    cap.release()
    return unique_frames, fps

def create_zoom_video(frames, output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50):
    logging.info(f"Creating zoomed video: {output_video_path}")
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(output_video_path, fourcc, fps, (frames[0].shape[1], frames[0].shape[0]))

    for frame in frames:
        zoomed_frames = interpolate_zoom(frame, zoom_factor, num_frames_zoom)
        for zoomed_frame in zoomed_frames:
            video_writer.write(zoomed_frame)

    video_writer.release()

def interpolate_zoom(frame, zoom_factor, num_frames_zoom):
    zoomed_frames = []
    for i in range(num_frames_zoom):
        current_zoom = 1 + (zoom_factor - 1) * (i / (num_frames_zoom - 1))
        zoomed_frame = zoom_frame(frame, current_zoom)
        zoomed_frames.append(zoomed_frame)
    return zoomed_frames

def zoom_frame(frame, zoom_factor):
    height, width = frame.shape[:2]
    new_width = int(width * zoom_factor)
    new_height = int(height * zoom_factor)
    zoomed_frame = cv2.resize(frame, (new_width, new_height))

    crop_x1 = (new_width - width) // 2
    crop_x2 = crop_x1 + width
    crop_y1 = (new_height - height) // 2
    crop_y2 = crop_y1 + height

    zoomed_frame = zoomed_frame[crop_y1:crop_y2, crop_x1:crop_x2]
    return zoomed_frame

def reverse_and_concatenate_video(input_video, output_video):
    try:
        if not os.path.exists(input_video):
            logging.error(f"Input video '{input_video}' not found.")
            return

        reversed_video = "reversed_" + os.path.basename(input_video)
        reverse_command = ["ffmpeg", "-hide_banner", "-i", input_video, "-vf", "reverse", "-an", "-y", reversed_video]
        logging.info("Reversing the input video...")
        subprocess.run(reverse_command, check=True)

        concat_command = [
            "ffmpeg",
            "-i", input_video,
            "-i", reversed_video,
            "-filter_complex", "[0:v][1:v]concat=n=2:v=1:a=0, setpts=2*PTS[outv]",
            "-map", "[outv]", "-y",
            output_video
        ]
        logging.info("Concatenating the original and reversed videos...")
        subprocess.run(concat_command, check=True)

        logging.info("Video concatenation completed successfully!")
    except subprocess.CalledProcessError as e:
        logging.error(f"Error occurred: {e}")

@app.route('/')
def index():
    content = '''
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Upload Video</title>
    </head>
    <body>
        <h1>Upload Video</h1>
        <form action="/upload" method="post" enctype="multipart/form-data">
            <input type="file" name="file" accept=".mp4">
            <input type="submit" value="Upload">
        </form>
    </body>
    </html>
    '''
    return content

@app.route('/upload', methods=['POST'])
def upload_file():
    ensure_folders_exist()
    
    if request.method == 'POST':
        if 'file' not in request.files:
            return redirect(request.url)
        file = request.files['file']
        if file.filename == '':
            return redirect(request.url)
        if file and allowed_file(file.filename):
            filename = file.filename
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            file.save(file_path)
            logging.info(f"File uploaded: {filename}")
            return redirect(url_for('process_video', filename=filename))
    return redirect(url_for('index'))

@app.route('/process/<filename>')
def process_video(filename):
    ensure_folders_exist()

    input_video_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    output_video_directory = app.config['ZOOMED_FOLDER']

    unique_frames, fps = extract_unique_frames(input_video_path)

    for i, frame in enumerate(unique_frames):
        output_video_path = os.path.join(output_video_directory, f"zoomed_video_{i}.mp4")
        create_zoom_video([frame], output_video_path, fps, zoom_factor=1.5, num_frames_zoom=50)

    mp4_files = glob.glob(os.path.join(output_video_directory, "*.mp4"))
    for mp4_file in mp4_files:
        reversed_and_concatenated_output = os.path.join(output_video_directory, "concatenated_" + os.path.basename(mp4_file))
        reverse_and_concatenate_video(mp4_file, reversed_and_concatenated_output)

    logging.info(f"Zoomed, reversed, and concatenated videos created for: {filename}")
    return redirect(url_for('index'))

@app.route('/download/<filename>')
def download_zoomed_videos(filename):
    zoomed_directory = app.config['ZOOMED_FOLDER']
    return send_from_directory(zoomed_directory, filename, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)
```

### Key Points:
1. **Concatenation Command**: The `setpts=2*PTS` filter in the `concat_command` slows down the video by 50%.
2. **Process Flow**: The script ensures the upload, processing, and reversing/concatenation of videos, then makes them available for download.
3. **Logging**: All significant steps in the process are logged for easier debugging and understanding of the process flow.

